var N = null;var searchIndex = {};
searchIndex["c_vec"]={"doc":"Library to interface with chunks of memory allocated in C.","items":[[3,"CVec","c_vec","The type representing a foreign chunk of memory",N,N],[3,"CSlice","","The type representing an 'unsafe' foreign chunk of memory",N,N],[11,"new","","Create a `CVec` from a raw pointer to a buffer with a given length.",0,N],[11,"new_with_dtor","","Create a `CVec` from a foreign buffer, with a given length, and a function to run upon destruction.",0,N],[11,"get","","Retrieves an element at a given index, returning `None` if the requested index is greater than the length of the vector.",0,[[["self"],["usize"]],["option"]]],[11,"get_mut","","Retrieves a mutable element at a given index, returning `None` if the requested index is greater than the length of the vector.",0,[[["self"],["usize"]],["option"]]],[11,"into_inner","","Unwrap the pointer without running the destructor",0,N],[11,"len","","Returns the number of items in this vector.",0,[[["self"]],["usize"]]],[11,"is_empty","","Returns whether this vector is empty.",0,[[["self"]],["bool"]]],[11,"as_cslice","","Convert to CSlice",0,[[["self"]],["cslice"]]],[11,"new","","Create a `CSlice` from a raw pointer to a buffer with a given length.",1,N],[11,"get","","Retrieves an element at a given index, returning `None` if the requested index is greater than the length of the vector.",1,[[["self"],["usize"]],["option"]]],[11,"get_mut","","Retrieves a mutable element at a given index, returning `None` if the requested index is greater than the length of the vector.",1,[[["self"],["usize"]],["option"]]],[11,"len","","Returns the number of items in this vector.",1,[[["self"]],["usize"]]],[11,"is_empty","","Returns whether this vector is empty.",1,[[["self"]],["bool"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"as_mut","","View the stored data as a slice.",0,N],[11,"as_mut","","View the stored data as a slice.",1,N],[11,"as_ref","","View the stored data as a slice.",0,N],[11,"as_ref","","View the stored data as a slice.",1,N],[11,"drop","","",0,[[["self"]]]],[11,"index","","",1,[[["self"],["usize"]],["t"]]],[11,"index_mut","","",1,[[["self"],["usize"]],["t"]]]],"paths":[[3,"CVec"],[3,"CSlice"]]};
searchIndex["cfg_if"]={"doc":"A macro for defining `#[cfg]` if-else statements.","items":[[14,"cfg_if","cfg_if","",N,N]],"paths":[]};
searchIndex["libc"]={"doc":"libc - Raw FFI bindings to platforms' system libraries","items":[[4,"c_void","libc","Equivalent to C's `void` type when used as a [pointer].",N,N],[3,"group","","",N,N],[12,"gr_name","","",0,N],[12,"gr_passwd","","",0,N],[12,"gr_gid","","",0,N],[12,"gr_mem","","",0,N],[3,"utimbuf","","",N,N],[12,"actime","","",1,N],[12,"modtime","","",1,N],[3,"timeval","","",N,N],[12,"tv_sec","","",2,N],[12,"tv_usec","","",2,N],[3,"timespec","","",N,N],[12,"tv_sec","","",3,N],[12,"tv_nsec","","",3,N],[3,"rlimit","","",N,N],[12,"rlim_cur","","",4,N],[12,"rlim_max","","",4,N],[3,"rusage","","",N,N],[12,"ru_utime","","",5,N],[12,"ru_stime","","",5,N],[12,"ru_maxrss","","",5,N],[12,"ru_ixrss","","",5,N],[12,"ru_idrss","","",5,N],[12,"ru_isrss","","",5,N],[12,"ru_minflt","","",5,N],[12,"ru_majflt","","",5,N],[12,"ru_nswap","","",5,N],[12,"ru_inblock","","",5,N],[12,"ru_oublock","","",5,N],[12,"ru_msgsnd","","",5,N],[12,"ru_msgrcv","","",5,N],[12,"ru_nsignals","","",5,N],[12,"ru_nvcsw","","",5,N],[12,"ru_nivcsw","","",5,N],[3,"ipv6_mreq","","",N,N],[12,"ipv6mr_multiaddr","","",6,N],[12,"ipv6mr_interface","","",6,N],[3,"hostent","","",N,N],[12,"h_name","","",7,N],[12,"h_aliases","","",7,N],[12,"h_addrtype","","",7,N],[12,"h_length","","",7,N],[12,"h_addr_list","","",7,N],[3,"iovec","","",N,N],[12,"iov_base","","",8,N],[12,"iov_len","","",8,N],[3,"pollfd","","",N,N],[12,"fd","","",9,N],[12,"events","","",9,N],[12,"revents","","",9,N],[3,"winsize","","",N,N],[12,"ws_row","","",10,N],[12,"ws_col","","",10,N],[12,"ws_xpixel","","",10,N],[12,"ws_ypixel","","",10,N],[3,"linger","","",N,N],[12,"l_onoff","","",11,N],[12,"l_linger","","",11,N],[3,"sigval","","",N,N],[12,"sival_ptr","","",12,N],[3,"itimerval","","",N,N],[12,"it_interval","","",13,N],[12,"it_value","","",13,N],[3,"tms","","",N,N],[12,"tms_utime","","",14,N],[12,"tms_stime","","",14,N],[12,"tms_cutime","","",14,N],[12,"tms_cstime","","",14,N],[3,"servent","","",N,N],[12,"s_name","","",15,N],[12,"s_aliases","","",15,N],[12,"s_port","","",15,N],[12,"s_proto","","",15,N],[3,"protoent","","",N,N],[12,"p_name","","",16,N],[12,"p_aliases","","",16,N],[12,"p_proto","","",16,N],[3,"in_addr","","",N,N],[12,"s_addr","","",17,N],[3,"ip_mreq","","",N,N],[12,"imr_multiaddr","","",18,N],[12,"imr_interface","","",18,N],[3,"sockaddr","","",N,N],[12,"sa_family","","",19,N],[12,"sa_data","","",19,N],[3,"sockaddr_in","","",N,N],[12,"sin_family","","",20,N],[12,"sin_port","","",20,N],[12,"sin_addr","","",20,N],[12,"sin_zero","","",20,N],[3,"sockaddr_in6","","",N,N],[12,"sin6_family","","",21,N],[12,"sin6_port","","",21,N],[12,"sin6_flowinfo","","",21,N],[12,"sin6_addr","","",21,N],[12,"sin6_scope_id","","",21,N],[3,"addrinfo","","",N,N],[12,"ai_flags","","",22,N],[12,"ai_family","","",22,N],[12,"ai_socktype","","",22,N],[12,"ai_protocol","","",22,N],[12,"ai_addrlen","","",22,N],[12,"ai_addr","","",22,N],[12,"ai_canonname","","",22,N],[12,"ai_next","","",22,N],[3,"sockaddr_nl","","",N,N],[12,"nl_family","","",23,N],[12,"nl_pid","","",23,N],[12,"nl_groups","","",23,N],[3,"sockaddr_ll","","",N,N],[12,"sll_family","","",24,N],[12,"sll_protocol","","",24,N],[12,"sll_ifindex","","",24,N],[12,"sll_hatype","","",24,N],[12,"sll_pkttype","","",24,N],[12,"sll_halen","","",24,N],[12,"sll_addr","","",24,N],[3,"fd_set","","",N,N],[3,"tm","","",N,N],[12,"tm_sec","","",25,N],[12,"tm_min","","",25,N],[12,"tm_hour","","",25,N],[12,"tm_mday","","",25,N],[12,"tm_mon","","",25,N],[12,"tm_year","","",25,N],[12,"tm_wday","","",25,N],[12,"tm_yday","","",25,N],[12,"tm_isdst","","",25,N],[12,"tm_gmtoff","","",25,N],[12,"tm_zone","","",25,N],[3,"sched_param","","",N,N],[12,"sched_priority","","",26,N],[3,"Dl_info","","",N,N],[12,"dli_fname","","",27,N],[12,"dli_fbase","","",27,N],[12,"dli_sname","","",27,N],[12,"dli_saddr","","",27,N],[3,"lconv","","",N,N],[12,"decimal_point","","",28,N],[12,"thousands_sep","","",28,N],[12,"grouping","","",28,N],[12,"int_curr_symbol","","",28,N],[12,"currency_symbol","","",28,N],[12,"mon_decimal_point","","",28,N],[12,"mon_thousands_sep","","",28,N],[12,"mon_grouping","","",28,N],[12,"positive_sign","","",28,N],[12,"negative_sign","","",28,N],[12,"int_frac_digits","","",28,N],[12,"frac_digits","","",28,N],[12,"p_cs_precedes","","",28,N],[12,"p_sep_by_space","","",28,N],[12,"n_cs_precedes","","",28,N],[12,"n_sep_by_space","","",28,N],[12,"p_sign_posn","","",28,N],[12,"n_sign_posn","","",28,N],[12,"int_p_cs_precedes","","",28,N],[12,"int_p_sep_by_space","","",28,N],[12,"int_n_cs_precedes","","",28,N],[12,"int_n_sep_by_space","","",28,N],[12,"int_p_sign_posn","","",28,N],[12,"int_n_sign_posn","","",28,N],[3,"sigevent","","",N,N],[12,"sigev_value","","",29,N],[12,"sigev_signo","","",29,N],[12,"sigev_notify","","",29,N],[12,"sigev_notify_thread_id","","",29,N],[3,"in_pktinfo","","",N,N],[12,"ipi_ifindex","","",30,N],[12,"ipi_spec_dst","","",30,N],[12,"ipi_addr","","",30,N],[3,"ifaddrs","","",N,N],[12,"ifa_next","","",31,N],[12,"ifa_name","","",31,N],[12,"ifa_flags","","",31,N],[12,"ifa_addr","","",31,N],[12,"ifa_netmask","","",31,N],[12,"ifa_ifu","","",31,N],[12,"ifa_data","","",31,N],[3,"in6_rtmsg","","",N,N],[3,"arpreq","","",N,N],[12,"arp_pa","","",32,N],[12,"arp_ha","","",32,N],[12,"arp_flags","","",32,N],[12,"arp_netmask","","",32,N],[12,"arp_dev","","",32,N],[3,"arpreq_old","","",N,N],[12,"arp_pa","","",33,N],[12,"arp_ha","","",33,N],[12,"arp_flags","","",33,N],[12,"arp_netmask","","",33,N],[3,"arphdr","","",N,N],[12,"ar_hrd","","",34,N],[12,"ar_pro","","",34,N],[12,"ar_hln","","",34,N],[12,"ar_pln","","",34,N],[12,"ar_op","","",34,N],[3,"inotify_event","","",N,N],[12,"wd","","",35,N],[12,"mask","","",35,N],[12,"cookie","","",35,N],[12,"len","","",35,N],[3,"mmsghdr","","",N,N],[12,"msg_hdr","","",36,N],[12,"msg_len","","",36,N],[3,"epoll_event","","",N,N],[12,"events","","",37,N],[12,"u64","","",37,N],[3,"sockaddr_un","","",N,N],[12,"sun_family","","",38,N],[12,"sun_path","","",38,N],[3,"sockaddr_storage","","",N,N],[12,"ss_family","","",39,N],[3,"utsname","","",N,N],[12,"sysname","","",40,N],[12,"nodename","","",40,N],[12,"release","","",40,N],[12,"version","","",40,N],[12,"machine","","",40,N],[12,"domainname","","",40,N],[3,"rlimit64","","",N,N],[12,"rlim_cur","","",41,N],[12,"rlim_max","","",41,N],[3,"glob_t","","",N,N],[12,"gl_pathc","","",42,N],[12,"gl_pathv","","",42,N],[12,"gl_offs","","",42,N],[12,"gl_flags","","",42,N],[3,"passwd","","",N,N],[12,"pw_name","","",43,N],[12,"pw_passwd","","",43,N],[12,"pw_uid","","",43,N],[12,"pw_gid","","",43,N],[12,"pw_gecos","","",43,N],[12,"pw_dir","","",43,N],[12,"pw_shell","","",43,N],[3,"spwd","","",N,N],[12,"sp_namp","","",44,N],[12,"sp_pwdp","","",44,N],[12,"sp_lstchg","","",44,N],[12,"sp_min","","",44,N],[12,"sp_max","","",44,N],[12,"sp_warn","","",44,N],[12,"sp_inact","","",44,N],[12,"sp_expire","","",44,N],[12,"sp_flag","","",44,N],[3,"dqblk","","",N,N],[12,"dqb_bhardlimit","","",45,N],[12,"dqb_bsoftlimit","","",45,N],[12,"dqb_curspace","","",45,N],[12,"dqb_ihardlimit","","",45,N],[12,"dqb_isoftlimit","","",45,N],[12,"dqb_curinodes","","",45,N],[12,"dqb_btime","","",45,N],[12,"dqb_itime","","",45,N],[12,"dqb_valid","","",45,N],[3,"signalfd_siginfo","","",N,N],[12,"ssi_signo","","",46,N],[12,"ssi_errno","","",46,N],[12,"ssi_code","","",46,N],[12,"ssi_pid","","",46,N],[12,"ssi_uid","","",46,N],[12,"ssi_fd","","",46,N],[12,"ssi_tid","","",46,N],[12,"ssi_band","","",46,N],[12,"ssi_overrun","","",46,N],[12,"ssi_trapno","","",46,N],[12,"ssi_status","","",46,N],[12,"ssi_int","","",46,N],[12,"ssi_ptr","","",46,N],[12,"ssi_utime","","",46,N],[12,"ssi_stime","","",46,N],[12,"ssi_addr","","",46,N],[12,"ssi_addr_lsb","","",46,N],[12,"ssi_syscall","","",46,N],[12,"ssi_call_addr","","",46,N],[12,"ssi_arch","","",46,N],[3,"itimerspec","","",N,N],[12,"it_interval","","",47,N],[12,"it_value","","",47,N],[3,"fsid_t","","",N,N],[3,"mq_attr","","",N,N],[12,"mq_flags","","",48,N],[12,"mq_maxmsg","","",48,N],[12,"mq_msgsize","","",48,N],[12,"mq_curmsgs","","",48,N],[3,"packet_mreq","","",N,N],[12,"mr_ifindex","","",49,N],[12,"mr_type","","",49,N],[12,"mr_alen","","",49,N],[12,"mr_address","","",49,N],[3,"cpu_set_t","","",N,N],[3,"if_nameindex","","",N,N],[12,"if_index","","",50,N],[12,"if_name","","",50,N],[3,"msginfo","","",N,N],[12,"msgpool","","",51,N],[12,"msgmap","","",51,N],[12,"msgmax","","",51,N],[12,"msgmnb","","",51,N],[12,"msgmni","","",51,N],[12,"msgssz","","",51,N],[12,"msgtql","","",51,N],[12,"msgseg","","",51,N],[3,"sembuf","","",N,N],[12,"sem_num","","",52,N],[12,"sem_op","","",52,N],[12,"sem_flg","","",52,N],[3,"input_event","","",N,N],[12,"time","","",53,N],[12,"type_","","",53,N],[12,"code","","",53,N],[12,"value","","",53,N],[3,"input_id","","",N,N],[12,"bustype","","",54,N],[12,"vendor","","",54,N],[12,"product","","",54,N],[12,"version","","",54,N],[3,"input_absinfo","","",N,N],[12,"value","","",55,N],[12,"minimum","","",55,N],[12,"maximum","","",55,N],[12,"fuzz","","",55,N],[12,"flat","","",55,N],[12,"resolution","","",55,N],[3,"input_keymap_entry","","",N,N],[12,"flags","","",56,N],[12,"len","","",56,N],[12,"index","","",56,N],[12,"keycode","","",56,N],[12,"scancode","","",56,N],[3,"input_mask","","",N,N],[12,"type_","","",57,N],[12,"codes_size","","",57,N],[12,"codes_ptr","","",57,N],[3,"ff_replay","","",N,N],[12,"length","","",58,N],[12,"delay","","",58,N],[3,"ff_trigger","","",N,N],[12,"button","","",59,N],[12,"interval","","",59,N],[3,"ff_envelope","","",N,N],[12,"attack_length","","",60,N],[12,"attack_level","","",60,N],[12,"fade_length","","",60,N],[12,"fade_level","","",60,N],[3,"ff_constant_effect","","",N,N],[12,"level","","",61,N],[12,"envelope","","",61,N],[3,"ff_ramp_effect","","",N,N],[12,"start_level","","",62,N],[12,"end_level","","",62,N],[12,"envelope","","",62,N],[3,"ff_condition_effect","","",N,N],[12,"right_saturation","","",63,N],[12,"left_saturation","","",63,N],[12,"right_coeff","","",63,N],[12,"left_coeff","","",63,N],[12,"deadband","","",63,N],[12,"center","","",63,N],[3,"ff_periodic_effect","","",N,N],[12,"waveform","","",64,N],[12,"period","","",64,N],[12,"magnitude","","",64,N],[12,"offset","","",64,N],[12,"phase","","",64,N],[12,"envelope","","",64,N],[12,"custom_len","","",64,N],[12,"custom_data","","",64,N],[3,"ff_rumble_effect","","",N,N],[12,"strong_magnitude","","",65,N],[12,"weak_magnitude","","",65,N],[3,"ff_effect","","",N,N],[12,"type_","","",66,N],[12,"id","","",66,N],[12,"direction","","",66,N],[12,"trigger","","",66,N],[12,"replay","","",66,N],[12,"u","","",66,N],[3,"dl_phdr_info","","",N,N],[12,"dlpi_addr","","",67,N],[12,"dlpi_name","","",67,N],[12,"dlpi_phdr","","",67,N],[12,"dlpi_phnum","","",67,N],[12,"dlpi_adds","","",67,N],[12,"dlpi_subs","","",67,N],[12,"dlpi_tls_modid","","",67,N],[12,"dlpi_tls_data","","",67,N],[3,"Elf32_Ehdr","","",N,N],[12,"e_ident","","",68,N],[12,"e_type","","",68,N],[12,"e_machine","","",68,N],[12,"e_version","","",68,N],[12,"e_entry","","",68,N],[12,"e_phoff","","",68,N],[12,"e_shoff","","",68,N],[12,"e_flags","","",68,N],[12,"e_ehsize","","",68,N],[12,"e_phentsize","","",68,N],[12,"e_phnum","","",68,N],[12,"e_shentsize","","",68,N],[12,"e_shnum","","",68,N],[12,"e_shstrndx","","",68,N],[3,"Elf64_Ehdr","","",N,N],[12,"e_ident","","",69,N],[12,"e_type","","",69,N],[12,"e_machine","","",69,N],[12,"e_version","","",69,N],[12,"e_entry","","",69,N],[12,"e_phoff","","",69,N],[12,"e_shoff","","",69,N],[12,"e_flags","","",69,N],[12,"e_ehsize","","",69,N],[12,"e_phentsize","","",69,N],[12,"e_phnum","","",69,N],[12,"e_shentsize","","",69,N],[12,"e_shnum","","",69,N],[12,"e_shstrndx","","",69,N],[3,"Elf32_Sym","","",N,N],[12,"st_name","","",70,N],[12,"st_value","","",70,N],[12,"st_size","","",70,N],[12,"st_info","","",70,N],[12,"st_other","","",70,N],[12,"st_shndx","","",70,N],[3,"Elf64_Sym","","",N,N],[12,"st_name","","",71,N],[12,"st_info","","",71,N],[12,"st_other","","",71,N],[12,"st_shndx","","",71,N],[12,"st_value","","",71,N],[12,"st_size","","",71,N],[3,"Elf32_Phdr","","",N,N],[12,"p_type","","",72,N],[12,"p_offset","","",72,N],[12,"p_vaddr","","",72,N],[12,"p_paddr","","",72,N],[12,"p_filesz","","",72,N],[12,"p_memsz","","",72,N],[12,"p_flags","","",72,N],[12,"p_align","","",72,N],[3,"Elf64_Phdr","","",N,N],[12,"p_type","","",73,N],[12,"p_flags","","",73,N],[12,"p_offset","","",73,N],[12,"p_vaddr","","",73,N],[12,"p_paddr","","",73,N],[12,"p_filesz","","",73,N],[12,"p_memsz","","",73,N],[12,"p_align","","",73,N],[3,"Elf32_Shdr","","",N,N],[12,"sh_name","","",74,N],[12,"sh_type","","",74,N],[12,"sh_flags","","",74,N],[12,"sh_addr","","",74,N],[12,"sh_offset","","",74,N],[12,"sh_size","","",74,N],[12,"sh_link","","",74,N],[12,"sh_info","","",74,N],[12,"sh_addralign","","",74,N],[12,"sh_entsize","","",74,N],[3,"Elf64_Shdr","","",N,N],[12,"sh_name","","",75,N],[12,"sh_type","","",75,N],[12,"sh_flags","","",75,N],[12,"sh_addr","","",75,N],[12,"sh_offset","","",75,N],[12,"sh_size","","",75,N],[12,"sh_link","","",75,N],[12,"sh_info","","",75,N],[12,"sh_addralign","","",75,N],[12,"sh_entsize","","",75,N],[3,"Elf32_Chdr","","",N,N],[12,"ch_type","","",76,N],[12,"ch_size","","",76,N],[12,"ch_addralign","","",76,N],[3,"Elf64_Chdr","","",N,N],[12,"ch_type","","",77,N],[12,"ch_reserved","","",77,N],[12,"ch_size","","",77,N],[12,"ch_addralign","","",77,N],[3,"ucred","","",N,N],[12,"pid","","",78,N],[12,"uid","","",78,N],[12,"gid","","",78,N],[3,"mntent","","",N,N],[12,"mnt_fsname","","",79,N],[12,"mnt_dir","","",79,N],[12,"mnt_type","","",79,N],[12,"mnt_opts","","",79,N],[12,"mnt_freq","","",79,N],[12,"mnt_passno","","",79,N],[3,"posix_spawn_file_actions_t","","",N,N],[3,"posix_spawnattr_t","","",N,N],[3,"genlmsghdr","","",N,N],[12,"cmd","","",80,N],[12,"version","","",80,N],[12,"reserved","","",80,N],[3,"in6_pktinfo","","",N,N],[12,"ipi6_addr","","",81,N],[12,"ipi6_ifindex","","",81,N],[3,"arpd_request","","",N,N],[12,"req","","",82,N],[12,"ip","","",82,N],[12,"dev","","",82,N],[12,"stamp","","",82,N],[12,"updated","","",82,N],[12,"ha","","",82,N],[3,"dirent","","",N,N],[12,"d_ino","","",83,N],[12,"d_off","","",83,N],[12,"d_reclen","","",83,N],[12,"d_type","","",83,N],[12,"d_name","","",83,N],[3,"dirent64","","",N,N],[12,"d_ino","","",84,N],[12,"d_off","","",84,N],[12,"d_reclen","","",84,N],[12,"d_type","","",84,N],[12,"d_name","","",84,N],[3,"sockaddr_alg","","",N,N],[12,"salg_family","","",85,N],[12,"salg_type","","",85,N],[12,"salg_feat","","",85,N],[12,"salg_mask","","",85,N],[12,"salg_name","","",85,N],[3,"af_alg_iv","","",N,N],[12,"ivlen","","",86,N],[12,"iv","","",86,N],[3,"aiocb","","",N,N],[12,"aio_fildes","","",87,N],[12,"aio_lio_opcode","","",87,N],[12,"aio_reqprio","","",87,N],[12,"aio_buf","","",87,N],[12,"aio_nbytes","","",87,N],[12,"aio_sigevent","","",87,N],[12,"aio_offset","","",87,N],[3,"__exit_status","","",N,N],[12,"e_termination","","",88,N],[12,"e_exit","","",88,N],[3,"__timeval","","",N,N],[12,"tv_sec","","",89,N],[12,"tv_usec","","",89,N],[3,"sigaction","","",N,N],[12,"sa_sigaction","","",90,N],[12,"sa_mask","","",90,N],[12,"sa_flags","","",90,N],[12,"sa_restorer","","",90,N],[3,"stack_t","","",N,N],[12,"ss_sp","","",91,N],[12,"ss_flags","","",91,N],[12,"ss_size","","",91,N],[3,"siginfo_t","","",N,N],[12,"si_signo","","",92,N],[12,"si_errno","","",92,N],[12,"si_code","","",92,N],[12,"_pad","","",92,N],[3,"glob64_t","","",N,N],[12,"gl_pathc","","",93,N],[12,"gl_pathv","","",93,N],[12,"gl_offs","","",93,N],[12,"gl_flags","","",93,N],[3,"statfs","","",N,N],[12,"f_type","","",94,N],[12,"f_bsize","","",94,N],[12,"f_blocks","","",94,N],[12,"f_bfree","","",94,N],[12,"f_bavail","","",94,N],[12,"f_files","","",94,N],[12,"f_ffree","","",94,N],[12,"f_fsid","","",94,N],[12,"f_namelen","","",94,N],[12,"f_frsize","","",94,N],[3,"msghdr","","",N,N],[12,"msg_name","","",95,N],[12,"msg_namelen","","",95,N],[12,"msg_iov","","",95,N],[12,"msg_iovlen","","",95,N],[12,"msg_control","","",95,N],[12,"msg_controllen","","",95,N],[12,"msg_flags","","",95,N],[3,"cmsghdr","","",N,N],[12,"cmsg_len","","",96,N],[12,"cmsg_level","","",96,N],[12,"cmsg_type","","",96,N],[3,"termios","","",N,N],[12,"c_iflag","","",97,N],[12,"c_oflag","","",97,N],[12,"c_cflag","","",97,N],[12,"c_lflag","","",97,N],[12,"c_line","","",97,N],[12,"c_cc","","",97,N],[12,"c_ispeed","","",97,N],[12,"c_ospeed","","",97,N],[3,"flock","","",N,N],[12,"l_type","","",98,N],[12,"l_whence","","",98,N],[12,"l_start","","",98,N],[12,"l_len","","",98,N],[12,"l_pid","","",98,N],[3,"mallinfo","","",N,N],[12,"arena","","",99,N],[12,"ordblks","","",99,N],[12,"smblks","","",99,N],[12,"hblks","","",99,N],[12,"hblkhd","","",99,N],[12,"usmblks","","",99,N],[12,"fsmblks","","",99,N],[12,"uordblks","","",99,N],[12,"fordblks","","",99,N],[12,"keepcost","","",99,N],[3,"nlmsghdr","","",N,N],[12,"nlmsg_len","","",100,N],[12,"nlmsg_type","","",100,N],[12,"nlmsg_flags","","",100,N],[12,"nlmsg_seq","","",100,N],[12,"nlmsg_pid","","",100,N],[3,"nlmsgerr","","",N,N],[12,"error","","",101,N],[12,"msg","","",101,N],[3,"nl_pktinfo","","",N,N],[12,"group","","",102,N],[3,"nl_mmap_req","","",N,N],[12,"nm_block_size","","",103,N],[12,"nm_block_nr","","",103,N],[12,"nm_frame_size","","",103,N],[12,"nm_frame_nr","","",103,N],[3,"nl_mmap_hdr","","",N,N],[12,"nm_status","","",104,N],[12,"nm_len","","",104,N],[12,"nm_group","","",104,N],[12,"nm_pid","","",104,N],[12,"nm_uid","","",104,N],[12,"nm_gid","","",104,N],[3,"nlattr","","",N,N],[12,"nla_len","","",105,N],[12,"nla_type","","",105,N],[3,"rtentry","","",N,N],[12,"rt_pad1","","",106,N],[12,"rt_dst","","",106,N],[12,"rt_gateway","","",106,N],[12,"rt_genmask","","",106,N],[12,"rt_flags","","",106,N],[12,"rt_pad2","","",106,N],[12,"rt_pad3","","",106,N],[12,"rt_tos","","",106,N],[12,"rt_class","","",106,N],[12,"rt_pad4","","",106,N],[12,"rt_metric","","",106,N],[12,"rt_dev","","",106,N],[12,"rt_mtu","","",106,N],[12,"rt_window","","",106,N],[12,"rt_irtt","","",106,N],[3,"utmpx","","",N,N],[12,"ut_type","","",107,N],[12,"ut_pid","","",107,N],[12,"ut_line","","",107,N],[12,"ut_id","","",107,N],[12,"ut_user","","",107,N],[12,"ut_host","","",107,N],[12,"ut_exit","","",107,N],[12,"ut_session","","",107,N],[12,"ut_tv","","",107,N],[12,"ut_addr_v6","","",107,N],[3,"sigset_t","","",N,N],[3,"sysinfo","","",N,N],[12,"uptime","","",108,N],[12,"loads","","",108,N],[12,"totalram","","",108,N],[12,"freeram","","",108,N],[12,"sharedram","","",108,N],[12,"bufferram","","",108,N],[12,"totalswap","","",108,N],[12,"freeswap","","",108,N],[12,"procs","","",108,N],[12,"pad","","",108,N],[12,"totalhigh","","",108,N],[12,"freehigh","","",108,N],[12,"mem_unit","","",108,N],[12,"_f","","",108,N],[3,"msqid_ds","","",N,N],[12,"msg_perm","","",109,N],[12,"msg_stime","","",109,N],[12,"msg_rtime","","",109,N],[12,"msg_ctime","","",109,N],[12,"msg_qnum","","",109,N],[12,"msg_qbytes","","",109,N],[12,"msg_lspid","","",109,N],[12,"msg_lrpid","","",109,N],[3,"stat","","",N,N],[12,"st_dev","","",110,N],[12,"st_ino","","",110,N],[12,"st_nlink","","",110,N],[12,"st_mode","","",110,N],[12,"st_uid","","",110,N],[12,"st_gid","","",110,N],[12,"st_rdev","","",110,N],[12,"st_size","","",110,N],[12,"st_blksize","","",110,N],[12,"st_blocks","","",110,N],[12,"st_atime","","",110,N],[12,"st_atime_nsec","","",110,N],[12,"st_mtime","","",110,N],[12,"st_mtime_nsec","","",110,N],[12,"st_ctime","","",110,N],[12,"st_ctime_nsec","","",110,N],[3,"stat64","","",N,N],[12,"st_dev","","",111,N],[12,"st_ino","","",111,N],[12,"st_nlink","","",111,N],[12,"st_mode","","",111,N],[12,"st_uid","","",111,N],[12,"st_gid","","",111,N],[12,"st_rdev","","",111,N],[12,"st_size","","",111,N],[12,"st_blksize","","",111,N],[12,"st_blocks","","",111,N],[12,"st_atime","","",111,N],[12,"st_atime_nsec","","",111,N],[12,"st_mtime","","",111,N],[12,"st_mtime_nsec","","",111,N],[12,"st_ctime","","",111,N],[12,"st_ctime_nsec","","",111,N],[3,"statfs64","","",N,N],[12,"f_type","","",112,N],[12,"f_bsize","","",112,N],[12,"f_blocks","","",112,N],[12,"f_bfree","","",112,N],[12,"f_bavail","","",112,N],[12,"f_files","","",112,N],[12,"f_ffree","","",112,N],[12,"f_fsid","","",112,N],[12,"f_namelen","","",112,N],[12,"f_frsize","","",112,N],[12,"f_flags","","",112,N],[12,"f_spare","","",112,N],[3,"statvfs64","","",N,N],[12,"f_bsize","","",113,N],[12,"f_frsize","","",113,N],[12,"f_blocks","","",113,N],[12,"f_bfree","","",113,N],[12,"f_bavail","","",113,N],[12,"f_files","","",113,N],[12,"f_ffree","","",113,N],[12,"f_favail","","",113,N],[12,"f_fsid","","",113,N],[12,"f_flag","","",113,N],[12,"f_namemax","","",113,N],[3,"pthread_attr_t","","",N,N],[3,"_libc_fpxreg","","",N,N],[12,"significand","","",114,N],[12,"exponent","","",114,N],[3,"_libc_xmmreg","","",N,N],[12,"element","","",115,N],[3,"_libc_fpstate","","",N,N],[12,"cwd","","",116,N],[12,"swd","","",116,N],[12,"ftw","","",116,N],[12,"fop","","",116,N],[12,"rip","","",116,N],[12,"rdp","","",116,N],[12,"mxcsr","","",116,N],[12,"mxcr_mask","","",116,N],[12,"_st","","",116,N],[12,"_xmm","","",116,N],[3,"user_regs_struct","","",N,N],[12,"r15","","",117,N],[12,"r14","","",117,N],[12,"r13","","",117,N],[12,"r12","","",117,N],[12,"rbp","","",117,N],[12,"rbx","","",117,N],[12,"r11","","",117,N],[12,"r10","","",117,N],[12,"r9","","",117,N],[12,"r8","","",117,N],[12,"rax","","",117,N],[12,"rcx","","",117,N],[12,"rdx","","",117,N],[12,"rsi","","",117,N],[12,"rdi","","",117,N],[12,"orig_rax","","",117,N],[12,"rip","","",117,N],[12,"cs","","",117,N],[12,"eflags","","",117,N],[12,"rsp","","",117,N],[12,"ss","","",117,N],[12,"fs_base","","",117,N],[12,"gs_base","","",117,N],[12,"ds","","",117,N],[12,"es","","",117,N],[12,"fs","","",117,N],[12,"gs","","",117,N],[3,"user","","",N,N],[12,"regs","","",118,N],[12,"u_fpvalid","","",118,N],[12,"i387","","",118,N],[12,"u_tsize","","",118,N],[12,"u_dsize","","",118,N],[12,"u_ssize","","",118,N],[12,"start_code","","",118,N],[12,"start_stack","","",118,N],[12,"signal","","",118,N],[12,"u_ar0","","",118,N],[12,"u_fpstate","","",118,N],[12,"magic","","",118,N],[12,"u_comm","","",118,N],[12,"u_debugreg","","",118,N],[3,"mcontext_t","","",N,N],[12,"gregs","","",119,N],[12,"fpregs","","",119,N],[3,"ipc_perm","","",N,N],[12,"__key","","",120,N],[12,"uid","","",120,N],[12,"gid","","",120,N],[12,"cuid","","",120,N],[12,"cgid","","",120,N],[12,"mode","","",120,N],[12,"__seq","","",120,N],[3,"shmid_ds","","",N,N],[12,"shm_perm","","",121,N],[12,"shm_segsz","","",121,N],[12,"shm_atime","","",121,N],[12,"shm_dtime","","",121,N],[12,"shm_ctime","","",121,N],[12,"shm_cpid","","",121,N],[12,"shm_lpid","","",121,N],[12,"shm_nattch","","",121,N],[3,"termios2","","",N,N],[12,"c_iflag","","",122,N],[12,"c_oflag","","",122,N],[12,"c_cflag","","",122,N],[12,"c_lflag","","",122,N],[12,"c_line","","",122,N],[12,"c_cc","","",122,N],[12,"c_ispeed","","",122,N],[12,"c_ospeed","","",122,N],[3,"user_fpregs_struct","","",N,N],[12,"cwd","","",123,N],[12,"swd","","",123,N],[12,"ftw","","",123,N],[12,"fop","","",123,N],[12,"rip","","",123,N],[12,"rdp","","",123,N],[12,"mxcsr","","",123,N],[12,"mxcr_mask","","",123,N],[12,"st_space","","",123,N],[12,"xmm_space","","",123,N],[3,"ucontext_t","","",N,N],[12,"uc_flags","","",124,N],[12,"uc_link","","",124,N],[12,"uc_stack","","",124,N],[12,"uc_mcontext","","",124,N],[12,"uc_sigmask","","",124,N],[3,"statvfs","","",N,N],[12,"f_bsize","","",125,N],[12,"f_frsize","","",125,N],[12,"f_blocks","","",125,N],[12,"f_bfree","","",125,N],[12,"f_bavail","","",125,N],[12,"f_files","","",125,N],[12,"f_ffree","","",125,N],[12,"f_favail","","",125,N],[12,"f_fsid","","",125,N],[12,"f_flag","","",125,N],[12,"f_namemax","","",125,N],[3,"sem_t","","",N,N],[3,"pthread_mutexattr_t","","",N,N],[3,"pthread_rwlockattr_t","","",N,N],[3,"pthread_condattr_t","","",N,N],[3,"pthread_cond_t","","",N,N],[3,"pthread_mutex_t","","",N,N],[3,"pthread_rwlock_t","","",N,N],[3,"in6_addr","","",N,N],[12,"s6_addr","","",126,N],[4,"DIR","","",N,N],[4,"locale_t","","",N,N],[4,"FILE","","",N,N],[4,"fpos_t","","",N,N],[4,"timezone","","",N,N],[4,"fpos64_t","","",N,N],[5,"CMSG_FIRSTHDR","","",N,N],[5,"CMSG_DATA","","",N,N],[5,"CMSG_SPACE","","",N,[[["c_uint"]],["c_uint"]]],[5,"CMSG_LEN","","",N,[[["c_uint"]],["c_uint"]]],[5,"FD_CLR","","",N,N],[5,"FD_ISSET","","",N,N],[5,"FD_SET","","",N,N],[5,"FD_ZERO","","",N,N],[5,"WIFSTOPPED","","",N,[[["c_int"]],["bool"]]],[5,"WSTOPSIG","","",N,[[["c_int"]],["c_int"]]],[5,"WIFCONTINUED","","",N,[[["c_int"]],["bool"]]],[5,"WIFSIGNALED","","",N,[[["c_int"]],["bool"]]],[5,"WTERMSIG","","",N,[[["c_int"]],["c_int"]]],[5,"WIFEXITED","","",N,[[["c_int"]],["bool"]]],[5,"WEXITSTATUS","","",N,[[["c_int"]],["c_int"]]],[5,"WCOREDUMP","","",N,[[["c_int"]],["bool"]]],[5,"QCMD","","",N,[[["c_int"],["c_int"]],["c_int"]]],[5,"IPOPT_COPIED","","",N,[[["u8"]],["u8"]]],[5,"IPOPT_CLASS","","",N,[[["u8"]],["u8"]]],[5,"IPOPT_NUMBER","","",N,[[["u8"]],["u8"]]],[5,"IPTOS_ECN","","",N,[[["u8"]],["u8"]]],[5,"CMSG_NXTHDR","","",N,N],[5,"CPU_ZERO","","",N,N],[5,"CPU_SET","","",N,N],[5,"CPU_CLR","","",N,N],[5,"CPU_ISSET","","",N,[[["usize"],["cpu_set_t"]],["bool"]]],[5,"CPU_EQUAL","","",N,[[["cpu_set_t"],["cpu_set_t"]],["bool"]]],[5,"major","","",N,[[["dev_t"]],["c_uint"]]],[5,"minor","","",N,[[["dev_t"]],["c_uint"]]],[5,"makedev","","",N,[[["c_uint"],["c_uint"]],["dev_t"]]],[5,"IPTOS_TOS","","",N,[[["u8"]],["u8"]]],[5,"IPTOS_PREC","","",N,[[["u8"]],["u8"]]],[5,"RT_TOS","","",N,[[["u8"]],["u8"]]],[5,"RT_ADDRCLASS","","",N,[[["u32"]],["u32"]]],[5,"RT_LOCALADDR","","",N,[[["u32"]],["bool"]]],[5,"NLA_ALIGN","","",N,[[["c_int"]],["c_int"]]],[5,"isalnum","","",N,N],[5,"isalpha","","",N,N],[5,"iscntrl","","",N,N],[5,"isdigit","","",N,N],[5,"isgraph","","",N,N],[5,"islower","","",N,N],[5,"isprint","","",N,N],[5,"ispunct","","",N,N],[5,"isspace","","",N,N],[5,"isupper","","",N,N],[5,"isxdigit","","",N,N],[5,"tolower","","",N,N],[5,"toupper","","",N,N],[5,"fopen","","",N,N],[5,"freopen","","",N,N],[5,"fflush","","",N,N],[5,"fclose","","",N,N],[5,"remove","","",N,N],[5,"rename","","",N,N],[5,"tmpfile","","",N,N],[5,"setvbuf","","",N,N],[5,"setbuf","","",N,N],[5,"getchar","","",N,N],[5,"putchar","","",N,N],[5,"fgetc","","",N,N],[5,"fgets","","",N,N],[5,"fputc","","",N,N],[5,"fputs","","",N,N],[5,"puts","","",N,N],[5,"ungetc","","",N,N],[5,"fread","","",N,N],[5,"fwrite","","",N,N],[5,"fseek","","",N,N],[5,"ftell","","",N,N],[5,"rewind","","",N,N],[5,"fgetpos","","",N,N],[5,"fsetpos","","",N,N],[5,"feof","","",N,N],[5,"ferror","","",N,N],[5,"perror","","",N,N],[5,"atoi","","",N,N],[5,"strtod","","",N,N],[5,"strtol","","",N,N],[5,"strtoul","","",N,N],[5,"calloc","","",N,N],[5,"malloc","","",N,N],[5,"realloc","","",N,N],[5,"free","","",N,N],[5,"abort","","",N,N],[5,"exit","","",N,N],[5,"_exit","","",N,N],[5,"atexit","","",N,N],[5,"system","","",N,N],[5,"getenv","","",N,N],[5,"strcpy","","",N,N],[5,"strncpy","","",N,N],[5,"strcat","","",N,N],[5,"strncat","","",N,N],[5,"strcmp","","",N,N],[5,"strncmp","","",N,N],[5,"strcoll","","",N,N],[5,"strchr","","",N,N],[5,"strrchr","","",N,N],[5,"strspn","","",N,N],[5,"strcspn","","",N,N],[5,"strdup","","",N,N],[5,"strpbrk","","",N,N],[5,"strstr","","",N,N],[5,"strcasecmp","","",N,N],[5,"strncasecmp","","",N,N],[5,"strlen","","",N,N],[5,"strnlen","","",N,N],[5,"strerror","","",N,N],[5,"strtok","","",N,N],[5,"strxfrm","","",N,N],[5,"wcslen","","",N,N],[5,"wcstombs","","",N,N],[5,"memchr","","",N,N],[5,"memcmp","","",N,N],[5,"memcpy","","",N,N],[5,"memmove","","",N,N],[5,"memset","","",N,N],[5,"getpwnam","","",N,N],[5,"getpwuid","","",N,N],[5,"fprintf","","",N,N],[5,"printf","","",N,N],[5,"snprintf","","",N,N],[5,"sprintf","","",N,N],[5,"fscanf","","",N,N],[5,"scanf","","",N,N],[5,"sscanf","","",N,N],[5,"getchar_unlocked","","",N,N],[5,"putchar_unlocked","","",N,N],[5,"socket","","",N,N],[5,"connect","","",N,N],[5,"listen","","",N,N],[5,"accept","","",N,N],[5,"getpeername","","",N,N],[5,"getsockname","","",N,N],[5,"setsockopt","","",N,N],[5,"socketpair","","",N,N],[5,"sendto","","",N,N],[5,"shutdown","","",N,N],[5,"chmod","","",N,N],[5,"fchmod","","",N,N],[5,"fstat","","",N,N],[5,"mkdir","","",N,N],[5,"stat","","",N,N],[5,"pclose","","",N,N],[5,"fdopen","","",N,N],[5,"fileno","","",N,N],[5,"open","","",N,N],[5,"creat","","",N,N],[5,"fcntl","","",N,N],[5,"opendir","","",N,N],[5,"fdopendir","","",N,N],[5,"readdir","","",N,N],[5,"readdir_r","","",N,N],[5,"closedir","","",N,N],[5,"rewinddir","","",N,N],[5,"openat","","",N,N],[5,"fchmodat","","",N,N],[5,"fchown","","",N,N],[5,"fchownat","","",N,N],[5,"fstatat","","",N,N],[5,"linkat","","",N,N],[5,"mkdirat","","",N,N],[5,"readlinkat","","",N,N],[5,"renameat","","",N,N],[5,"symlinkat","","",N,N],[5,"unlinkat","","",N,N],[5,"access","","",N,N],[5,"alarm","","",N,N],[5,"chdir","","",N,N],[5,"fchdir","","",N,N],[5,"chown","","",N,N],[5,"lchown","","",N,N],[5,"close","","",N,N],[5,"dup","","",N,N],[5,"dup2","","",N,N],[5,"execl","","",N,N],[5,"execle","","",N,N],[5,"execlp","","",N,N],[5,"execv","","",N,N],[5,"execve","","",N,N],[5,"execvp","","",N,N],[5,"fork","","",N,N],[5,"fpathconf","","",N,N],[5,"getcwd","","",N,N],[5,"getegid","","",N,N],[5,"geteuid","","",N,N],[5,"getgid","","",N,N],[5,"getgroups","","",N,N],[5,"getlogin","","",N,N],[5,"getopt","","",N,N],[5,"getpgid","","",N,N],[5,"getpgrp","","",N,N],[5,"getpid","","",N,N],[5,"getppid","","",N,N],[5,"getuid","","",N,N],[5,"isatty","","",N,N],[5,"link","","",N,N],[5,"lseek","","",N,N],[5,"pathconf","","",N,N],[5,"pause","","",N,N],[5,"pipe","","",N,N],[5,"posix_memalign","","",N,N],[5,"read","","",N,N],[5,"rmdir","","",N,N],[5,"seteuid","","",N,N],[5,"setegid","","",N,N],[5,"setgid","","",N,N],[5,"setpgid","","",N,N],[5,"setsid","","",N,N],[5,"setuid","","",N,N],[5,"sleep","","",N,N],[5,"nanosleep","","",N,N],[5,"tcgetpgrp","","",N,N],[5,"tcsetpgrp","","",N,N],[5,"ttyname","","",N,N],[5,"unlink","","",N,N],[5,"wait","","",N,N],[5,"waitpid","","",N,N],[5,"write","","",N,N],[5,"pread","","",N,N],[5,"pwrite","","",N,N],[5,"umask","","",N,N],[5,"utime","","",N,N],[5,"kill","","",N,N],[5,"killpg","","",N,N],[5,"mlock","","",N,N],[5,"munlock","","",N,N],[5,"mlockall","","",N,N],[5,"munlockall","","",N,N],[5,"mmap","","",N,N],[5,"munmap","","",N,N],[5,"if_nametoindex","","",N,N],[5,"if_indextoname","","",N,N],[5,"lstat","","",N,N],[5,"fsync","","",N,N],[5,"setenv","","",N,N],[5,"unsetenv","","",N,N],[5,"symlink","","",N,N],[5,"truncate","","",N,N],[5,"ftruncate","","",N,N],[5,"signal","","",N,N],[5,"getrlimit","","",N,N],[5,"setrlimit","","",N,N],[5,"getrusage","","",N,N],[5,"realpath","","",N,N],[5,"flock","","",N,N],[5,"gettimeofday","","",N,N],[5,"times","","",N,N],[5,"pthread_self","","",N,N],[5,"pthread_join","","",N,N],[5,"pthread_exit","","",N,N],[5,"pthread_attr_init","","",N,N],[5,"pthread_attr_destroy","","",N,N],[5,"pthread_attr_setstacksize","","",N,N],[5,"pthread_attr_setdetachstate","","",N,N],[5,"pthread_detach","","",N,N],[5,"sched_yield","","",N,N],[5,"pthread_key_create","","",N,N],[5,"pthread_key_delete","","",N,N],[5,"pthread_getspecific","","",N,N],[5,"pthread_setspecific","","",N,N],[5,"pthread_mutex_init","","",N,N],[5,"pthread_mutex_destroy","","",N,N],[5,"pthread_mutex_lock","","",N,N],[5,"pthread_mutex_trylock","","",N,N],[5,"pthread_mutex_unlock","","",N,N],[5,"pthread_mutexattr_init","","",N,N],[5,"pthread_mutexattr_destroy","","",N,N],[5,"pthread_mutexattr_settype","","",N,N],[5,"pthread_cond_init","","",N,N],[5,"pthread_cond_wait","","",N,N],[5,"pthread_cond_timedwait","","",N,N],[5,"pthread_cond_signal","","",N,N],[5,"pthread_cond_broadcast","","",N,N],[5,"pthread_cond_destroy","","",N,N],[5,"pthread_condattr_init","","",N,N],[5,"pthread_condattr_destroy","","",N,N],[5,"pthread_rwlock_init","","",N,N],[5,"pthread_rwlock_destroy","","",N,N],[5,"pthread_rwlock_rdlock","","",N,N],[5,"pthread_rwlock_tryrdlock","","",N,N],[5,"pthread_rwlock_wrlock","","",N,N],[5,"pthread_rwlock_trywrlock","","",N,N],[5,"pthread_rwlock_unlock","","",N,N],[5,"pthread_rwlockattr_init","","",N,N],[5,"pthread_rwlockattr_destroy","","",N,N],[5,"strerror_r","","",N,N],[5,"getsockopt","","",N,N],[5,"raise","","",N,N],[5,"sigaction","","",N,N],[5,"utimes","","",N,N],[5,"dlopen","","",N,N],[5,"dlerror","","",N,N],[5,"dlsym","","",N,N],[5,"dlclose","","",N,N],[5,"dladdr","","",N,N],[5,"getaddrinfo","","",N,N],[5,"freeaddrinfo","","",N,N],[5,"gai_strerror","","",N,N],[5,"res_init","","",N,N],[5,"gmtime_r","","",N,N],[5,"localtime_r","","",N,N],[5,"mktime","","",N,N],[5,"time","","",N,N],[5,"gmtime","","",N,N],[5,"localtime","","",N,N],[5,"difftime","","",N,N],[5,"mknod","","",N,N],[5,"gethostname","","",N,N],[5,"getservbyname","","",N,N],[5,"getprotobyname","","",N,N],[5,"getprotobynumber","","",N,N],[5,"chroot","","",N,N],[5,"usleep","","",N,N],[5,"send","","",N,N],[5,"recv","","",N,N],[5,"putenv","","",N,N],[5,"poll","","",N,N],[5,"select","","",N,N],[5,"setlocale","","",N,N],[5,"localeconv","","",N,N],[5,"sem_wait","","",N,N],[5,"sem_trywait","","",N,N],[5,"sem_post","","",N,N],[5,"statvfs","","",N,N],[5,"fstatvfs","","",N,N],[5,"readlink","","",N,N],[5,"sigemptyset","","",N,N],[5,"sigaddset","","",N,N],[5,"sigfillset","","",N,N],[5,"sigdelset","","",N,N],[5,"sigismember","","",N,N],[5,"sigprocmask","","",N,N],[5,"sigpending","","",N,N],[5,"timegm","","",N,N],[5,"getsid","","",N,N],[5,"sysconf","","",N,N],[5,"mkfifo","","",N,N],[5,"pselect","","",N,N],[5,"fseeko","","",N,N],[5,"ftello","","",N,N],[5,"tcdrain","","",N,N],[5,"cfgetispeed","","",N,N],[5,"cfgetospeed","","",N,N],[5,"cfsetispeed","","",N,N],[5,"cfsetospeed","","",N,N],[5,"tcgetattr","","",N,N],[5,"tcsetattr","","",N,N],[5,"tcflow","","",N,N],[5,"tcflush","","",N,N],[5,"tcgetsid","","",N,N],[5,"tcsendbreak","","",N,N],[5,"mkstemp","","",N,N],[5,"mkdtemp","","",N,N],[5,"tmpnam","","",N,N],[5,"openlog","","",N,N],[5,"closelog","","",N,N],[5,"setlogmask","","",N,N],[5,"syslog","","",N,N],[5,"nice","","",N,N],[5,"grantpt","","",N,N],[5,"posix_openpt","","",N,N],[5,"ptsname","","",N,N],[5,"unlockpt","","",N,N],[5,"strcasestr","","",N,N],[5,"getline","","",N,N],[5,"cfmakeraw","","",N,N],[5,"cfsetspeed","","",N,N],[5,"sem_destroy","","",N,N],[5,"sem_init","","",N,N],[5,"fdatasync","","",N,N],[5,"mincore","","",N,N],[5,"clock_getres","","",N,N],[5,"clock_gettime","","",N,N],[5,"clock_settime","","",N,N],[5,"dirfd","","",N,N],[5,"pthread_getattr_np","","",N,N],[5,"pthread_attr_getstack","","",N,N],[5,"memalign","","",N,N],[5,"setgroups","","",N,N],[5,"pipe2","","",N,N],[5,"statfs","","",N,N],[5,"statfs64","","",N,N],[5,"fstatfs","","",N,N],[5,"fstatfs64","","",N,N],[5,"statvfs64","","",N,N],[5,"fstatvfs64","","",N,N],[5,"memrchr","","",N,N],[5,"posix_fadvise","","",N,N],[5,"futimens","","",N,N],[5,"utimensat","","",N,N],[5,"duplocale","","",N,N],[5,"freelocale","","",N,N],[5,"newlocale","","",N,N],[5,"uselocale","","",N,N],[5,"creat64","","",N,N],[5,"fstat64","","",N,N],[5,"fstatat64","","",N,N],[5,"ftruncate64","","",N,N],[5,"getrlimit64","","",N,N],[5,"lseek64","","",N,N],[5,"lstat64","","",N,N],[5,"mmap64","","",N,N],[5,"open64","","",N,N],[5,"openat64","","",N,N],[5,"pread64","","",N,N],[5,"preadv64","","",N,N],[5,"pwrite64","","",N,N],[5,"pwritev64","","",N,N],[5,"readdir64","","",N,N],[5,"readdir64_r","","",N,N],[5,"setrlimit64","","",N,N],[5,"stat64","","",N,N],[5,"truncate64","","",N,N],[5,"mknodat","","",N,N],[5,"pthread_condattr_getclock","","",N,N],[5,"pthread_condattr_setclock","","",N,N],[5,"pthread_condattr_setpshared","","",N,N],[5,"accept4","","",N,N],[5,"pthread_mutexattr_setpshared","","",N,N],[5,"pthread_rwlockattr_getpshared","","",N,N],[5,"pthread_rwlockattr_setpshared","","",N,N],[5,"ptsname_r","","",N,N],[5,"clearenv","","",N,N],[5,"waitid","","",N,N],[5,"setreuid","","",N,N],[5,"setregid","","",N,N],[5,"getresuid","","",N,N],[5,"getresgid","","",N,N],[5,"acct","","",N,N],[5,"brk","","",N,N],[5,"sbrk","","",N,N],[5,"vfork","","",N,N],[5,"setresgid","","",N,N],[5,"setresuid","","",N,N],[5,"wait4","","",N,N],[5,"openpty","","",N,N],[5,"execvpe","","",N,N],[5,"fexecve","","",N,N],[5,"getifaddrs","","",N,N],[5,"freeifaddrs","","",N,N],[5,"bind","","",N,N],[5,"writev","","",N,N],[5,"readv","","",N,N],[5,"sendmsg","","",N,N],[5,"recvmsg","","",N,N],[5,"uname","","",N,N],[5,"inotify_init","","",N,N],[5,"inotify_init1","","",N,N],[5,"inotify_add_watch","","",N,N],[5,"abs","","",N,N],[5,"atof","","",N,N],[5,"labs","","",N,N],[5,"rand","","",N,N],[5,"srand","","",N,N],[5,"aio_read","","",N,N],[5,"aio_write","","",N,N],[5,"aio_fsync","","",N,N],[5,"aio_error","","",N,N],[5,"aio_return","","",N,N],[5,"aio_suspend","","",N,N],[5,"aio_cancel","","",N,N],[5,"lio_listio","","",N,N],[5,"lutimes","","",N,N],[5,"setpwent","","",N,N],[5,"endpwent","","",N,N],[5,"getpwent","","",N,N],[5,"setgrent","","",N,N],[5,"endgrent","","",N,N],[5,"getgrent","","",N,N],[5,"setspent","","",N,N],[5,"endspent","","",N,N],[5,"getspent","","",N,N],[5,"getspnam","","",N,N],[5,"shm_open","","",N,N],[5,"shmget","","",N,N],[5,"shmat","","",N,N],[5,"shmdt","","",N,N],[5,"shmctl","","",N,N],[5,"ftok","","",N,N],[5,"semget","","",N,N],[5,"semop","","",N,N],[5,"semctl","","",N,N],[5,"msgctl","","",N,N],[5,"msgget","","",N,N],[5,"msgrcv","","",N,N],[5,"msgsnd","","",N,N],[5,"mprotect","","",N,N],[5,"__errno_location","","",N,N],[5,"fopen64","","",N,N],[5,"freopen64","","",N,N],[5,"tmpfile64","","",N,N],[5,"fgetpos64","","",N,N],[5,"fsetpos64","","",N,N],[5,"fseeko64","","",N,N],[5,"ftello64","","",N,N],[5,"fallocate","","",N,N],[5,"fallocate64","","",N,N],[5,"posix_fallocate","","",N,N],[5,"posix_fallocate64","","",N,N],[5,"readahead","","",N,N],[5,"getxattr","","",N,N],[5,"lgetxattr","","",N,N],[5,"fgetxattr","","",N,N],[5,"setxattr","","",N,N],[5,"lsetxattr","","",N,N],[5,"fsetxattr","","",N,N],[5,"listxattr","","",N,N],[5,"llistxattr","","",N,N],[5,"flistxattr","","",N,N],[5,"removexattr","","",N,N],[5,"lremovexattr","","",N,N],[5,"fremovexattr","","",N,N],[5,"signalfd","","",N,N],[5,"timerfd_create","","",N,N],[5,"timerfd_gettime","","",N,N],[5,"timerfd_settime","","",N,N],[5,"pwritev","","",N,N],[5,"preadv","","",N,N],[5,"quotactl","","",N,N],[5,"mq_open","","",N,N],[5,"mq_close","","",N,N],[5,"mq_unlink","","",N,N],[5,"mq_receive","","",N,N],[5,"mq_send","","",N,N],[5,"mq_getattr","","",N,N],[5,"mq_setattr","","",N,N],[5,"epoll_pwait","","",N,N],[5,"dup3","","",N,N],[5,"mkostemp","","",N,N],[5,"mkostemps","","",N,N],[5,"sigtimedwait","","",N,N],[5,"sigwaitinfo","","",N,N],[5,"nl_langinfo_l","","",N,N],[5,"getnameinfo","","",N,N],[5,"pthread_setschedprio","","",N,N],[5,"prlimit","","",N,N],[5,"prlimit64","","",N,N],[5,"getloadavg","","",N,N],[5,"process_vm_readv","","",N,N],[5,"process_vm_writev","","",N,N],[5,"reboot","","",N,N],[5,"setfsgid","","",N,N],[5,"setfsuid","","",N,N],[5,"mkfifoat","","",N,N],[5,"if_nameindex","","",N,N],[5,"if_freenameindex","","",N,N],[5,"sync_file_range","","",N,N],[5,"mremap","","",N,N],[5,"glob","","",N,N],[5,"globfree","","",N,N],[5,"posix_madvise","","",N,N],[5,"shm_unlink","","",N,N],[5,"seekdir","","",N,N],[5,"telldir","","",N,N],[5,"madvise","","",N,N],[5,"msync","","",N,N],[5,"remap_file_pages","","",N,N],[5,"recvfrom","","",N,N],[5,"mkstemps","","",N,N],[5,"futimes","","",N,N],[5,"nl_langinfo","","",N,N],[5,"getdomainname","","",N,N],[5,"setdomainname","","",N,N],[5,"vhangup","","",N,N],[5,"sendmmsg","","",N,N],[5,"recvmmsg","","",N,N],[5,"sync","","",N,N],[5,"syscall","","",N,N],[5,"sched_getaffinity","","",N,N],[5,"sched_setaffinity","","",N,N],[5,"epoll_create","","",N,N],[5,"epoll_create1","","",N,N],[5,"epoll_wait","","",N,N],[5,"epoll_ctl","","",N,N],[5,"pthread_getschedparam","","",N,N],[5,"unshare","","",N,N],[5,"umount","","",N,N],[5,"sched_get_priority_max","","",N,N],[5,"tee","","",N,N],[5,"settimeofday","","",N,N],[5,"splice","","",N,N],[5,"eventfd","","",N,N],[5,"sched_rr_get_interval","","",N,N],[5,"sem_timedwait","","",N,N],[5,"sem_getvalue","","",N,N],[5,"sched_setparam","","",N,N],[5,"setns","","",N,N],[5,"swapoff","","",N,N],[5,"vmsplice","","",N,N],[5,"mount","","",N,N],[5,"personality","","",N,N],[5,"prctl","","",N,N],[5,"sched_getparam","","",N,N],[5,"ppoll","","",N,N],[5,"pthread_mutex_timedlock","","",N,N],[5,"clone","","",N,N],[5,"sched_getscheduler","","",N,N],[5,"clock_nanosleep","","",N,N],[5,"pthread_attr_getguardsize","","",N,N],[5,"sethostname","","",N,N],[5,"sched_get_priority_min","","",N,N],[5,"pthread_condattr_getpshared","","",N,N],[5,"sysinfo","","",N,N],[5,"umount2","","",N,N],[5,"pthread_setschedparam","","",N,N],[5,"swapon","","",N,N],[5,"sched_setscheduler","","",N,N],[5,"sendfile","","",N,N],[5,"sigsuspend","","",N,N],[5,"getgrgid_r","","",N,N],[5,"sigaltstack","","",N,N],[5,"sem_close","","",N,N],[5,"getdtablesize","","",N,N],[5,"getgrnam_r","","",N,N],[5,"initgroups","","",N,N],[5,"pthread_sigmask","","",N,N],[5,"sem_open","","",N,N],[5,"getgrnam","","",N,N],[5,"pthread_cancel","","",N,N],[5,"pthread_kill","","",N,N],[5,"sem_unlink","","",N,N],[5,"daemon","","",N,N],[5,"getpwnam_r","","",N,N],[5,"getpwuid_r","","",N,N],[5,"sigwait","","",N,N],[5,"pthread_atfork","","",N,N],[5,"getgrgid","","",N,N],[5,"getgrouplist","","",N,N],[5,"pthread_mutexattr_getpshared","","",N,N],[5,"popen","","",N,N],[5,"faccessat","","",N,N],[5,"pthread_create","","",N,N],[5,"dl_iterate_phdr","","",N,N],[5,"setmntent","","",N,N],[5,"getmntent","","",N,N],[5,"addmntent","","",N,N],[5,"endmntent","","",N,N],[5,"hasmntopt","","",N,N],[5,"posix_spawn","","",N,N],[5,"posix_spawnp","","",N,N],[5,"posix_spawnattr_init","","",N,N],[5,"posix_spawnattr_destroy","","",N,N],[5,"posix_spawnattr_getsigdefault","","",N,N],[5,"posix_spawnattr_setsigdefault","","",N,N],[5,"posix_spawnattr_getsigmask","","",N,N],[5,"posix_spawnattr_setsigmask","","",N,N],[5,"posix_spawnattr_getflags","","",N,N],[5,"posix_spawnattr_setflags","","",N,N],[5,"posix_spawnattr_getpgroup","","",N,N],[5,"posix_spawnattr_setpgroup","","",N,N],[5,"posix_spawnattr_getschedpolicy","","",N,N],[5,"posix_spawnattr_setschedpolicy","","",N,N],[5,"posix_spawnattr_getschedparam","","",N,N],[5,"posix_spawnattr_setschedparam","","",N,N],[5,"posix_spawn_file_actions_init","","",N,N],[5,"posix_spawn_file_actions_destroy","","",N,N],[5,"posix_spawn_file_actions_addopen","","",N,N],[5,"posix_spawn_file_actions_addclose","","",N,N],[5,"posix_spawn_file_actions_adddup2","","",N,N],[5,"fread_unlocked","","",N,N],[5,"inotify_rm_watch","","",N,N],[5,"utmpxname","","",N,N],[5,"getutxent","","",N,N],[5,"getutxid","","",N,N],[5,"getutxline","","",N,N],[5,"pututxline","","",N,N],[5,"setutxent","","",N,N],[5,"endutxent","","",N,N],[5,"getpt","","",N,N],[5,"mallopt","","",N,N],[5,"ioctl","","",N,N],[5,"backtrace","","",N,N],[5,"glob64","","",N,N],[5,"globfree64","","",N,N],[5,"ptrace","","",N,N],[5,"pthread_attr_getaffinity_np","","",N,N],[5,"pthread_attr_setaffinity_np","","",N,N],[5,"getpriority","","",N,N],[5,"setpriority","","",N,N],[5,"pthread_getaffinity_np","","",N,N],[5,"pthread_setaffinity_np","","",N,N],[5,"pthread_rwlockattr_getkind_np","","",N,N],[5,"pthread_rwlockattr_setkind_np","","",N,N],[5,"sched_getcpu","","",N,N],[5,"mallinfo","","",N,N],[5,"malloc_usable_size","","",N,N],[5,"getauxval","","",N,N],[5,"getpwent_r","","",N,N],[5,"getgrent_r","","",N,N],[5,"getcontext","","",N,N],[5,"setcontext","","",N,N],[5,"makecontext","","",N,N],[5,"swapcontext","","",N,N],[5,"iopl","","",N,N],[5,"ioperm","","",N,N],[5,"sysctl","","",N,N],[6,"int8_t","","",N,N],[6,"int16_t","","",N,N],[6,"int32_t","","",N,N],[6,"int64_t","","",N,N],[6,"uint8_t","","",N,N],[6,"uint16_t","","",N,N],[6,"uint32_t","","",N,N],[6,"uint64_t","","",N,N],[6,"c_schar","","",N,N],[6,"c_uchar","","",N,N],[6,"c_short","","",N,N],[6,"c_ushort","","",N,N],[6,"c_int","","",N,N],[6,"c_uint","","",N,N],[6,"c_float","","",N,N],[6,"c_double","","",N,N],[6,"c_longlong","","",N,N],[6,"c_ulonglong","","",N,N],[6,"intmax_t","","",N,N],[6,"uintmax_t","","",N,N],[6,"size_t","","",N,N],[6,"ptrdiff_t","","",N,N],[6,"intptr_t","","",N,N],[6,"uintptr_t","","",N,N],[6,"ssize_t","","",N,N],[6,"pid_t","","",N,N],[6,"uid_t","","",N,N],[6,"gid_t","","",N,N],[6,"in_addr_t","","",N,N],[6,"in_port_t","","",N,N],[6,"sighandler_t","","",N,N],[6,"cc_t","","",N,N],[6,"sa_family_t","","",N,N],[6,"pthread_key_t","","",N,N],[6,"speed_t","","",N,N],[6,"tcflag_t","","",N,N],[6,"clockid_t","","",N,N],[6,"key_t","","",N,N],[6,"id_t","","",N,N],[6,"useconds_t","","",N,N],[6,"dev_t","","",N,N],[6,"socklen_t","","",N,N],[6,"pthread_t","","",N,N],[6,"mode_t","","",N,N],[6,"ino64_t","","",N,N],[6,"off64_t","","",N,N],[6,"blkcnt64_t","","",N,N],[6,"rlim64_t","","",N,N],[6,"mqd_t","","",N,N],[6,"nfds_t","","",N,N],[6,"nl_item","","",N,N],[6,"idtype_t","","",N,N],[6,"loff_t","","",N,N],[6,"__u8","","",N,N],[6,"__u16","","",N,N],[6,"__s16","","",N,N],[6,"__u32","","",N,N],[6,"__s32","","",N,N],[6,"Elf32_Half","","",N,N],[6,"Elf32_Word","","",N,N],[6,"Elf32_Off","","",N,N],[6,"Elf32_Addr","","",N,N],[6,"Elf64_Half","","",N,N],[6,"Elf64_Word","","",N,N],[6,"Elf64_Off","","",N,N],[6,"Elf64_Addr","","",N,N],[6,"Elf64_Xword","","",N,N],[6,"Elf64_Sxword","","",N,N],[6,"Elf32_Section","","",N,N],[6,"Elf64_Section","","",N,N],[6,"__priority_which_t","","",N,N],[6,"clock_t","","",N,N],[6,"time_t","","",N,N],[6,"ino_t","","",N,N],[6,"off_t","","",N,N],[6,"blkcnt_t","","",N,N],[6,"__fsword_t","","",N,N],[6,"shmatt_t","","",N,N],[6,"msgqnum_t","","",N,N],[6,"msglen_t","","",N,N],[6,"fsblkcnt_t","","",N,N],[6,"fsfilcnt_t","","",N,N],[6,"rlim_t","","",N,N],[6,"c_char","","",N,N],[6,"wchar_t","","",N,N],[6,"nlink_t","","",N,N],[6,"blksize_t","","",N,N],[6,"greg_t","","",N,N],[6,"suseconds_t","","",N,N],[6,"__u64","","",N,N],[6,"c_long","","",N,N],[6,"c_ulong","","",N,N],[17,"INT_MIN","","",N,N],[17,"INT_MAX","","",N,N],[17,"SIG_DFL","","",N,N],[17,"SIG_IGN","","",N,N],[17,"SIG_ERR","","",N,N],[17,"DT_UNKNOWN","","",N,N],[17,"DT_FIFO","","",N,N],[17,"DT_CHR","","",N,N],[17,"DT_DIR","","",N,N],[17,"DT_BLK","","",N,N],[17,"DT_REG","","",N,N],[17,"DT_LNK","","",N,N],[17,"DT_SOCK","","",N,N],[17,"FD_CLOEXEC","","",N,N],[17,"USRQUOTA","","",N,N],[17,"GRPQUOTA","","",N,N],[17,"SIGIOT","","",N,N],[17,"S_ISUID","","",N,N],[17,"S_ISGID","","",N,N],[17,"S_ISVTX","","",N,N],[17,"IF_NAMESIZE","","",N,N],[17,"IFNAMSIZ","","",N,N],[17,"LOG_EMERG","","",N,N],[17,"LOG_ALERT","","",N,N],[17,"LOG_CRIT","","",N,N],[17,"LOG_ERR","","",N,N],[17,"LOG_WARNING","","",N,N],[17,"LOG_NOTICE","","",N,N],[17,"LOG_INFO","","",N,N],[17,"LOG_DEBUG","","",N,N],[17,"LOG_KERN","","",N,N],[17,"LOG_USER","","",N,N],[17,"LOG_MAIL","","",N,N],[17,"LOG_DAEMON","","",N,N],[17,"LOG_AUTH","","",N,N],[17,"LOG_SYSLOG","","",N,N],[17,"LOG_LPR","","",N,N],[17,"LOG_NEWS","","",N,N],[17,"LOG_UUCP","","",N,N],[17,"LOG_LOCAL0","","",N,N],[17,"LOG_LOCAL1","","",N,N],[17,"LOG_LOCAL2","","",N,N],[17,"LOG_LOCAL3","","",N,N],[17,"LOG_LOCAL4","","",N,N],[17,"LOG_LOCAL5","","",N,N],[17,"LOG_LOCAL6","","",N,N],[17,"LOG_LOCAL7","","",N,N],[17,"LOG_PID","","",N,N],[17,"LOG_CONS","","",N,N],[17,"LOG_ODELAY","","",N,N],[17,"LOG_NDELAY","","",N,N],[17,"LOG_NOWAIT","","",N,N],[17,"LOG_PRIMASK","","",N,N],[17,"LOG_FACMASK","","",N,N],[17,"PRIO_PROCESS","","",N,N],[17,"PRIO_PGRP","","",N,N],[17,"PRIO_USER","","",N,N],[17,"PRIO_MIN","","",N,N],[17,"PRIO_MAX","","",N,N],[17,"IPPROTO_ICMP","","",N,N],[17,"IPPROTO_ICMPV6","","",N,N],[17,"IPPROTO_TCP","","",N,N],[17,"IPPROTO_UDP","","",N,N],[17,"IPPROTO_IP","","",N,N],[17,"IPPROTO_IPV6","","",N,N],[17,"INADDR_LOOPBACK","","",N,N],[17,"INADDR_ANY","","",N,N],[17,"INADDR_BROADCAST","","",N,N],[17,"INADDR_NONE","","",N,N],[17,"ARPOP_REQUEST","","",N,N],[17,"ARPOP_REPLY","","",N,N],[17,"ATF_COM","","",N,N],[17,"ATF_PERM","","",N,N],[17,"ATF_PUBL","","",N,N],[17,"ATF_USETRAILERS","","",N,N],[17,"EXIT_FAILURE","","",N,N],[17,"EXIT_SUCCESS","","",N,N],[17,"RAND_MAX","","",N,N],[17,"EOF","","",N,N],[17,"SEEK_SET","","",N,N],[17,"SEEK_CUR","","",N,N],[17,"SEEK_END","","",N,N],[17,"_IOFBF","","",N,N],[17,"_IONBF","","",N,N],[17,"_IOLBF","","",N,N],[17,"F_DUPFD","","",N,N],[17,"F_GETFD","","",N,N],[17,"F_SETFD","","",N,N],[17,"F_GETFL","","",N,N],[17,"F_SETFL","","",N,N],[17,"F_SETLEASE","","",N,N],[17,"F_GETLEASE","","",N,N],[17,"F_NOTIFY","","",N,N],[17,"F_CANCELLK","","",N,N],[17,"F_DUPFD_CLOEXEC","","",N,N],[17,"F_SETPIPE_SZ","","",N,N],[17,"F_GETPIPE_SZ","","",N,N],[17,"F_ADD_SEALS","","",N,N],[17,"F_GET_SEALS","","",N,N],[17,"F_SEAL_SEAL","","",N,N],[17,"F_SEAL_SHRINK","","",N,N],[17,"F_SEAL_GROW","","",N,N],[17,"F_SEAL_WRITE","","",N,N],[17,"SIGTRAP","","",N,N],[17,"PTHREAD_CREATE_JOINABLE","","",N,N],[17,"PTHREAD_CREATE_DETACHED","","",N,N],[17,"CLOCK_REALTIME","","",N,N],[17,"CLOCK_MONOTONIC","","",N,N],[17,"CLOCK_PROCESS_CPUTIME_ID","","",N,N],[17,"CLOCK_THREAD_CPUTIME_ID","","",N,N],[17,"CLOCK_MONOTONIC_RAW","","",N,N],[17,"CLOCK_REALTIME_COARSE","","",N,N],[17,"CLOCK_MONOTONIC_COARSE","","",N,N],[17,"CLOCK_BOOTTIME","","",N,N],[17,"CLOCK_REALTIME_ALARM","","",N,N],[17,"CLOCK_BOOTTIME_ALARM","","",N,N],[17,"TIMER_ABSTIME","","",N,N],[17,"RLIMIT_CPU","","",N,N],[17,"RLIMIT_FSIZE","","",N,N],[17,"RLIMIT_DATA","","",N,N],[17,"RLIMIT_STACK","","",N,N],[17,"RLIMIT_CORE","","",N,N],[17,"RLIMIT_LOCKS","","",N,N],[17,"RLIMIT_SIGPENDING","","",N,N],[17,"RLIMIT_MSGQUEUE","","",N,N],[17,"RLIMIT_NICE","","",N,N],[17,"RLIMIT_RTPRIO","","",N,N],[17,"RUSAGE_SELF","","",N,N],[17,"O_RDONLY","","",N,N],[17,"O_WRONLY","","",N,N],[17,"O_RDWR","","",N,N],[17,"SOCK_CLOEXEC","","",N,N],[17,"S_IFIFO","","",N,N],[17,"S_IFCHR","","",N,N],[17,"S_IFBLK","","",N,N],[17,"S_IFDIR","","",N,N],[17,"S_IFREG","","",N,N],[17,"S_IFLNK","","",N,N],[17,"S_IFSOCK","","",N,N],[17,"S_IFMT","","",N,N],[17,"S_IRWXU","","",N,N],[17,"S_IXUSR","","",N,N],[17,"S_IWUSR","","",N,N],[17,"S_IRUSR","","",N,N],[17,"S_IRWXG","","",N,N],[17,"S_IXGRP","","",N,N],[17,"S_IWGRP","","",N,N],[17,"S_IRGRP","","",N,N],[17,"S_IRWXO","","",N,N],[17,"S_IXOTH","","",N,N],[17,"S_IWOTH","","",N,N],[17,"S_IROTH","","",N,N],[17,"F_OK","","",N,N],[17,"R_OK","","",N,N],[17,"W_OK","","",N,N],[17,"X_OK","","",N,N],[17,"STDIN_FILENO","","",N,N],[17,"STDOUT_FILENO","","",N,N],[17,"STDERR_FILENO","","",N,N],[17,"SIGHUP","","",N,N],[17,"SIGINT","","",N,N],[17,"SIGQUIT","","",N,N],[17,"SIGILL","","",N,N],[17,"SIGABRT","","",N,N],[17,"SIGFPE","","",N,N],[17,"SIGKILL","","",N,N],[17,"SIGSEGV","","",N,N],[17,"SIGPIPE","","",N,N],[17,"SIGALRM","","",N,N],[17,"SIGTERM","","",N,N],[17,"PROT_NONE","","",N,N],[17,"PROT_READ","","",N,N],[17,"PROT_WRITE","","",N,N],[17,"PROT_EXEC","","",N,N],[17,"LC_CTYPE","","",N,N],[17,"LC_NUMERIC","","",N,N],[17,"LC_TIME","","",N,N],[17,"LC_COLLATE","","",N,N],[17,"LC_MONETARY","","",N,N],[17,"LC_MESSAGES","","",N,N],[17,"LC_ALL","","",N,N],[17,"LC_CTYPE_MASK","","",N,N],[17,"LC_NUMERIC_MASK","","",N,N],[17,"LC_TIME_MASK","","",N,N],[17,"LC_COLLATE_MASK","","",N,N],[17,"LC_MONETARY_MASK","","",N,N],[17,"LC_MESSAGES_MASK","","",N,N],[17,"MAP_FILE","","",N,N],[17,"MAP_SHARED","","",N,N],[17,"MAP_PRIVATE","","",N,N],[17,"MAP_FIXED","","",N,N],[17,"MAP_FAILED","","",N,N],[17,"MS_ASYNC","","",N,N],[17,"MS_INVALIDATE","","",N,N],[17,"MS_SYNC","","",N,N],[17,"MS_RDONLY","","",N,N],[17,"MS_NOSUID","","",N,N],[17,"MS_NODEV","","",N,N],[17,"MS_NOEXEC","","",N,N],[17,"MS_SYNCHRONOUS","","",N,N],[17,"MS_REMOUNT","","",N,N],[17,"MS_MANDLOCK","","",N,N],[17,"MS_DIRSYNC","","",N,N],[17,"MS_NOATIME","","",N,N],[17,"MS_NODIRATIME","","",N,N],[17,"MS_BIND","","",N,N],[17,"MS_MOVE","","",N,N],[17,"MS_REC","","",N,N],[17,"MS_SILENT","","",N,N],[17,"MS_POSIXACL","","",N,N],[17,"MS_UNBINDABLE","","",N,N],[17,"MS_PRIVATE","","",N,N],[17,"MS_SLAVE","","",N,N],[17,"MS_SHARED","","",N,N],[17,"MS_RELATIME","","",N,N],[17,"MS_KERNMOUNT","","",N,N],[17,"MS_I_VERSION","","",N,N],[17,"MS_STRICTATIME","","",N,N],[17,"MS_ACTIVE","","",N,N],[17,"MS_NOUSER","","",N,N],[17,"MS_MGC_VAL","","",N,N],[17,"MS_MGC_MSK","","",N,N],[17,"MS_RMT_MASK","","",N,N],[17,"EPERM","","",N,N],[17,"ENOENT","","",N,N],[17,"ESRCH","","",N,N],[17,"EINTR","","",N,N],[17,"EIO","","",N,N],[17,"ENXIO","","",N,N],[17,"E2BIG","","",N,N],[17,"ENOEXEC","","",N,N],[17,"EBADF","","",N,N],[17,"ECHILD","","",N,N],[17,"EAGAIN","","",N,N],[17,"ENOMEM","","",N,N],[17,"EACCES","","",N,N],[17,"EFAULT","","",N,N],[17,"ENOTBLK","","",N,N],[17,"EBUSY","","",N,N],[17,"EEXIST","","",N,N],[17,"EXDEV","","",N,N],[17,"ENODEV","","",N,N],[17,"ENOTDIR","","",N,N],[17,"EISDIR","","",N,N],[17,"EINVAL","","",N,N],[17,"ENFILE","","",N,N],[17,"EMFILE","","",N,N],[17,"ENOTTY","","",N,N],[17,"ETXTBSY","","",N,N],[17,"EFBIG","","",N,N],[17,"ENOSPC","","",N,N],[17,"ESPIPE","","",N,N],[17,"EROFS","","",N,N],[17,"EMLINK","","",N,N],[17,"EPIPE","","",N,N],[17,"EDOM","","",N,N],[17,"ERANGE","","",N,N],[17,"EWOULDBLOCK","","",N,N],[17,"SCM_RIGHTS","","",N,N],[17,"SCM_CREDENTIALS","","",N,N],[17,"PROT_GROWSDOWN","","",N,N],[17,"PROT_GROWSUP","","",N,N],[17,"MAP_TYPE","","",N,N],[17,"MADV_NORMAL","","",N,N],[17,"MADV_RANDOM","","",N,N],[17,"MADV_SEQUENTIAL","","",N,N],[17,"MADV_WILLNEED","","",N,N],[17,"MADV_DONTNEED","","",N,N],[17,"MADV_FREE","","",N,N],[17,"MADV_REMOVE","","",N,N],[17,"MADV_DONTFORK","","",N,N],[17,"MADV_DOFORK","","",N,N],[17,"MADV_MERGEABLE","","",N,N],[17,"MADV_UNMERGEABLE","","",N,N],[17,"MADV_HUGEPAGE","","",N,N],[17,"MADV_NOHUGEPAGE","","",N,N],[17,"MADV_DONTDUMP","","",N,N],[17,"MADV_DODUMP","","",N,N],[17,"MADV_HWPOISON","","",N,N],[17,"MADV_SOFT_OFFLINE","","",N,N],[17,"IFF_UP","","",N,N],[17,"IFF_BROADCAST","","",N,N],[17,"IFF_DEBUG","","",N,N],[17,"IFF_LOOPBACK","","",N,N],[17,"IFF_POINTOPOINT","","",N,N],[17,"IFF_NOTRAILERS","","",N,N],[17,"IFF_RUNNING","","",N,N],[17,"IFF_NOARP","","",N,N],[17,"IFF_PROMISC","","",N,N],[17,"IFF_ALLMULTI","","",N,N],[17,"IFF_MASTER","","",N,N],[17,"IFF_SLAVE","","",N,N],[17,"IFF_MULTICAST","","",N,N],[17,"IFF_PORTSEL","","",N,N],[17,"IFF_AUTOMEDIA","","",N,N],[17,"IFF_DYNAMIC","","",N,N],[17,"SOL_IP","","",N,N],[17,"SOL_TCP","","",N,N],[17,"SOL_UDP","","",N,N],[17,"SOL_IPV6","","",N,N],[17,"SOL_ICMPV6","","",N,N],[17,"SOL_RAW","","",N,N],[17,"SOL_DECNET","","",N,N],[17,"SOL_X25","","",N,N],[17,"SOL_PACKET","","",N,N],[17,"SOL_ATM","","",N,N],[17,"SOL_AAL","","",N,N],[17,"SOL_IRDA","","",N,N],[17,"SOL_NETBEUI","","",N,N],[17,"SOL_LLC","","",N,N],[17,"SOL_DCCP","","",N,N],[17,"SOL_NETLINK","","",N,N],[17,"SOL_TIPC","","",N,N],[17,"SOL_BLUETOOTH","","",N,N],[17,"SOL_ALG","","",N,N],[17,"AF_UNSPEC","","",N,N],[17,"AF_UNIX","","",N,N],[17,"AF_LOCAL","","",N,N],[17,"AF_INET","","",N,N],[17,"AF_AX25","","",N,N],[17,"AF_IPX","","",N,N],[17,"AF_APPLETALK","","",N,N],[17,"AF_NETROM","","",N,N],[17,"AF_BRIDGE","","",N,N],[17,"AF_ATMPVC","","",N,N],[17,"AF_X25","","",N,N],[17,"AF_INET6","","",N,N],[17,"AF_ROSE","","",N,N],[17,"AF_DECnet","","",N,N],[17,"AF_NETBEUI","","",N,N],[17,"AF_SECURITY","","",N,N],[17,"AF_KEY","","",N,N],[17,"AF_NETLINK","","",N,N],[17,"AF_ROUTE","","",N,N],[17,"AF_PACKET","","",N,N],[17,"AF_ASH","","",N,N],[17,"AF_ECONET","","",N,N],[17,"AF_ATMSVC","","",N,N],[17,"AF_RDS","","",N,N],[17,"AF_SNA","","",N,N],[17,"AF_IRDA","","",N,N],[17,"AF_PPPOX","","",N,N],[17,"AF_WANPIPE","","",N,N],[17,"AF_LLC","","",N,N],[17,"AF_CAN","","",N,N],[17,"AF_TIPC","","",N,N],[17,"AF_BLUETOOTH","","",N,N],[17,"AF_IUCV","","",N,N],[17,"AF_RXRPC","","",N,N],[17,"AF_ISDN","","",N,N],[17,"AF_PHONET","","",N,N],[17,"AF_IEEE802154","","",N,N],[17,"AF_CAIF","","",N,N],[17,"AF_ALG","","",N,N],[17,"PF_UNSPEC","","",N,N],[17,"PF_UNIX","","",N,N],[17,"PF_LOCAL","","",N,N],[17,"PF_INET","","",N,N],[17,"PF_AX25","","",N,N],[17,"PF_IPX","","",N,N],[17,"PF_APPLETALK","","",N,N],[17,"PF_NETROM","","",N,N],[17,"PF_BRIDGE","","",N,N],[17,"PF_ATMPVC","","",N,N],[17,"PF_X25","","",N,N],[17,"PF_INET6","","",N,N],[17,"PF_ROSE","","",N,N],[17,"PF_DECnet","","",N,N],[17,"PF_NETBEUI","","",N,N],[17,"PF_SECURITY","","",N,N],[17,"PF_KEY","","",N,N],[17,"PF_NETLINK","","",N,N],[17,"PF_ROUTE","","",N,N],[17,"PF_PACKET","","",N,N],[17,"PF_ASH","","",N,N],[17,"PF_ECONET","","",N,N],[17,"PF_ATMSVC","","",N,N],[17,"PF_RDS","","",N,N],[17,"PF_SNA","","",N,N],[17,"PF_IRDA","","",N,N],[17,"PF_PPPOX","","",N,N],[17,"PF_WANPIPE","","",N,N],[17,"PF_LLC","","",N,N],[17,"PF_CAN","","",N,N],[17,"PF_TIPC","","",N,N],[17,"PF_BLUETOOTH","","",N,N],[17,"PF_IUCV","","",N,N],[17,"PF_RXRPC","","",N,N],[17,"PF_ISDN","","",N,N],[17,"PF_PHONET","","",N,N],[17,"PF_IEEE802154","","",N,N],[17,"PF_CAIF","","",N,N],[17,"PF_ALG","","",N,N],[17,"SOMAXCONN","","",N,N],[17,"MSG_OOB","","",N,N],[17,"MSG_PEEK","","",N,N],[17,"MSG_DONTROUTE","","",N,N],[17,"MSG_CTRUNC","","",N,N],[17,"MSG_TRUNC","","",N,N],[17,"MSG_DONTWAIT","","",N,N],[17,"MSG_EOR","","",N,N],[17,"MSG_WAITALL","","",N,N],[17,"MSG_FIN","","",N,N],[17,"MSG_SYN","","",N,N],[17,"MSG_CONFIRM","","",N,N],[17,"MSG_RST","","",N,N],[17,"MSG_ERRQUEUE","","",N,N],[17,"MSG_NOSIGNAL","","",N,N],[17,"MSG_MORE","","",N,N],[17,"MSG_WAITFORONE","","",N,N],[17,"MSG_FASTOPEN","","",N,N],[17,"MSG_CMSG_CLOEXEC","","",N,N],[17,"SCM_TIMESTAMP","","",N,N],[17,"SOCK_RAW","","",N,N],[17,"SOCK_RDM","","",N,N],[17,"IP_MULTICAST_IF","","",N,N],[17,"IP_MULTICAST_TTL","","",N,N],[17,"IP_MULTICAST_LOOP","","",N,N],[17,"IP_TOS","","",N,N],[17,"IP_TTL","","",N,N],[17,"IP_HDRINCL","","",N,N],[17,"IP_PKTINFO","","",N,N],[17,"IP_RECVTOS","","",N,N],[17,"IP_ADD_MEMBERSHIP","","",N,N],[17,"IP_DROP_MEMBERSHIP","","",N,N],[17,"IP_TRANSPARENT","","",N,N],[17,"IPV6_FLOWINFO","","",N,N],[17,"IPV6_UNICAST_HOPS","","",N,N],[17,"IPV6_MULTICAST_IF","","",N,N],[17,"IPV6_MULTICAST_HOPS","","",N,N],[17,"IPV6_MULTICAST_LOOP","","",N,N],[17,"IPV6_ADD_MEMBERSHIP","","",N,N],[17,"IPV6_DROP_MEMBERSHIP","","",N,N],[17,"IPV6_V6ONLY","","",N,N],[17,"IPV6_FLOWLABEL_MGR","","",N,N],[17,"IPV6_FLOWINFO_SEND","","",N,N],[17,"IPV6_RECVPKTINFO","","",N,N],[17,"IPV6_PKTINFO","","",N,N],[17,"IPV6_RECVTCLASS","","",N,N],[17,"IPV6_TCLASS","","",N,N],[17,"IPV6_FLOWINFO_FLOWLABEL","","",N,N],[17,"IPV6_FLOWINFO_PRIORITY","","",N,N],[17,"TCP_NODELAY","","",N,N],[17,"TCP_MAXSEG","","",N,N],[17,"TCP_CORK","","",N,N],[17,"TCP_KEEPIDLE","","",N,N],[17,"TCP_KEEPINTVL","","",N,N],[17,"TCP_KEEPCNT","","",N,N],[17,"TCP_SYNCNT","","",N,N],[17,"TCP_LINGER2","","",N,N],[17,"TCP_DEFER_ACCEPT","","",N,N],[17,"TCP_WINDOW_CLAMP","","",N,N],[17,"TCP_INFO","","",N,N],[17,"TCP_QUICKACK","","",N,N],[17,"TCP_CONGESTION","","",N,N],[17,"SO_DEBUG","","",N,N],[17,"SHUT_RD","","",N,N],[17,"SHUT_WR","","",N,N],[17,"SHUT_RDWR","","",N,N],[17,"LOCK_SH","","",N,N],[17,"LOCK_EX","","",N,N],[17,"LOCK_NB","","",N,N],[17,"LOCK_UN","","",N,N],[17,"SS_ONSTACK","","",N,N],[17,"SS_DISABLE","","",N,N],[17,"PATH_MAX","","",N,N],[17,"FD_SETSIZE","","",N,N],[17,"EPOLLIN","","",N,N],[17,"EPOLLPRI","","",N,N],[17,"EPOLLOUT","","",N,N],[17,"EPOLLRDNORM","","",N,N],[17,"EPOLLRDBAND","","",N,N],[17,"EPOLLWRNORM","","",N,N],[17,"EPOLLWRBAND","","",N,N],[17,"EPOLLMSG","","",N,N],[17,"EPOLLERR","","",N,N],[17,"EPOLLHUP","","",N,N],[17,"EPOLLET","","",N,N],[17,"EPOLL_CTL_ADD","","",N,N],[17,"EPOLL_CTL_MOD","","",N,N],[17,"EPOLL_CTL_DEL","","",N,N],[17,"MNT_DETACH","","",N,N],[17,"MNT_EXPIRE","","",N,N],[17,"Q_GETFMT","","",N,N],[17,"Q_GETINFO","","",N,N],[17,"Q_SETINFO","","",N,N],[17,"QIF_BLIMITS","","",N,N],[17,"QIF_SPACE","","",N,N],[17,"QIF_ILIMITS","","",N,N],[17,"QIF_INODES","","",N,N],[17,"QIF_BTIME","","",N,N],[17,"QIF_ITIME","","",N,N],[17,"QIF_LIMITS","","",N,N],[17,"QIF_USAGE","","",N,N],[17,"QIF_TIMES","","",N,N],[17,"QIF_ALL","","",N,N],[17,"MNT_FORCE","","",N,N],[17,"Q_SYNC","","",N,N],[17,"Q_QUOTAON","","",N,N],[17,"Q_QUOTAOFF","","",N,N],[17,"Q_GETQUOTA","","",N,N],[17,"Q_SETQUOTA","","",N,N],[17,"TCIOFF","","",N,N],[17,"TCION","","",N,N],[17,"TCOOFF","","",N,N],[17,"TCOON","","",N,N],[17,"TCIFLUSH","","",N,N],[17,"TCOFLUSH","","",N,N],[17,"TCIOFLUSH","","",N,N],[17,"NL0","","",N,N],[17,"NL1","","",N,N],[17,"TAB0","","",N,N],[17,"CR0","","",N,N],[17,"FF0","","",N,N],[17,"BS0","","",N,N],[17,"VT0","","",N,N],[17,"VERASE","","",N,N],[17,"VKILL","","",N,N],[17,"VINTR","","",N,N],[17,"VQUIT","","",N,N],[17,"VLNEXT","","",N,N],[17,"IGNBRK","","",N,N],[17,"BRKINT","","",N,N],[17,"IGNPAR","","",N,N],[17,"PARMRK","","",N,N],[17,"INPCK","","",N,N],[17,"ISTRIP","","",N,N],[17,"INLCR","","",N,N],[17,"IGNCR","","",N,N],[17,"ICRNL","","",N,N],[17,"IXANY","","",N,N],[17,"IMAXBEL","","",N,N],[17,"OPOST","","",N,N],[17,"CS5","","",N,N],[17,"CRTSCTS","","",N,N],[17,"ECHO","","",N,N],[17,"OCRNL","","",N,N],[17,"ONOCR","","",N,N],[17,"ONLRET","","",N,N],[17,"OFILL","","",N,N],[17,"OFDEL","","",N,N],[17,"CLONE_VM","","",N,N],[17,"CLONE_FS","","",N,N],[17,"CLONE_FILES","","",N,N],[17,"CLONE_SIGHAND","","",N,N],[17,"CLONE_PTRACE","","",N,N],[17,"CLONE_VFORK","","",N,N],[17,"CLONE_PARENT","","",N,N],[17,"CLONE_THREAD","","",N,N],[17,"CLONE_NEWNS","","",N,N],[17,"CLONE_SYSVSEM","","",N,N],[17,"CLONE_SETTLS","","",N,N],[17,"CLONE_PARENT_SETTID","","",N,N],[17,"CLONE_CHILD_CLEARTID","","",N,N],[17,"CLONE_DETACHED","","",N,N],[17,"CLONE_UNTRACED","","",N,N],[17,"CLONE_CHILD_SETTID","","",N,N],[17,"CLONE_NEWUTS","","",N,N],[17,"CLONE_NEWIPC","","",N,N],[17,"CLONE_NEWUSER","","",N,N],[17,"CLONE_NEWPID","","",N,N],[17,"CLONE_NEWNET","","",N,N],[17,"CLONE_IO","","",N,N],[17,"CLONE_NEWCGROUP","","",N,N],[17,"WNOHANG","","",N,N],[17,"WUNTRACED","","",N,N],[17,"WSTOPPED","","",N,N],[17,"WEXITED","","",N,N],[17,"WCONTINUED","","",N,N],[17,"WNOWAIT","","",N,N],[17,"PTRACE_O_TRACESYSGOOD","","",N,N],[17,"PTRACE_O_TRACEFORK","","",N,N],[17,"PTRACE_O_TRACEVFORK","","",N,N],[17,"PTRACE_O_TRACECLONE","","",N,N],[17,"PTRACE_O_TRACEEXEC","","",N,N],[17,"PTRACE_O_TRACEVFORKDONE","","",N,N],[17,"PTRACE_O_TRACEEXIT","","",N,N],[17,"PTRACE_O_TRACESECCOMP","","",N,N],[17,"PTRACE_O_EXITKILL","","",N,N],[17,"PTRACE_O_SUSPEND_SECCOMP","","",N,N],[17,"PTRACE_O_MASK","","",N,N],[17,"PTRACE_EVENT_FORK","","",N,N],[17,"PTRACE_EVENT_VFORK","","",N,N],[17,"PTRACE_EVENT_CLONE","","",N,N],[17,"PTRACE_EVENT_EXEC","","",N,N],[17,"PTRACE_EVENT_VFORK_DONE","","",N,N],[17,"PTRACE_EVENT_EXIT","","",N,N],[17,"PTRACE_EVENT_SECCOMP","","",N,N],[17,"__WNOTHREAD","","",N,N],[17,"__WALL","","",N,N],[17,"__WCLONE","","",N,N],[17,"SPLICE_F_MOVE","","",N,N],[17,"SPLICE_F_NONBLOCK","","",N,N],[17,"SPLICE_F_MORE","","",N,N],[17,"SPLICE_F_GIFT","","",N,N],[17,"RTLD_LOCAL","","",N,N],[17,"RTLD_LAZY","","",N,N],[17,"POSIX_FADV_NORMAL","","",N,N],[17,"POSIX_FADV_RANDOM","","",N,N],[17,"POSIX_FADV_SEQUENTIAL","","",N,N],[17,"POSIX_FADV_WILLNEED","","",N,N],[17,"AT_FDCWD","","",N,N],[17,"AT_SYMLINK_NOFOLLOW","","",N,N],[17,"AT_REMOVEDIR","","",N,N],[17,"AT_SYMLINK_FOLLOW","","",N,N],[17,"AT_NO_AUTOMOUNT","","",N,N],[17,"AT_EMPTY_PATH","","",N,N],[17,"LOG_CRON","","",N,N],[17,"LOG_AUTHPRIV","","",N,N],[17,"LOG_FTP","","",N,N],[17,"LOG_PERROR","","",N,N],[17,"PIPE_BUF","","",N,N],[17,"SI_LOAD_SHIFT","","",N,N],[17,"SIGEV_SIGNAL","","",N,N],[17,"SIGEV_NONE","","",N,N],[17,"SIGEV_THREAD","","",N,N],[17,"P_ALL","","",N,N],[17,"P_PID","","",N,N],[17,"P_PGID","","",N,N],[17,"UTIME_OMIT","","",N,N],[17,"UTIME_NOW","","",N,N],[17,"POLLIN","","",N,N],[17,"POLLPRI","","",N,N],[17,"POLLOUT","","",N,N],[17,"POLLERR","","",N,N],[17,"POLLHUP","","",N,N],[17,"POLLNVAL","","",N,N],[17,"POLLRDNORM","","",N,N],[17,"POLLRDBAND","","",N,N],[17,"IPTOS_LOWDELAY","","",N,N],[17,"IPTOS_THROUGHPUT","","",N,N],[17,"IPTOS_RELIABILITY","","",N,N],[17,"IPTOS_MINCOST","","",N,N],[17,"IPTOS_PREC_NETCONTROL","","",N,N],[17,"IPTOS_PREC_INTERNETCONTROL","","",N,N],[17,"IPTOS_PREC_CRITIC_ECP","","",N,N],[17,"IPTOS_PREC_FLASHOVERRIDE","","",N,N],[17,"IPTOS_PREC_FLASH","","",N,N],[17,"IPTOS_PREC_IMMEDIATE","","",N,N],[17,"IPTOS_PREC_PRIORITY","","",N,N],[17,"IPTOS_PREC_ROUTINE","","",N,N],[17,"IPTOS_ECN_MASK","","",N,N],[17,"IPTOS_ECN_ECT1","","",N,N],[17,"IPTOS_ECN_ECT0","","",N,N],[17,"IPTOS_ECN_CE","","",N,N],[17,"IPOPT_COPY","","",N,N],[17,"IPOPT_CLASS_MASK","","",N,N],[17,"IPOPT_NUMBER_MASK","","",N,N],[17,"IPOPT_CONTROL","","",N,N],[17,"IPOPT_RESERVED1","","",N,N],[17,"IPOPT_MEASUREMENT","","",N,N],[17,"IPOPT_RESERVED2","","",N,N],[17,"IPOPT_END","","",N,N],[17,"IPOPT_NOOP","","",N,N],[17,"IPOPT_SEC","","",N,N],[17,"IPOPT_LSRR","","",N,N],[17,"IPOPT_TIMESTAMP","","",N,N],[17,"IPOPT_RR","","",N,N],[17,"IPOPT_SID","","",N,N],[17,"IPOPT_SSRR","","",N,N],[17,"IPOPT_RA","","",N,N],[17,"IPVERSION","","",N,N],[17,"MAXTTL","","",N,N],[17,"IPDEFTTL","","",N,N],[17,"IPOPT_OPTVAL","","",N,N],[17,"IPOPT_OLEN","","",N,N],[17,"IPOPT_OFFSET","","",N,N],[17,"IPOPT_MINOFF","","",N,N],[17,"MAX_IPOPTLEN","","",N,N],[17,"IPOPT_NOP","","",N,N],[17,"IPOPT_EOL","","",N,N],[17,"IPOPT_TS","","",N,N],[17,"IPOPT_TS_TSONLY","","",N,N],[17,"IPOPT_TS_TSANDADDR","","",N,N],[17,"IPOPT_TS_PRESPEC","","",N,N],[17,"ARPOP_RREQUEST","","",N,N],[17,"ARPOP_RREPLY","","",N,N],[17,"ARPOP_InREQUEST","","",N,N],[17,"ARPOP_InREPLY","","",N,N],[17,"ARPOP_NAK","","",N,N],[17,"ATF_NETMASK","","",N,N],[17,"ATF_DONTPUB","","",N,N],[17,"ARPHRD_NETROM","","",N,N],[17,"ARPHRD_ETHER","","",N,N],[17,"ARPHRD_EETHER","","",N,N],[17,"ARPHRD_AX25","","",N,N],[17,"ARPHRD_PRONET","","",N,N],[17,"ARPHRD_CHAOS","","",N,N],[17,"ARPHRD_IEEE802","","",N,N],[17,"ARPHRD_ARCNET","","",N,N],[17,"ARPHRD_APPLETLK","","",N,N],[17,"ARPHRD_DLCI","","",N,N],[17,"ARPHRD_ATM","","",N,N],[17,"ARPHRD_METRICOM","","",N,N],[17,"ARPHRD_IEEE1394","","",N,N],[17,"ARPHRD_EUI64","","",N,N],[17,"ARPHRD_INFINIBAND","","",N,N],[17,"ARPHRD_SLIP","","",N,N],[17,"ARPHRD_CSLIP","","",N,N],[17,"ARPHRD_SLIP6","","",N,N],[17,"ARPHRD_CSLIP6","","",N,N],[17,"ARPHRD_RSRVD","","",N,N],[17,"ARPHRD_ADAPT","","",N,N],[17,"ARPHRD_ROSE","","",N,N],[17,"ARPHRD_X25","","",N,N],[17,"ARPHRD_HWX25","","",N,N],[17,"ARPHRD_PPP","","",N,N],[17,"ARPHRD_CISCO","","",N,N],[17,"ARPHRD_HDLC","","",N,N],[17,"ARPHRD_LAPB","","",N,N],[17,"ARPHRD_DDCMP","","",N,N],[17,"ARPHRD_RAWHDLC","","",N,N],[17,"ARPHRD_TUNNEL","","",N,N],[17,"ARPHRD_TUNNEL6","","",N,N],[17,"ARPHRD_FRAD","","",N,N],[17,"ARPHRD_SKIP","","",N,N],[17,"ARPHRD_LOOPBACK","","",N,N],[17,"ARPHRD_LOCALTLK","","",N,N],[17,"ARPHRD_FDDI","","",N,N],[17,"ARPHRD_BIF","","",N,N],[17,"ARPHRD_SIT","","",N,N],[17,"ARPHRD_IPDDP","","",N,N],[17,"ARPHRD_IPGRE","","",N,N],[17,"ARPHRD_PIMREG","","",N,N],[17,"ARPHRD_HIPPI","","",N,N],[17,"ARPHRD_ASH","","",N,N],[17,"ARPHRD_ECONET","","",N,N],[17,"ARPHRD_IRDA","","",N,N],[17,"ARPHRD_FCPP","","",N,N],[17,"ARPHRD_FCAL","","",N,N],[17,"ARPHRD_FCPL","","",N,N],[17,"ARPHRD_FCFABRIC","","",N,N],[17,"ARPHRD_IEEE802_TR","","",N,N],[17,"ARPHRD_IEEE80211","","",N,N],[17,"ARPHRD_IEEE80211_PRISM","","",N,N],[17,"ARPHRD_IEEE80211_RADIOTAP","","",N,N],[17,"ARPHRD_IEEE802154","","",N,N],[17,"ARPHRD_VOID","","",N,N],[17,"ARPHRD_NONE","","",N,N],[17,"IN_ACCESS","","",N,N],[17,"IN_MODIFY","","",N,N],[17,"IN_ATTRIB","","",N,N],[17,"IN_CLOSE_WRITE","","",N,N],[17,"IN_CLOSE_NOWRITE","","",N,N],[17,"IN_CLOSE","","",N,N],[17,"IN_OPEN","","",N,N],[17,"IN_MOVED_FROM","","",N,N],[17,"IN_MOVED_TO","","",N,N],[17,"IN_MOVE","","",N,N],[17,"IN_CREATE","","",N,N],[17,"IN_DELETE","","",N,N],[17,"IN_DELETE_SELF","","",N,N],[17,"IN_MOVE_SELF","","",N,N],[17,"IN_UNMOUNT","","",N,N],[17,"IN_Q_OVERFLOW","","",N,N],[17,"IN_IGNORED","","",N,N],[17,"IN_ONLYDIR","","",N,N],[17,"IN_DONT_FOLLOW","","",N,N],[17,"IN_ISDIR","","",N,N],[17,"IN_ONESHOT","","",N,N],[17,"IN_ALL_EVENTS","","",N,N],[17,"IN_CLOEXEC","","",N,N],[17,"IN_NONBLOCK","","",N,N],[17,"ABDAY_1","","",N,N],[17,"ABDAY_2","","",N,N],[17,"ABDAY_3","","",N,N],[17,"ABDAY_4","","",N,N],[17,"ABDAY_5","","",N,N],[17,"ABDAY_6","","",N,N],[17,"ABDAY_7","","",N,N],[17,"DAY_1","","",N,N],[17,"DAY_2","","",N,N],[17,"DAY_3","","",N,N],[17,"DAY_4","","",N,N],[17,"DAY_5","","",N,N],[17,"DAY_6","","",N,N],[17,"DAY_7","","",N,N],[17,"ABMON_1","","",N,N],[17,"ABMON_2","","",N,N],[17,"ABMON_3","","",N,N],[17,"ABMON_4","","",N,N],[17,"ABMON_5","","",N,N],[17,"ABMON_6","","",N,N],[17,"ABMON_7","","",N,N],[17,"ABMON_8","","",N,N],[17,"ABMON_9","","",N,N],[17,"ABMON_10","","",N,N],[17,"ABMON_11","","",N,N],[17,"ABMON_12","","",N,N],[17,"MON_1","","",N,N],[17,"MON_2","","",N,N],[17,"MON_3","","",N,N],[17,"MON_4","","",N,N],[17,"MON_5","","",N,N],[17,"MON_6","","",N,N],[17,"MON_7","","",N,N],[17,"MON_8","","",N,N],[17,"MON_9","","",N,N],[17,"MON_10","","",N,N],[17,"MON_11","","",N,N],[17,"MON_12","","",N,N],[17,"AM_STR","","",N,N],[17,"PM_STR","","",N,N],[17,"D_T_FMT","","",N,N],[17,"D_FMT","","",N,N],[17,"T_FMT","","",N,N],[17,"T_FMT_AMPM","","",N,N],[17,"ERA","","",N,N],[17,"ERA_D_FMT","","",N,N],[17,"ALT_DIGITS","","",N,N],[17,"ERA_D_T_FMT","","",N,N],[17,"ERA_T_FMT","","",N,N],[17,"CODESET","","",N,N],[17,"CRNCYSTR","","",N,N],[17,"RUSAGE_THREAD","","",N,N],[17,"RUSAGE_CHILDREN","","",N,N],[17,"RADIXCHAR","","",N,N],[17,"THOUSEP","","",N,N],[17,"YESEXPR","","",N,N],[17,"NOEXPR","","",N,N],[17,"YESSTR","","",N,N],[17,"NOSTR","","",N,N],[17,"FILENAME_MAX","","",N,N],[17,"L_tmpnam","","",N,N],[17,"_PC_LINK_MAX","","",N,N],[17,"_PC_MAX_CANON","","",N,N],[17,"_PC_MAX_INPUT","","",N,N],[17,"_PC_NAME_MAX","","",N,N],[17,"_PC_PATH_MAX","","",N,N],[17,"_PC_PIPE_BUF","","",N,N],[17,"_PC_CHOWN_RESTRICTED","","",N,N],[17,"_PC_NO_TRUNC","","",N,N],[17,"_PC_VDISABLE","","",N,N],[17,"_PC_SYNC_IO","","",N,N],[17,"_PC_ASYNC_IO","","",N,N],[17,"_PC_PRIO_IO","","",N,N],[17,"_PC_SOCK_MAXBUF","","",N,N],[17,"_PC_FILESIZEBITS","","",N,N],[17,"_PC_REC_INCR_XFER_SIZE","","",N,N],[17,"_PC_REC_MAX_XFER_SIZE","","",N,N],[17,"_PC_REC_MIN_XFER_SIZE","","",N,N],[17,"_PC_REC_XFER_ALIGN","","",N,N],[17,"_PC_ALLOC_SIZE_MIN","","",N,N],[17,"_PC_SYMLINK_MAX","","",N,N],[17,"_PC_2_SYMLINKS","","",N,N],[17,"_SC_ARG_MAX","","",N,N],[17,"_SC_CHILD_MAX","","",N,N],[17,"_SC_CLK_TCK","","",N,N],[17,"_SC_NGROUPS_MAX","","",N,N],[17,"_SC_OPEN_MAX","","",N,N],[17,"_SC_STREAM_MAX","","",N,N],[17,"_SC_TZNAME_MAX","","",N,N],[17,"_SC_JOB_CONTROL","","",N,N],[17,"_SC_SAVED_IDS","","",N,N],[17,"_SC_REALTIME_SIGNALS","","",N,N],[17,"_SC_PRIORITY_SCHEDULING","","",N,N],[17,"_SC_TIMERS","","",N,N],[17,"_SC_ASYNCHRONOUS_IO","","",N,N],[17,"_SC_PRIORITIZED_IO","","",N,N],[17,"_SC_SYNCHRONIZED_IO","","",N,N],[17,"_SC_FSYNC","","",N,N],[17,"_SC_MAPPED_FILES","","",N,N],[17,"_SC_MEMLOCK","","",N,N],[17,"_SC_MEMLOCK_RANGE","","",N,N],[17,"_SC_MEMORY_PROTECTION","","",N,N],[17,"_SC_MESSAGE_PASSING","","",N,N],[17,"_SC_SEMAPHORES","","",N,N],[17,"_SC_SHARED_MEMORY_OBJECTS","","",N,N],[17,"_SC_AIO_LISTIO_MAX","","",N,N],[17,"_SC_AIO_MAX","","",N,N],[17,"_SC_AIO_PRIO_DELTA_MAX","","",N,N],[17,"_SC_DELAYTIMER_MAX","","",N,N],[17,"_SC_MQ_OPEN_MAX","","",N,N],[17,"_SC_MQ_PRIO_MAX","","",N,N],[17,"_SC_VERSION","","",N,N],[17,"_SC_PAGESIZE","","",N,N],[17,"_SC_PAGE_SIZE","","",N,N],[17,"_SC_RTSIG_MAX","","",N,N],[17,"_SC_SEM_NSEMS_MAX","","",N,N],[17,"_SC_SEM_VALUE_MAX","","",N,N],[17,"_SC_SIGQUEUE_MAX","","",N,N],[17,"_SC_TIMER_MAX","","",N,N],[17,"_SC_BC_BASE_MAX","","",N,N],[17,"_SC_BC_DIM_MAX","","",N,N],[17,"_SC_BC_SCALE_MAX","","",N,N],[17,"_SC_BC_STRING_MAX","","",N,N],[17,"_SC_COLL_WEIGHTS_MAX","","",N,N],[17,"_SC_EXPR_NEST_MAX","","",N,N],[17,"_SC_LINE_MAX","","",N,N],[17,"_SC_RE_DUP_MAX","","",N,N],[17,"_SC_2_VERSION","","",N,N],[17,"_SC_2_C_BIND","","",N,N],[17,"_SC_2_C_DEV","","",N,N],[17,"_SC_2_FORT_DEV","","",N,N],[17,"_SC_2_FORT_RUN","","",N,N],[17,"_SC_2_SW_DEV","","",N,N],[17,"_SC_2_LOCALEDEF","","",N,N],[17,"_SC_UIO_MAXIOV","","",N,N],[17,"_SC_IOV_MAX","","",N,N],[17,"_SC_THREADS","","",N,N],[17,"_SC_THREAD_SAFE_FUNCTIONS","","",N,N],[17,"_SC_GETGR_R_SIZE_MAX","","",N,N],[17,"_SC_GETPW_R_SIZE_MAX","","",N,N],[17,"_SC_LOGIN_NAME_MAX","","",N,N],[17,"_SC_TTY_NAME_MAX","","",N,N],[17,"_SC_THREAD_DESTRUCTOR_ITERATIONS","","",N,N],[17,"_SC_THREAD_KEYS_MAX","","",N,N],[17,"_SC_THREAD_STACK_MIN","","",N,N],[17,"_SC_THREAD_THREADS_MAX","","",N,N],[17,"_SC_THREAD_ATTR_STACKADDR","","",N,N],[17,"_SC_THREAD_ATTR_STACKSIZE","","",N,N],[17,"_SC_THREAD_PRIORITY_SCHEDULING","","",N,N],[17,"_SC_THREAD_PRIO_INHERIT","","",N,N],[17,"_SC_THREAD_PRIO_PROTECT","","",N,N],[17,"_SC_THREAD_PROCESS_SHARED","","",N,N],[17,"_SC_NPROCESSORS_CONF","","",N,N],[17,"_SC_NPROCESSORS_ONLN","","",N,N],[17,"_SC_PHYS_PAGES","","",N,N],[17,"_SC_AVPHYS_PAGES","","",N,N],[17,"_SC_ATEXIT_MAX","","",N,N],[17,"_SC_PASS_MAX","","",N,N],[17,"_SC_XOPEN_VERSION","","",N,N],[17,"_SC_XOPEN_XCU_VERSION","","",N,N],[17,"_SC_XOPEN_UNIX","","",N,N],[17,"_SC_XOPEN_CRYPT","","",N,N],[17,"_SC_XOPEN_ENH_I18N","","",N,N],[17,"_SC_XOPEN_SHM","","",N,N],[17,"_SC_2_CHAR_TERM","","",N,N],[17,"_SC_2_UPE","","",N,N],[17,"_SC_XOPEN_XPG2","","",N,N],[17,"_SC_XOPEN_XPG3","","",N,N],[17,"_SC_XOPEN_XPG4","","",N,N],[17,"_SC_NZERO","","",N,N],[17,"_SC_XBS5_ILP32_OFF32","","",N,N],[17,"_SC_XBS5_ILP32_OFFBIG","","",N,N],[17,"_SC_XBS5_LP64_OFF64","","",N,N],[17,"_SC_XBS5_LPBIG_OFFBIG","","",N,N],[17,"_SC_XOPEN_LEGACY","","",N,N],[17,"_SC_XOPEN_REALTIME","","",N,N],[17,"_SC_XOPEN_REALTIME_THREADS","","",N,N],[17,"_SC_ADVISORY_INFO","","",N,N],[17,"_SC_BARRIERS","","",N,N],[17,"_SC_CLOCK_SELECTION","","",N,N],[17,"_SC_CPUTIME","","",N,N],[17,"_SC_THREAD_CPUTIME","","",N,N],[17,"_SC_MONOTONIC_CLOCK","","",N,N],[17,"_SC_READER_WRITER_LOCKS","","",N,N],[17,"_SC_SPIN_LOCKS","","",N,N],[17,"_SC_REGEXP","","",N,N],[17,"_SC_SHELL","","",N,N],[17,"_SC_SPAWN","","",N,N],[17,"_SC_SPORADIC_SERVER","","",N,N],[17,"_SC_THREAD_SPORADIC_SERVER","","",N,N],[17,"_SC_TIMEOUTS","","",N,N],[17,"_SC_TYPED_MEMORY_OBJECTS","","",N,N],[17,"_SC_2_PBS","","",N,N],[17,"_SC_2_PBS_ACCOUNTING","","",N,N],[17,"_SC_2_PBS_LOCATE","","",N,N],[17,"_SC_2_PBS_MESSAGE","","",N,N],[17,"_SC_2_PBS_TRACK","","",N,N],[17,"_SC_SYMLOOP_MAX","","",N,N],[17,"_SC_STREAMS","","",N,N],[17,"_SC_2_PBS_CHECKPOINT","","",N,N],[17,"_SC_V6_ILP32_OFF32","","",N,N],[17,"_SC_V6_ILP32_OFFBIG","","",N,N],[17,"_SC_V6_LP64_OFF64","","",N,N],[17,"_SC_V6_LPBIG_OFFBIG","","",N,N],[17,"_SC_HOST_NAME_MAX","","",N,N],[17,"_SC_TRACE","","",N,N],[17,"_SC_TRACE_EVENT_FILTER","","",N,N],[17,"_SC_TRACE_INHERIT","","",N,N],[17,"_SC_TRACE_LOG","","",N,N],[17,"_SC_IPV6","","",N,N],[17,"_SC_RAW_SOCKETS","","",N,N],[17,"_SC_V7_ILP32_OFF32","","",N,N],[17,"_SC_V7_ILP32_OFFBIG","","",N,N],[17,"_SC_V7_LP64_OFF64","","",N,N],[17,"_SC_V7_LPBIG_OFFBIG","","",N,N],[17,"_SC_SS_REPL_MAX","","",N,N],[17,"_SC_TRACE_EVENT_NAME_MAX","","",N,N],[17,"_SC_TRACE_NAME_MAX","","",N,N],[17,"_SC_TRACE_SYS_MAX","","",N,N],[17,"_SC_TRACE_USER_EVENT_MAX","","",N,N],[17,"_SC_XOPEN_STREAMS","","",N,N],[17,"_SC_THREAD_ROBUST_PRIO_INHERIT","","",N,N],[17,"_SC_THREAD_ROBUST_PRIO_PROTECT","","",N,N],[17,"RLIM_SAVED_MAX","","",N,N],[17,"RLIM_SAVED_CUR","","",N,N],[17,"GLOB_ERR","","",N,N],[17,"GLOB_MARK","","",N,N],[17,"GLOB_NOSORT","","",N,N],[17,"GLOB_DOOFFS","","",N,N],[17,"GLOB_NOCHECK","","",N,N],[17,"GLOB_APPEND","","",N,N],[17,"GLOB_NOESCAPE","","",N,N],[17,"GLOB_NOSPACE","","",N,N],[17,"GLOB_ABORTED","","",N,N],[17,"GLOB_NOMATCH","","",N,N],[17,"POSIX_MADV_NORMAL","","",N,N],[17,"POSIX_MADV_RANDOM","","",N,N],[17,"POSIX_MADV_SEQUENTIAL","","",N,N],[17,"POSIX_MADV_WILLNEED","","",N,N],[17,"S_IEXEC","","",N,N],[17,"S_IWRITE","","",N,N],[17,"S_IREAD","","",N,N],[17,"F_LOCK","","",N,N],[17,"F_TEST","","",N,N],[17,"F_TLOCK","","",N,N],[17,"F_ULOCK","","",N,N],[17,"IFF_LOWER_UP","","",N,N],[17,"IFF_DORMANT","","",N,N],[17,"IFF_ECHO","","",N,N],[17,"IFF_TUN","","",N,N],[17,"IFF_TAP","","",N,N],[17,"IFF_NO_PI","","",N,N],[17,"TUN_READQ_SIZE","","",N,N],[17,"TUN_TUN_DEV","","",N,N],[17,"TUN_TAP_DEV","","",N,N],[17,"TUN_TYPE_MASK","","",N,N],[17,"IFF_ONE_QUEUE","","",N,N],[17,"IFF_VNET_HDR","","",N,N],[17,"IFF_TUN_EXCL","","",N,N],[17,"IFF_MULTI_QUEUE","","",N,N],[17,"IFF_ATTACH_QUEUE","","",N,N],[17,"IFF_DETACH_QUEUE","","",N,N],[17,"IFF_PERSIST","","",N,N],[17,"IFF_NOFILTER","","",N,N],[17,"ST_RDONLY","","",N,N],[17,"ST_NOSUID","","",N,N],[17,"ST_NODEV","","",N,N],[17,"ST_NOEXEC","","",N,N],[17,"ST_SYNCHRONOUS","","",N,N],[17,"ST_MANDLOCK","","",N,N],[17,"ST_WRITE","","",N,N],[17,"ST_APPEND","","",N,N],[17,"ST_IMMUTABLE","","",N,N],[17,"ST_NOATIME","","",N,N],[17,"ST_NODIRATIME","","",N,N],[17,"RTLD_NEXT","","",N,N],[17,"RTLD_DEFAULT","","",N,N],[17,"RTLD_NODELETE","","",N,N],[17,"RTLD_NOW","","",N,N],[17,"TCP_MD5SIG","","",N,N],[17,"PTHREAD_MUTEX_INITIALIZER","","",N,N],[17,"PTHREAD_COND_INITIALIZER","","",N,N],[17,"PTHREAD_RWLOCK_INITIALIZER","","",N,N],[17,"PTHREAD_MUTEX_NORMAL","","",N,N],[17,"PTHREAD_MUTEX_RECURSIVE","","",N,N],[17,"PTHREAD_MUTEX_ERRORCHECK","","",N,N],[17,"PTHREAD_MUTEX_DEFAULT","","",N,N],[17,"PTHREAD_PROCESS_PRIVATE","","",N,N],[17,"PTHREAD_PROCESS_SHARED","","",N,N],[17,"__SIZEOF_PTHREAD_COND_T","","",N,N],[17,"RENAME_NOREPLACE","","",N,N],[17,"RENAME_EXCHANGE","","",N,N],[17,"RENAME_WHITEOUT","","",N,N],[17,"SCHED_OTHER","","",N,N],[17,"SCHED_FIFO","","",N,N],[17,"SCHED_RR","","",N,N],[17,"SCHED_BATCH","","",N,N],[17,"SCHED_IDLE","","",N,N],[17,"IPPROTO_HOPOPTS","","Hop-by-hop option header",N,N],[17,"IPPROTO_IGMP","","group mgmt protocol",N,N],[17,"IPPROTO_IPIP","","for compatibility",N,N],[17,"IPPROTO_EGP","","exterior gateway protocol",N,N],[17,"IPPROTO_PUP","","pup",N,N],[17,"IPPROTO_IDP","","xns idp",N,N],[17,"IPPROTO_TP","","tp-4 w/ class negotiation",N,N],[17,"IPPROTO_DCCP","","DCCP",N,N],[17,"IPPROTO_ROUTING","","IP6 routing header",N,N],[17,"IPPROTO_FRAGMENT","","IP6 fragmentation header",N,N],[17,"IPPROTO_RSVP","","resource reservation",N,N],[17,"IPPROTO_GRE","","General Routing Encap.",N,N],[17,"IPPROTO_ESP","","IP6 Encap Sec. Payload",N,N],[17,"IPPROTO_AH","","IP6 Auth Header",N,N],[17,"IPPROTO_NONE","","IP6 no next header",N,N],[17,"IPPROTO_DSTOPTS","","IP6 destination option",N,N],[17,"IPPROTO_MTP","","",N,N],[17,"IPPROTO_BEETPH","","",N,N],[17,"IPPROTO_ENCAP","","encapsulation header",N,N],[17,"IPPROTO_PIM","","Protocol indep. multicast",N,N],[17,"IPPROTO_COMP","","IP Payload Comp. Protocol",N,N],[17,"IPPROTO_SCTP","","SCTP",N,N],[17,"IPPROTO_MH","","",N,N],[17,"IPPROTO_UDPLITE","","",N,N],[17,"IPPROTO_MPLS","","",N,N],[17,"IPPROTO_RAW","","raw IP packet",N,N],[17,"IPPROTO_MAX","","",N,N],[17,"AF_IB","","",N,N],[17,"AF_MPLS","","",N,N],[17,"AF_NFC","","",N,N],[17,"AF_VSOCK","","",N,N],[17,"AF_XDP","","",N,N],[17,"PF_IB","","",N,N],[17,"PF_MPLS","","",N,N],[17,"PF_NFC","","",N,N],[17,"PF_VSOCK","","",N,N],[17,"PF_XDP","","",N,N],[17,"IPC_PRIVATE","","",N,N],[17,"IPC_CREAT","","",N,N],[17,"IPC_EXCL","","",N,N],[17,"IPC_NOWAIT","","",N,N],[17,"IPC_RMID","","",N,N],[17,"IPC_SET","","",N,N],[17,"IPC_STAT","","",N,N],[17,"IPC_INFO","","",N,N],[17,"MSG_STAT","","",N,N],[17,"MSG_INFO","","",N,N],[17,"MSG_NOERROR","","",N,N],[17,"MSG_EXCEPT","","",N,N],[17,"MSG_COPY","","",N,N],[17,"SHM_R","","",N,N],[17,"SHM_W","","",N,N],[17,"SHM_RDONLY","","",N,N],[17,"SHM_RND","","",N,N],[17,"SHM_REMAP","","",N,N],[17,"SHM_EXEC","","",N,N],[17,"SHM_LOCK","","",N,N],[17,"SHM_UNLOCK","","",N,N],[17,"SHM_HUGETLB","","",N,N],[17,"SHM_NORESERVE","","",N,N],[17,"EPOLLRDHUP","","",N,N],[17,"EPOLLEXCLUSIVE","","",N,N],[17,"EPOLLONESHOT","","",N,N],[17,"QFMT_VFS_OLD","","",N,N],[17,"QFMT_VFS_V0","","",N,N],[17,"QFMT_VFS_V1","","",N,N],[17,"EFD_SEMAPHORE","","",N,N],[17,"LOG_NFACILITIES","","",N,N],[17,"SEM_FAILED","","",N,N],[17,"RB_AUTOBOOT","","",N,N],[17,"RB_HALT_SYSTEM","","",N,N],[17,"RB_ENABLE_CAD","","",N,N],[17,"RB_DISABLE_CAD","","",N,N],[17,"RB_POWER_OFF","","",N,N],[17,"RB_SW_SUSPEND","","",N,N],[17,"RB_KEXEC","","",N,N],[17,"AI_PASSIVE","","",N,N],[17,"AI_CANONNAME","","",N,N],[17,"AI_NUMERICHOST","","",N,N],[17,"AI_V4MAPPED","","",N,N],[17,"AI_ALL","","",N,N],[17,"AI_ADDRCONFIG","","",N,N],[17,"AI_NUMERICSERV","","",N,N],[17,"EAI_BADFLAGS","","",N,N],[17,"EAI_NONAME","","",N,N],[17,"EAI_AGAIN","","",N,N],[17,"EAI_FAIL","","",N,N],[17,"EAI_NODATA","","",N,N],[17,"EAI_FAMILY","","",N,N],[17,"EAI_SOCKTYPE","","",N,N],[17,"EAI_SERVICE","","",N,N],[17,"EAI_MEMORY","","",N,N],[17,"EAI_SYSTEM","","",N,N],[17,"EAI_OVERFLOW","","",N,N],[17,"NI_NUMERICHOST","","",N,N],[17,"NI_NUMERICSERV","","",N,N],[17,"NI_NOFQDN","","",N,N],[17,"NI_NAMEREQD","","",N,N],[17,"NI_DGRAM","","",N,N],[17,"SYNC_FILE_RANGE_WAIT_BEFORE","","",N,N],[17,"SYNC_FILE_RANGE_WRITE","","",N,N],[17,"SYNC_FILE_RANGE_WAIT_AFTER","","",N,N],[17,"AIO_CANCELED","","",N,N],[17,"AIO_NOTCANCELED","","",N,N],[17,"AIO_ALLDONE","","",N,N],[17,"LIO_READ","","",N,N],[17,"LIO_WRITE","","",N,N],[17,"LIO_NOP","","",N,N],[17,"LIO_WAIT","","",N,N],[17,"LIO_NOWAIT","","",N,N],[17,"MREMAP_MAYMOVE","","",N,N],[17,"MREMAP_FIXED","","",N,N],[17,"PR_SET_PDEATHSIG","","",N,N],[17,"PR_GET_PDEATHSIG","","",N,N],[17,"PR_GET_DUMPABLE","","",N,N],[17,"PR_SET_DUMPABLE","","",N,N],[17,"PR_GET_UNALIGN","","",N,N],[17,"PR_SET_UNALIGN","","",N,N],[17,"PR_UNALIGN_NOPRINT","","",N,N],[17,"PR_UNALIGN_SIGBUS","","",N,N],[17,"PR_GET_KEEPCAPS","","",N,N],[17,"PR_SET_KEEPCAPS","","",N,N],[17,"PR_GET_FPEMU","","",N,N],[17,"PR_SET_FPEMU","","",N,N],[17,"PR_FPEMU_NOPRINT","","",N,N],[17,"PR_FPEMU_SIGFPE","","",N,N],[17,"PR_GET_FPEXC","","",N,N],[17,"PR_SET_FPEXC","","",N,N],[17,"PR_FP_EXC_SW_ENABLE","","",N,N],[17,"PR_FP_EXC_DIV","","",N,N],[17,"PR_FP_EXC_OVF","","",N,N],[17,"PR_FP_EXC_UND","","",N,N],[17,"PR_FP_EXC_RES","","",N,N],[17,"PR_FP_EXC_INV","","",N,N],[17,"PR_FP_EXC_DISABLED","","",N,N],[17,"PR_FP_EXC_NONRECOV","","",N,N],[17,"PR_FP_EXC_ASYNC","","",N,N],[17,"PR_FP_EXC_PRECISE","","",N,N],[17,"PR_GET_TIMING","","",N,N],[17,"PR_SET_TIMING","","",N,N],[17,"PR_TIMING_STATISTICAL","","",N,N],[17,"PR_TIMING_TIMESTAMP","","",N,N],[17,"PR_SET_NAME","","",N,N],[17,"PR_GET_NAME","","",N,N],[17,"PR_GET_ENDIAN","","",N,N],[17,"PR_SET_ENDIAN","","",N,N],[17,"PR_ENDIAN_BIG","","",N,N],[17,"PR_ENDIAN_LITTLE","","",N,N],[17,"PR_ENDIAN_PPC_LITTLE","","",N,N],[17,"PR_GET_SECCOMP","","",N,N],[17,"PR_SET_SECCOMP","","",N,N],[17,"PR_CAPBSET_READ","","",N,N],[17,"PR_CAPBSET_DROP","","",N,N],[17,"PR_GET_TSC","","",N,N],[17,"PR_SET_TSC","","",N,N],[17,"PR_TSC_ENABLE","","",N,N],[17,"PR_TSC_SIGSEGV","","",N,N],[17,"PR_GET_SECUREBITS","","",N,N],[17,"PR_SET_SECUREBITS","","",N,N],[17,"PR_SET_TIMERSLACK","","",N,N],[17,"PR_GET_TIMERSLACK","","",N,N],[17,"PR_TASK_PERF_EVENTS_DISABLE","","",N,N],[17,"PR_TASK_PERF_EVENTS_ENABLE","","",N,N],[17,"PR_MCE_KILL","","",N,N],[17,"PR_MCE_KILL_CLEAR","","",N,N],[17,"PR_MCE_KILL_SET","","",N,N],[17,"PR_MCE_KILL_LATE","","",N,N],[17,"PR_MCE_KILL_EARLY","","",N,N],[17,"PR_MCE_KILL_DEFAULT","","",N,N],[17,"PR_MCE_KILL_GET","","",N,N],[17,"PR_SET_MM","","",N,N],[17,"PR_SET_MM_START_CODE","","",N,N],[17,"PR_SET_MM_END_CODE","","",N,N],[17,"PR_SET_MM_START_DATA","","",N,N],[17,"PR_SET_MM_END_DATA","","",N,N],[17,"PR_SET_MM_START_STACK","","",N,N],[17,"PR_SET_MM_START_BRK","","",N,N],[17,"PR_SET_MM_BRK","","",N,N],[17,"PR_SET_MM_ARG_START","","",N,N],[17,"PR_SET_MM_ARG_END","","",N,N],[17,"PR_SET_MM_ENV_START","","",N,N],[17,"PR_SET_MM_ENV_END","","",N,N],[17,"PR_SET_MM_AUXV","","",N,N],[17,"PR_SET_MM_EXE_FILE","","",N,N],[17,"PR_SET_MM_MAP","","",N,N],[17,"PR_SET_MM_MAP_SIZE","","",N,N],[17,"PR_SET_PTRACER","","",N,N],[17,"PR_SET_CHILD_SUBREAPER","","",N,N],[17,"PR_GET_CHILD_SUBREAPER","","",N,N],[17,"PR_SET_NO_NEW_PRIVS","","",N,N],[17,"PR_GET_NO_NEW_PRIVS","","",N,N],[17,"PR_GET_TID_ADDRESS","","",N,N],[17,"PR_SET_THP_DISABLE","","",N,N],[17,"PR_GET_THP_DISABLE","","",N,N],[17,"PR_MPX_ENABLE_MANAGEMENT","","",N,N],[17,"PR_MPX_DISABLE_MANAGEMENT","","",N,N],[17,"PR_SET_FP_MODE","","",N,N],[17,"PR_GET_FP_MODE","","",N,N],[17,"PR_FP_MODE_FR","","",N,N],[17,"PR_FP_MODE_FRE","","",N,N],[17,"PR_CAP_AMBIENT","","",N,N],[17,"PR_CAP_AMBIENT_IS_SET","","",N,N],[17,"PR_CAP_AMBIENT_RAISE","","",N,N],[17,"PR_CAP_AMBIENT_LOWER","","",N,N],[17,"PR_CAP_AMBIENT_CLEAR_ALL","","",N,N],[17,"GRND_NONBLOCK","","",N,N],[17,"GRND_RANDOM","","",N,N],[17,"SECCOMP_MODE_DISABLED","","",N,N],[17,"SECCOMP_MODE_STRICT","","",N,N],[17,"SECCOMP_MODE_FILTER","","",N,N],[17,"ITIMER_REAL","","",N,N],[17,"ITIMER_VIRTUAL","","",N,N],[17,"ITIMER_PROF","","",N,N],[17,"TFD_CLOEXEC","","",N,N],[17,"TFD_NONBLOCK","","",N,N],[17,"TFD_TIMER_ABSTIME","","",N,N],[17,"XATTR_CREATE","","",N,N],[17,"XATTR_REPLACE","","",N,N],[17,"_POSIX_VDISABLE","","",N,N],[17,"FALLOC_FL_KEEP_SIZE","","",N,N],[17,"FALLOC_FL_PUNCH_HOLE","","",N,N],[17,"FALLOC_FL_COLLAPSE_RANGE","","",N,N],[17,"FALLOC_FL_ZERO_RANGE","","",N,N],[17,"FALLOC_FL_INSERT_RANGE","","",N,N],[17,"FALLOC_FL_UNSHARE_RANGE","","",N,N],[17,"ENOATTR","","",N,N],[17,"SO_ORIGINAL_DST","","",N,N],[17,"IP_ORIGDSTADDR","","",N,N],[17,"IP_RECVORIGDSTADDR","","",N,N],[17,"IPV6_ORIGDSTADDR","","",N,N],[17,"IPV6_RECVORIGDSTADDR","","",N,N],[17,"IUTF8","","",N,N],[17,"CMSPAR","","",N,N],[17,"MFD_CLOEXEC","","",N,N],[17,"MFD_ALLOW_SEALING","","",N,N],[17,"MFD_HUGETLB","","",N,N],[17,"PT_NULL","","",N,N],[17,"PT_LOAD","","",N,N],[17,"PT_DYNAMIC","","",N,N],[17,"PT_INTERP","","",N,N],[17,"PT_NOTE","","",N,N],[17,"PT_SHLIB","","",N,N],[17,"PT_PHDR","","",N,N],[17,"PT_TLS","","",N,N],[17,"PT_NUM","","",N,N],[17,"PT_LOOS","","",N,N],[17,"PT_GNU_EH_FRAME","","",N,N],[17,"PT_GNU_STACK","","",N,N],[17,"PT_GNU_RELRO","","",N,N],[17,"ETH_ALEN","","",N,N],[17,"ETH_HLEN","","",N,N],[17,"ETH_ZLEN","","",N,N],[17,"ETH_DATA_LEN","","",N,N],[17,"ETH_FRAME_LEN","","",N,N],[17,"ETH_FCS_LEN","","",N,N],[17,"ETH_P_LOOP","","",N,N],[17,"ETH_P_PUP","","",N,N],[17,"ETH_P_PUPAT","","",N,N],[17,"ETH_P_IP","","",N,N],[17,"ETH_P_X25","","",N,N],[17,"ETH_P_ARP","","",N,N],[17,"ETH_P_BPQ","","",N,N],[17,"ETH_P_IEEEPUP","","",N,N],[17,"ETH_P_IEEEPUPAT","","",N,N],[17,"ETH_P_BATMAN","","",N,N],[17,"ETH_P_DEC","","",N,N],[17,"ETH_P_DNA_DL","","",N,N],[17,"ETH_P_DNA_RC","","",N,N],[17,"ETH_P_DNA_RT","","",N,N],[17,"ETH_P_LAT","","",N,N],[17,"ETH_P_DIAG","","",N,N],[17,"ETH_P_CUST","","",N,N],[17,"ETH_P_SCA","","",N,N],[17,"ETH_P_TEB","","",N,N],[17,"ETH_P_RARP","","",N,N],[17,"ETH_P_ATALK","","",N,N],[17,"ETH_P_AARP","","",N,N],[17,"ETH_P_8021Q","","",N,N],[17,"ETH_P_IPX","","",N,N],[17,"ETH_P_IPV6","","",N,N],[17,"ETH_P_PAUSE","","",N,N],[17,"ETH_P_SLOW","","",N,N],[17,"ETH_P_WCCP","","",N,N],[17,"ETH_P_MPLS_UC","","",N,N],[17,"ETH_P_MPLS_MC","","",N,N],[17,"ETH_P_ATMMPOA","","",N,N],[17,"ETH_P_PPP_DISC","","",N,N],[17,"ETH_P_PPP_SES","","",N,N],[17,"ETH_P_LINK_CTL","","",N,N],[17,"ETH_P_ATMFATE","","",N,N],[17,"ETH_P_PAE","","",N,N],[17,"ETH_P_AOE","","",N,N],[17,"ETH_P_8021AD","","",N,N],[17,"ETH_P_802_EX1","","",N,N],[17,"ETH_P_TIPC","","",N,N],[17,"ETH_P_MACSEC","","",N,N],[17,"ETH_P_8021AH","","",N,N],[17,"ETH_P_MVRP","","",N,N],[17,"ETH_P_1588","","",N,N],[17,"ETH_P_PRP","","",N,N],[17,"ETH_P_FCOE","","",N,N],[17,"ETH_P_TDLS","","",N,N],[17,"ETH_P_FIP","","",N,N],[17,"ETH_P_80221","","",N,N],[17,"ETH_P_LOOPBACK","","",N,N],[17,"ETH_P_QINQ1","","",N,N],[17,"ETH_P_QINQ2","","",N,N],[17,"ETH_P_QINQ3","","",N,N],[17,"ETH_P_EDSA","","",N,N],[17,"ETH_P_AF_IUCV","","",N,N],[17,"ETH_P_802_3_MIN","","",N,N],[17,"ETH_P_802_3","","",N,N],[17,"ETH_P_AX25","","",N,N],[17,"ETH_P_ALL","","",N,N],[17,"ETH_P_802_2","","",N,N],[17,"ETH_P_SNAP","","",N,N],[17,"ETH_P_DDCMP","","",N,N],[17,"ETH_P_WAN_PPP","","",N,N],[17,"ETH_P_PPP_MP","","",N,N],[17,"ETH_P_LOCALTALK","","",N,N],[17,"ETH_P_CANFD","","",N,N],[17,"ETH_P_PPPTALK","","",N,N],[17,"ETH_P_TR_802_2","","",N,N],[17,"ETH_P_MOBITEX","","",N,N],[17,"ETH_P_CONTROL","","",N,N],[17,"ETH_P_IRDA","","",N,N],[17,"ETH_P_ECONET","","",N,N],[17,"ETH_P_HDLC","","",N,N],[17,"ETH_P_ARCNET","","",N,N],[17,"ETH_P_DSA","","",N,N],[17,"ETH_P_TRAILER","","",N,N],[17,"ETH_P_PHONET","","",N,N],[17,"ETH_P_IEEE802154","","",N,N],[17,"ETH_P_CAIF","","",N,N],[17,"POSIX_SPAWN_RESETIDS","","",N,N],[17,"POSIX_SPAWN_SETPGROUP","","",N,N],[17,"POSIX_SPAWN_SETSIGDEF","","",N,N],[17,"POSIX_SPAWN_SETSIGMASK","","",N,N],[17,"POSIX_SPAWN_SETSCHEDPARAM","","",N,N],[17,"POSIX_SPAWN_SETSCHEDULER","","",N,N],[17,"NLMSG_NOOP","","",N,N],[17,"NLMSG_ERROR","","",N,N],[17,"NLMSG_DONE","","",N,N],[17,"NLMSG_OVERRUN","","",N,N],[17,"NLMSG_MIN_TYPE","","",N,N],[17,"GENL_NAMSIZ","","",N,N],[17,"GENL_MIN_ID","","",N,N],[17,"GENL_MAX_ID","","",N,N],[17,"GENL_ADMIN_PERM","","",N,N],[17,"GENL_CMD_CAP_DO","","",N,N],[17,"GENL_CMD_CAP_DUMP","","",N,N],[17,"GENL_CMD_CAP_HASPOL","","",N,N],[17,"GENL_ID_CTRL","","",N,N],[17,"CTRL_CMD_UNSPEC","","",N,N],[17,"CTRL_CMD_NEWFAMILY","","",N,N],[17,"CTRL_CMD_DELFAMILY","","",N,N],[17,"CTRL_CMD_GETFAMILY","","",N,N],[17,"CTRL_CMD_NEWOPS","","",N,N],[17,"CTRL_CMD_DELOPS","","",N,N],[17,"CTRL_CMD_GETOPS","","",N,N],[17,"CTRL_CMD_NEWMCAST_GRP","","",N,N],[17,"CTRL_CMD_DELMCAST_GRP","","",N,N],[17,"CTRL_CMD_GETMCAST_GRP","","",N,N],[17,"CTRL_ATTR_UNSPEC","","",N,N],[17,"CTRL_ATTR_FAMILY_ID","","",N,N],[17,"CTRL_ATTR_FAMILY_NAME","","",N,N],[17,"CTRL_ATTR_VERSION","","",N,N],[17,"CTRL_ATTR_HDRSIZE","","",N,N],[17,"CTRL_ATTR_MAXATTR","","",N,N],[17,"CTRL_ATTR_OPS","","",N,N],[17,"CTRL_ATTR_MCAST_GROUPS","","",N,N],[17,"CTRL_ATTR_OP_UNSPEC","","",N,N],[17,"CTRL_ATTR_OP_ID","","",N,N],[17,"CTRL_ATTR_OP_FLAGS","","",N,N],[17,"CTRL_ATTR_MCAST_GRP_UNSPEC","","",N,N],[17,"CTRL_ATTR_MCAST_GRP_NAME","","",N,N],[17,"CTRL_ATTR_MCAST_GRP_ID","","",N,N],[17,"PACKET_ADD_MEMBERSHIP","","",N,N],[17,"PACKET_DROP_MEMBERSHIP","","",N,N],[17,"PACKET_MR_MULTICAST","","",N,N],[17,"PACKET_MR_PROMISC","","",N,N],[17,"PACKET_MR_ALLMULTI","","",N,N],[17,"PACKET_MR_UNICAST","","",N,N],[17,"NF_DROP","","",N,N],[17,"NF_ACCEPT","","",N,N],[17,"NF_STOLEN","","",N,N],[17,"NF_QUEUE","","",N,N],[17,"NF_REPEAT","","",N,N],[17,"NF_STOP","","",N,N],[17,"NF_MAX_VERDICT","","",N,N],[17,"NF_VERDICT_MASK","","",N,N],[17,"NF_VERDICT_FLAG_QUEUE_BYPASS","","",N,N],[17,"NF_VERDICT_QMASK","","",N,N],[17,"NF_VERDICT_QBITS","","",N,N],[17,"NF_VERDICT_BITS","","",N,N],[17,"NF_INET_PRE_ROUTING","","",N,N],[17,"NF_INET_LOCAL_IN","","",N,N],[17,"NF_INET_FORWARD","","",N,N],[17,"NF_INET_LOCAL_OUT","","",N,N],[17,"NF_INET_POST_ROUTING","","",N,N],[17,"NF_INET_NUMHOOKS","","",N,N],[17,"NFPROTO_UNSPEC","","",N,N],[17,"NFPROTO_IPV4","","",N,N],[17,"NFPROTO_ARP","","",N,N],[17,"NFPROTO_BRIDGE","","",N,N],[17,"NFPROTO_IPV6","","",N,N],[17,"NFPROTO_DECNET","","",N,N],[17,"NFPROTO_NUMPROTO","","",N,N],[17,"NF_IP_PRE_ROUTING","","",N,N],[17,"NF_IP_LOCAL_IN","","",N,N],[17,"NF_IP_FORWARD","","",N,N],[17,"NF_IP_LOCAL_OUT","","",N,N],[17,"NF_IP_POST_ROUTING","","",N,N],[17,"NF_IP_NUMHOOKS","","",N,N],[17,"NF_IP_PRI_FIRST","","",N,N],[17,"NF_IP_PRI_CONNTRACK_DEFRAG","","",N,N],[17,"NF_IP_PRI_RAW","","",N,N],[17,"NF_IP_PRI_SELINUX_FIRST","","",N,N],[17,"NF_IP_PRI_CONNTRACK","","",N,N],[17,"NF_IP_PRI_MANGLE","","",N,N],[17,"NF_IP_PRI_NAT_DST","","",N,N],[17,"NF_IP_PRI_FILTER","","",N,N],[17,"NF_IP_PRI_SECURITY","","",N,N],[17,"NF_IP_PRI_NAT_SRC","","",N,N],[17,"NF_IP_PRI_SELINUX_LAST","","",N,N],[17,"NF_IP_PRI_CONNTRACK_HELPER","","",N,N],[17,"NF_IP_PRI_CONNTRACK_CONFIRM","","",N,N],[17,"NF_IP_PRI_LAST","","",N,N],[17,"NF_IP6_PRE_ROUTING","","",N,N],[17,"NF_IP6_LOCAL_IN","","",N,N],[17,"NF_IP6_FORWARD","","",N,N],[17,"NF_IP6_LOCAL_OUT","","",N,N],[17,"NF_IP6_POST_ROUTING","","",N,N],[17,"NF_IP6_NUMHOOKS","","",N,N],[17,"NF_IP6_PRI_FIRST","","",N,N],[17,"NF_IP6_PRI_CONNTRACK_DEFRAG","","",N,N],[17,"NF_IP6_PRI_RAW","","",N,N],[17,"NF_IP6_PRI_SELINUX_FIRST","","",N,N],[17,"NF_IP6_PRI_CONNTRACK","","",N,N],[17,"NF_IP6_PRI_MANGLE","","",N,N],[17,"NF_IP6_PRI_NAT_DST","","",N,N],[17,"NF_IP6_PRI_FILTER","","",N,N],[17,"NF_IP6_PRI_SECURITY","","",N,N],[17,"NF_IP6_PRI_NAT_SRC","","",N,N],[17,"NF_IP6_PRI_SELINUX_LAST","","",N,N],[17,"NF_IP6_PRI_CONNTRACK_HELPER","","",N,N],[17,"NF_IP6_PRI_LAST","","",N,N],[17,"SIOCADDRT","","",N,N],[17,"SIOCDELRT","","",N,N],[17,"SIOCGIFNAME","","",N,N],[17,"SIOCSIFLINK","","",N,N],[17,"SIOCGIFCONF","","",N,N],[17,"SIOCGIFFLAGS","","",N,N],[17,"SIOCSIFFLAGS","","",N,N],[17,"SIOCGIFADDR","","",N,N],[17,"SIOCSIFADDR","","",N,N],[17,"SIOCGIFDSTADDR","","",N,N],[17,"SIOCSIFDSTADDR","","",N,N],[17,"SIOCGIFBRDADDR","","",N,N],[17,"SIOCSIFBRDADDR","","",N,N],[17,"SIOCGIFNETMASK","","",N,N],[17,"SIOCSIFNETMASK","","",N,N],[17,"SIOCGIFMETRIC","","",N,N],[17,"SIOCSIFMETRIC","","",N,N],[17,"SIOCGIFMEM","","",N,N],[17,"SIOCSIFMEM","","",N,N],[17,"SIOCGIFMTU","","",N,N],[17,"SIOCSIFMTU","","",N,N],[17,"SIOCSIFHWADDR","","",N,N],[17,"SIOCGIFENCAP","","",N,N],[17,"SIOCSIFENCAP","","",N,N],[17,"SIOCGIFHWADDR","","",N,N],[17,"SIOCGIFSLAVE","","",N,N],[17,"SIOCSIFSLAVE","","",N,N],[17,"SIOCADDMULTI","","",N,N],[17,"SIOCDELMULTI","","",N,N],[17,"SIOCDARP","","",N,N],[17,"SIOCGARP","","",N,N],[17,"SIOCSARP","","",N,N],[17,"SIOCDRARP","","",N,N],[17,"SIOCGRARP","","",N,N],[17,"SIOCSRARP","","",N,N],[17,"SIOCGIFMAP","","",N,N],[17,"SIOCSIFMAP","","",N,N],[17,"IPTOS_TOS_MASK","","",N,N],[17,"IPTOS_PREC_MASK","","",N,N],[17,"IPTOS_ECN_NOT_ECT","","",N,N],[17,"RTF_UP","","",N,N],[17,"RTF_GATEWAY","","",N,N],[17,"RTF_HOST","","",N,N],[17,"RTF_REINSTATE","","",N,N],[17,"RTF_DYNAMIC","","",N,N],[17,"RTF_MODIFIED","","",N,N],[17,"RTF_MTU","","",N,N],[17,"RTF_MSS","","",N,N],[17,"RTF_WINDOW","","",N,N],[17,"RTF_IRTT","","",N,N],[17,"RTF_REJECT","","",N,N],[17,"RTF_STATIC","","",N,N],[17,"RTF_XRESOLVE","","",N,N],[17,"RTF_NOFORWARD","","",N,N],[17,"RTF_THROW","","",N,N],[17,"RTF_NOPMTUDISC","","",N,N],[17,"RTF_DEFAULT","","",N,N],[17,"RTF_ALLONLINK","","",N,N],[17,"RTF_ADDRCONF","","",N,N],[17,"RTF_LINKRT","","",N,N],[17,"RTF_NONEXTHOP","","",N,N],[17,"RTF_CACHE","","",N,N],[17,"RTF_FLOW","","",N,N],[17,"RTF_POLICY","","",N,N],[17,"RTCF_VALVE","","",N,N],[17,"RTCF_MASQ","","",N,N],[17,"RTCF_NAT","","",N,N],[17,"RTCF_DOREDIRECT","","",N,N],[17,"RTCF_LOG","","",N,N],[17,"RTCF_DIRECTSRC","","",N,N],[17,"RTF_LOCAL","","",N,N],[17,"RTF_INTERFACE","","",N,N],[17,"RTF_MULTICAST","","",N,N],[17,"RTF_BROADCAST","","",N,N],[17,"RTF_NAT","","",N,N],[17,"RTF_ADDRCLASSMASK","","",N,N],[17,"RT_CLASS_UNSPEC","","",N,N],[17,"RT_CLASS_DEFAULT","","",N,N],[17,"RT_CLASS_MAIN","","",N,N],[17,"RT_CLASS_LOCAL","","",N,N],[17,"RT_CLASS_MAX","","",N,N],[17,"RTMSG_OVERRUN","","",N,N],[17,"RTMSG_NEWDEVICE","","",N,N],[17,"RTMSG_DELDEVICE","","",N,N],[17,"RTMSG_NEWROUTE","","",N,N],[17,"RTMSG_DELROUTE","","",N,N],[17,"RTMSG_NEWRULE","","",N,N],[17,"RTMSG_DELRULE","","",N,N],[17,"RTMSG_CONTROL","","",N,N],[17,"RTMSG_AR_FAILED","","",N,N],[17,"MAX_ADDR_LEN","","",N,N],[17,"ARPD_UPDATE","","",N,N],[17,"ARPD_LOOKUP","","",N,N],[17,"ARPD_FLUSH","","",N,N],[17,"ATF_MAGIC","","",N,N],[17,"SO_TIMESTAMPING","","",N,N],[17,"SCM_TIMESTAMPING","","",N,N],[17,"MODULE_INIT_IGNORE_MODVERSIONS","","",N,N],[17,"MODULE_INIT_IGNORE_VERMAGIC","","",N,N],[17,"SOF_TIMESTAMPING_TX_HARDWARE","","",N,N],[17,"SOF_TIMESTAMPING_TX_SOFTWARE","","",N,N],[17,"SOF_TIMESTAMPING_RX_HARDWARE","","",N,N],[17,"SOF_TIMESTAMPING_RX_SOFTWARE","","",N,N],[17,"SOF_TIMESTAMPING_SOFTWARE","","",N,N],[17,"SOF_TIMESTAMPING_SYS_HARDWARE","","",N,N],[17,"SOF_TIMESTAMPING_RAW_HARDWARE","","",N,N],[17,"ALG_SET_KEY","","",N,N],[17,"ALG_SET_IV","","",N,N],[17,"ALG_SET_OP","","",N,N],[17,"ALG_SET_AEAD_ASSOCLEN","","",N,N],[17,"ALG_SET_AEAD_AUTHSIZE","","",N,N],[17,"ALG_OP_DECRYPT","","",N,N],[17,"ALG_OP_ENCRYPT","","",N,N],[17,"__UT_LINESIZE","","",N,N],[17,"__UT_NAMESIZE","","",N,N],[17,"__UT_HOSTSIZE","","",N,N],[17,"EMPTY","","",N,N],[17,"RUN_LVL","","",N,N],[17,"BOOT_TIME","","",N,N],[17,"NEW_TIME","","",N,N],[17,"OLD_TIME","","",N,N],[17,"INIT_PROCESS","","",N,N],[17,"LOGIN_PROCESS","","",N,N],[17,"USER_PROCESS","","",N,N],[17,"DEAD_PROCESS","","",N,N],[17,"ACCOUNTING","","",N,N],[17,"RLIMIT_RSS","","",N,N],[17,"RLIMIT_AS","","",N,N],[17,"RLIMIT_MEMLOCK","","",N,N],[17,"RLIM_INFINITY","","",N,N],[17,"RLIMIT_RTTIME","","",N,N],[17,"RLIMIT_NLIMITS","","",N,N],[17,"SOCK_NONBLOCK","","",N,N],[17,"SOL_RXRPC","","",N,N],[17,"SOL_PPPOL2TP","","",N,N],[17,"SOL_PNPIPE","","",N,N],[17,"SOL_RDS","","",N,N],[17,"SOL_IUCV","","",N,N],[17,"SOL_CAIF","","",N,N],[17,"SOL_NFC","","",N,N],[17,"SOL_XDP","","",N,N],[17,"MSG_TRYHARD","","",N,N],[17,"LC_PAPER","","",N,N],[17,"LC_NAME","","",N,N],[17,"LC_ADDRESS","","",N,N],[17,"LC_TELEPHONE","","",N,N],[17,"LC_MEASUREMENT","","",N,N],[17,"LC_IDENTIFICATION","","",N,N],[17,"LC_PAPER_MASK","","",N,N],[17,"LC_NAME_MASK","","",N,N],[17,"LC_ADDRESS_MASK","","",N,N],[17,"LC_TELEPHONE_MASK","","",N,N],[17,"LC_MEASUREMENT_MASK","","",N,N],[17,"LC_IDENTIFICATION_MASK","","",N,N],[17,"LC_ALL_MASK","","",N,N],[17,"MAP_ANON","","",N,N],[17,"MAP_ANONYMOUS","","",N,N],[17,"MAP_DENYWRITE","","",N,N],[17,"MAP_EXECUTABLE","","",N,N],[17,"MAP_POPULATE","","",N,N],[17,"MAP_NONBLOCK","","",N,N],[17,"MAP_STACK","","",N,N],[17,"ENOTSUP","","",N,N],[17,"EUCLEAN","","",N,N],[17,"ENOTNAM","","",N,N],[17,"ENAVAIL","","",N,N],[17,"EISNAM","","",N,N],[17,"EREMOTEIO","","",N,N],[17,"SOCK_STREAM","","",N,N],[17,"SOCK_DGRAM","","",N,N],[17,"SOCK_SEQPACKET","","",N,N],[17,"SOCK_DCCP","","",N,N],[17,"SOCK_PACKET","","",N,N],[17,"TCP_COOKIE_TRANSACTIONS","","",N,N],[17,"TCP_THIN_LINEAR_TIMEOUTS","","",N,N],[17,"TCP_THIN_DUPACK","","",N,N],[17,"TCP_USER_TIMEOUT","","",N,N],[17,"TCP_REPAIR","","",N,N],[17,"TCP_REPAIR_QUEUE","","",N,N],[17,"TCP_QUEUE_SEQ","","",N,N],[17,"TCP_REPAIR_OPTIONS","","",N,N],[17,"TCP_FASTOPEN","","",N,N],[17,"TCP_TIMESTAMP","","",N,N],[17,"DCCP_SOCKOPT_PACKET_SIZE","","",N,N],[17,"DCCP_SOCKOPT_SERVICE","","",N,N],[17,"DCCP_SOCKOPT_CHANGE_L","","",N,N],[17,"DCCP_SOCKOPT_CHANGE_R","","",N,N],[17,"DCCP_SOCKOPT_GET_CUR_MPS","","",N,N],[17,"DCCP_SOCKOPT_SERVER_TIMEWAIT","","",N,N],[17,"DCCP_SOCKOPT_SEND_CSCOV","","",N,N],[17,"DCCP_SOCKOPT_RECV_CSCOV","","",N,N],[17,"DCCP_SOCKOPT_AVAILABLE_CCIDS","","",N,N],[17,"DCCP_SOCKOPT_CCID","","",N,N],[17,"DCCP_SOCKOPT_TX_CCID","","",N,N],[17,"DCCP_SOCKOPT_RX_CCID","","",N,N],[17,"DCCP_SOCKOPT_QPOLICY_ID","","",N,N],[17,"DCCP_SOCKOPT_QPOLICY_TXQLEN","","",N,N],[17,"DCCP_SOCKOPT_CCID_RX_INFO","","",N,N],[17,"DCCP_SOCKOPT_CCID_TX_INFO","","",N,N],[17,"DCCP_SERVICE_LIST_MAX_LEN","","maximum number of services provided on the same listening port",N,N],[17,"SIGTTIN","","",N,N],[17,"SIGTTOU","","",N,N],[17,"SIGXCPU","","",N,N],[17,"SIGXFSZ","","",N,N],[17,"SIGVTALRM","","",N,N],[17,"SIGPROF","","",N,N],[17,"SIGWINCH","","",N,N],[17,"SIGEV_THREAD_ID","","",N,N],[17,"BUFSIZ","","",N,N],[17,"TMP_MAX","","",N,N],[17,"FOPEN_MAX","","",N,N],[17,"POSIX_FADV_DONTNEED","","",N,N],[17,"POSIX_FADV_NOREUSE","","",N,N],[17,"POSIX_MADV_DONTNEED","","",N,N],[17,"_SC_EQUIV_CLASS_MAX","","",N,N],[17,"_SC_CHARCLASS_NAME_MAX","","",N,N],[17,"_SC_PII","","",N,N],[17,"_SC_PII_XTI","","",N,N],[17,"_SC_PII_SOCKET","","",N,N],[17,"_SC_PII_INTERNET","","",N,N],[17,"_SC_PII_OSI","","",N,N],[17,"_SC_POLL","","",N,N],[17,"_SC_SELECT","","",N,N],[17,"_SC_PII_INTERNET_STREAM","","",N,N],[17,"_SC_PII_INTERNET_DGRAM","","",N,N],[17,"_SC_PII_OSI_COTS","","",N,N],[17,"_SC_PII_OSI_CLTS","","",N,N],[17,"_SC_PII_OSI_M","","",N,N],[17,"_SC_T_IOV_MAX","","",N,N],[17,"_SC_2_C_VERSION","","",N,N],[17,"_SC_CHAR_BIT","","",N,N],[17,"_SC_CHAR_MAX","","",N,N],[17,"_SC_CHAR_MIN","","",N,N],[17,"_SC_INT_MAX","","",N,N],[17,"_SC_INT_MIN","","",N,N],[17,"_SC_LONG_BIT","","",N,N],[17,"_SC_WORD_BIT","","",N,N],[17,"_SC_MB_LEN_MAX","","",N,N],[17,"_SC_SSIZE_MAX","","",N,N],[17,"_SC_SCHAR_MAX","","",N,N],[17,"_SC_SCHAR_MIN","","",N,N],[17,"_SC_SHRT_MAX","","",N,N],[17,"_SC_SHRT_MIN","","",N,N],[17,"_SC_UCHAR_MAX","","",N,N],[17,"_SC_UINT_MAX","","",N,N],[17,"_SC_ULONG_MAX","","",N,N],[17,"_SC_USHRT_MAX","","",N,N],[17,"_SC_NL_ARGMAX","","",N,N],[17,"_SC_NL_LANGMAX","","",N,N],[17,"_SC_NL_MSGMAX","","",N,N],[17,"_SC_NL_NMAX","","",N,N],[17,"_SC_NL_SETMAX","","",N,N],[17,"_SC_NL_TEXTMAX","","",N,N],[17,"_SC_BASE","","",N,N],[17,"_SC_C_LANG_SUPPORT","","",N,N],[17,"_SC_C_LANG_SUPPORT_R","","",N,N],[17,"_SC_DEVICE_IO","","",N,N],[17,"_SC_DEVICE_SPECIFIC","","",N,N],[17,"_SC_DEVICE_SPECIFIC_R","","",N,N],[17,"_SC_FD_MGMT","","",N,N],[17,"_SC_FIFO","","",N,N],[17,"_SC_PIPE","","",N,N],[17,"_SC_FILE_ATTRIBUTES","","",N,N],[17,"_SC_FILE_LOCKING","","",N,N],[17,"_SC_FILE_SYSTEM","","",N,N],[17,"_SC_MULTI_PROCESS","","",N,N],[17,"_SC_SINGLE_PROCESS","","",N,N],[17,"_SC_NETWORKING","","",N,N],[17,"_SC_REGEX_VERSION","","",N,N],[17,"_SC_SIGNALS","","",N,N],[17,"_SC_SYSTEM_DATABASE","","",N,N],[17,"_SC_SYSTEM_DATABASE_R","","",N,N],[17,"_SC_USER_GROUPS","","",N,N],[17,"_SC_USER_GROUPS_R","","",N,N],[17,"_SC_LEVEL1_ICACHE_SIZE","","",N,N],[17,"_SC_LEVEL1_ICACHE_ASSOC","","",N,N],[17,"_SC_LEVEL1_ICACHE_LINESIZE","","",N,N],[17,"_SC_LEVEL1_DCACHE_SIZE","","",N,N],[17,"_SC_LEVEL1_DCACHE_ASSOC","","",N,N],[17,"_SC_LEVEL1_DCACHE_LINESIZE","","",N,N],[17,"_SC_LEVEL2_CACHE_SIZE","","",N,N],[17,"_SC_LEVEL2_CACHE_ASSOC","","",N,N],[17,"_SC_LEVEL2_CACHE_LINESIZE","","",N,N],[17,"_SC_LEVEL3_CACHE_SIZE","","",N,N],[17,"_SC_LEVEL3_CACHE_ASSOC","","",N,N],[17,"_SC_LEVEL3_CACHE_LINESIZE","","",N,N],[17,"_SC_LEVEL4_CACHE_SIZE","","",N,N],[17,"_SC_LEVEL4_CACHE_ASSOC","","",N,N],[17,"_SC_LEVEL4_CACHE_LINESIZE","","",N,N],[17,"O_ACCMODE","","",N,N],[17,"ST_RELATIME","","",N,N],[17,"NI_MAXHOST","","",N,N],[17,"ADFS_SUPER_MAGIC","","",N,N],[17,"AFFS_SUPER_MAGIC","","",N,N],[17,"CODA_SUPER_MAGIC","","",N,N],[17,"CRAMFS_MAGIC","","",N,N],[17,"EFS_SUPER_MAGIC","","",N,N],[17,"EXT2_SUPER_MAGIC","","",N,N],[17,"EXT3_SUPER_MAGIC","","",N,N],[17,"EXT4_SUPER_MAGIC","","",N,N],[17,"HPFS_SUPER_MAGIC","","",N,N],[17,"HUGETLBFS_MAGIC","","",N,N],[17,"ISOFS_SUPER_MAGIC","","",N,N],[17,"JFFS2_SUPER_MAGIC","","",N,N],[17,"MINIX_SUPER_MAGIC","","",N,N],[17,"MINIX_SUPER_MAGIC2","","",N,N],[17,"MINIX2_SUPER_MAGIC","","",N,N],[17,"MINIX2_SUPER_MAGIC2","","",N,N],[17,"MSDOS_SUPER_MAGIC","","",N,N],[17,"NCP_SUPER_MAGIC","","",N,N],[17,"NFS_SUPER_MAGIC","","",N,N],[17,"OPENPROM_SUPER_MAGIC","","",N,N],[17,"PROC_SUPER_MAGIC","","",N,N],[17,"QNX4_SUPER_MAGIC","","",N,N],[17,"REISERFS_SUPER_MAGIC","","",N,N],[17,"SMB_SUPER_MAGIC","","",N,N],[17,"TMPFS_MAGIC","","",N,N],[17,"USBDEVICE_SUPER_MAGIC","","",N,N],[17,"VEOF","","",N,N],[17,"CPU_SETSIZE","","",N,N],[17,"PTRACE_TRACEME","","",N,N],[17,"PTRACE_PEEKTEXT","","",N,N],[17,"PTRACE_PEEKDATA","","",N,N],[17,"PTRACE_PEEKUSER","","",N,N],[17,"PTRACE_POKETEXT","","",N,N],[17,"PTRACE_POKEDATA","","",N,N],[17,"PTRACE_POKEUSER","","",N,N],[17,"PTRACE_CONT","","",N,N],[17,"PTRACE_KILL","","",N,N],[17,"PTRACE_SINGLESTEP","","",N,N],[17,"PTRACE_ATTACH","","",N,N],[17,"PTRACE_SYSCALL","","",N,N],[17,"PTRACE_SETOPTIONS","","",N,N],[17,"PTRACE_GETEVENTMSG","","",N,N],[17,"PTRACE_GETSIGINFO","","",N,N],[17,"PTRACE_SETSIGINFO","","",N,N],[17,"PTRACE_GETREGSET","","",N,N],[17,"PTRACE_SETREGSET","","",N,N],[17,"PTRACE_SEIZE","","",N,N],[17,"PTRACE_INTERRUPT","","",N,N],[17,"PTRACE_LISTEN","","",N,N],[17,"PTRACE_PEEKSIGINFO","","",N,N],[17,"EPOLLWAKEUP","","",N,N],[17,"MAP_HUGETLB","","",N,N],[17,"SEEK_DATA","","",N,N],[17,"SEEK_HOLE","","",N,N],[17,"TCSANOW","","",N,N],[17,"TCSADRAIN","","",N,N],[17,"TCSAFLUSH","","",N,N],[17,"TIOCLINUX","","",N,N],[17,"TIOCGSERIAL","","",N,N],[17,"RTLD_DEEPBIND","","",N,N],[17,"RTLD_GLOBAL","","",N,N],[17,"RTLD_NOLOAD","","",N,N],[17,"LINUX_REBOOT_MAGIC1","","",N,N],[17,"LINUX_REBOOT_MAGIC2","","",N,N],[17,"LINUX_REBOOT_MAGIC2A","","",N,N],[17,"LINUX_REBOOT_MAGIC2B","","",N,N],[17,"LINUX_REBOOT_MAGIC2C","","",N,N],[17,"LINUX_REBOOT_CMD_RESTART","","",N,N],[17,"LINUX_REBOOT_CMD_HALT","","",N,N],[17,"LINUX_REBOOT_CMD_CAD_ON","","",N,N],[17,"LINUX_REBOOT_CMD_CAD_OFF","","",N,N],[17,"LINUX_REBOOT_CMD_POWER_OFF","","",N,N],[17,"LINUX_REBOOT_CMD_RESTART2","","",N,N],[17,"LINUX_REBOOT_CMD_SW_SUSPEND","","",N,N],[17,"LINUX_REBOOT_CMD_KEXEC","","",N,N],[17,"NETLINK_ROUTE","","",N,N],[17,"NETLINK_UNUSED","","",N,N],[17,"NETLINK_USERSOCK","","",N,N],[17,"NETLINK_FIREWALL","","",N,N],[17,"NETLINK_SOCK_DIAG","","",N,N],[17,"NETLINK_NFLOG","","",N,N],[17,"NETLINK_XFRM","","",N,N],[17,"NETLINK_SELINUX","","",N,N],[17,"NETLINK_ISCSI","","",N,N],[17,"NETLINK_AUDIT","","",N,N],[17,"NETLINK_FIB_LOOKUP","","",N,N],[17,"NETLINK_CONNECTOR","","",N,N],[17,"NETLINK_NETFILTER","","",N,N],[17,"NETLINK_IP6_FW","","",N,N],[17,"NETLINK_DNRTMSG","","",N,N],[17,"NETLINK_KOBJECT_UEVENT","","",N,N],[17,"NETLINK_GENERIC","","",N,N],[17,"NETLINK_SCSITRANSPORT","","",N,N],[17,"NETLINK_ECRYPTFS","","",N,N],[17,"NETLINK_RDMA","","",N,N],[17,"NETLINK_CRYPTO","","",N,N],[17,"NETLINK_INET_DIAG","","",N,N],[17,"MAX_LINKS","","",N,N],[17,"NLM_F_REQUEST","","",N,N],[17,"NLM_F_MULTI","","",N,N],[17,"NLM_F_ACK","","",N,N],[17,"NLM_F_ECHO","","",N,N],[17,"NLM_F_DUMP_INTR","","",N,N],[17,"NLM_F_DUMP_FILTERED","","",N,N],[17,"NLM_F_ROOT","","",N,N],[17,"NLM_F_MATCH","","",N,N],[17,"NLM_F_ATOMIC","","",N,N],[17,"NLM_F_DUMP","","",N,N],[17,"NLM_F_REPLACE","","",N,N],[17,"NLM_F_EXCL","","",N,N],[17,"NLM_F_CREATE","","",N,N],[17,"NLM_F_APPEND","","",N,N],[17,"NETLINK_ADD_MEMBERSHIP","","",N,N],[17,"NETLINK_DROP_MEMBERSHIP","","",N,N],[17,"NETLINK_PKTINFO","","",N,N],[17,"NETLINK_BROADCAST_ERROR","","",N,N],[17,"NETLINK_NO_ENOBUFS","","",N,N],[17,"NETLINK_RX_RING","","",N,N],[17,"NETLINK_TX_RING","","",N,N],[17,"NETLINK_LISTEN_ALL_NSID","","",N,N],[17,"NETLINK_LIST_MEMBERSHIPS","","",N,N],[17,"NETLINK_CAP_ACK","","",N,N],[17,"NLA_F_NESTED","","",N,N],[17,"NLA_F_NET_BYTEORDER","","",N,N],[17,"NLA_TYPE_MASK","","",N,N],[17,"NLA_ALIGNTO","","",N,N],[17,"GENL_UNS_ADMIN_PERM","","",N,N],[17,"GENL_ID_VFS_DQUOT","","",N,N],[17,"GENL_ID_PMCRAID","","",N,N],[17,"TIOCM_LE","","",N,N],[17,"TIOCM_DTR","","",N,N],[17,"TIOCM_RTS","","",N,N],[17,"TIOCM_ST","","",N,N],[17,"TIOCM_SR","","",N,N],[17,"TIOCM_CTS","","",N,N],[17,"TIOCM_CAR","","",N,N],[17,"TIOCM_RNG","","",N,N],[17,"TIOCM_DSR","","",N,N],[17,"TIOCM_CD","","",N,N],[17,"TIOCM_RI","","",N,N],[17,"NF_NETDEV_INGRESS","","",N,N],[17,"NF_NETDEV_NUMHOOKS","","",N,N],[17,"NFPROTO_INET","","",N,N],[17,"NFPROTO_NETDEV","","",N,N],[17,"NFT_TABLE_MAXNAMELEN","","",N,N],[17,"NFT_CHAIN_MAXNAMELEN","","",N,N],[17,"NFT_SET_MAXNAMELEN","","",N,N],[17,"NFT_OBJ_MAXNAMELEN","","",N,N],[17,"NFT_USERDATA_MAXLEN","","",N,N],[17,"NFT_REG_VERDICT","","",N,N],[17,"NFT_REG_1","","",N,N],[17,"NFT_REG_2","","",N,N],[17,"NFT_REG_3","","",N,N],[17,"NFT_REG_4","","",N,N],[17,"__NFT_REG_MAX","","",N,N],[17,"NFT_REG32_00","","",N,N],[17,"NFT_REG32_01","","",N,N],[17,"NFT_REG32_02","","",N,N],[17,"NFT_REG32_03","","",N,N],[17,"NFT_REG32_04","","",N,N],[17,"NFT_REG32_05","","",N,N],[17,"NFT_REG32_06","","",N,N],[17,"NFT_REG32_07","","",N,N],[17,"NFT_REG32_08","","",N,N],[17,"NFT_REG32_09","","",N,N],[17,"NFT_REG32_10","","",N,N],[17,"NFT_REG32_11","","",N,N],[17,"NFT_REG32_12","","",N,N],[17,"NFT_REG32_13","","",N,N],[17,"NFT_REG32_14","","",N,N],[17,"NFT_REG32_15","","",N,N],[17,"NFT_REG_SIZE","","",N,N],[17,"NFT_REG32_SIZE","","",N,N],[17,"NFT_CONTINUE","","",N,N],[17,"NFT_BREAK","","",N,N],[17,"NFT_JUMP","","",N,N],[17,"NFT_GOTO","","",N,N],[17,"NFT_RETURN","","",N,N],[17,"NFT_MSG_NEWTABLE","","",N,N],[17,"NFT_MSG_GETTABLE","","",N,N],[17,"NFT_MSG_DELTABLE","","",N,N],[17,"NFT_MSG_NEWCHAIN","","",N,N],[17,"NFT_MSG_GETCHAIN","","",N,N],[17,"NFT_MSG_DELCHAIN","","",N,N],[17,"NFT_MSG_NEWRULE","","",N,N],[17,"NFT_MSG_GETRULE","","",N,N],[17,"NFT_MSG_DELRULE","","",N,N],[17,"NFT_MSG_NEWSET","","",N,N],[17,"NFT_MSG_GETSET","","",N,N],[17,"NFT_MSG_DELSET","","",N,N],[17,"NFT_MSG_NEWSETELEM","","",N,N],[17,"NFT_MSG_GETSETELEM","","",N,N],[17,"NFT_MSG_DELSETELEM","","",N,N],[17,"NFT_MSG_NEWGEN","","",N,N],[17,"NFT_MSG_GETGEN","","",N,N],[17,"NFT_MSG_TRACE","","",N,N],[17,"NFT_MSG_NEWOBJ","","",N,N],[17,"NFT_MSG_GETOBJ","","",N,N],[17,"NFT_MSG_DELOBJ","","",N,N],[17,"NFT_MSG_GETOBJ_RESET","","",N,N],[17,"NFT_MSG_MAX","","",N,N],[17,"NFT_SET_ANONYMOUS","","",N,N],[17,"NFT_SET_CONSTANT","","",N,N],[17,"NFT_SET_INTERVAL","","",N,N],[17,"NFT_SET_MAP","","",N,N],[17,"NFT_SET_TIMEOUT","","",N,N],[17,"NFT_SET_EVAL","","",N,N],[17,"NFT_SET_POL_PERFORMANCE","","",N,N],[17,"NFT_SET_POL_MEMORY","","",N,N],[17,"NFT_SET_ELEM_INTERVAL_END","","",N,N],[17,"NFT_DATA_VALUE","","",N,N],[17,"NFT_DATA_VERDICT","","",N,N],[17,"NFT_DATA_RESERVED_MASK","","",N,N],[17,"NFT_DATA_VALUE_MAXLEN","","",N,N],[17,"NFT_BYTEORDER_NTOH","","",N,N],[17,"NFT_BYTEORDER_HTON","","",N,N],[17,"NFT_CMP_EQ","","",N,N],[17,"NFT_CMP_NEQ","","",N,N],[17,"NFT_CMP_LT","","",N,N],[17,"NFT_CMP_LTE","","",N,N],[17,"NFT_CMP_GT","","",N,N],[17,"NFT_CMP_GTE","","",N,N],[17,"NFT_RANGE_EQ","","",N,N],[17,"NFT_RANGE_NEQ","","",N,N],[17,"NFT_LOOKUP_F_INV","","",N,N],[17,"NFT_DYNSET_OP_ADD","","",N,N],[17,"NFT_DYNSET_OP_UPDATE","","",N,N],[17,"NFT_DYNSET_F_INV","","",N,N],[17,"NFT_PAYLOAD_LL_HEADER","","",N,N],[17,"NFT_PAYLOAD_NETWORK_HEADER","","",N,N],[17,"NFT_PAYLOAD_TRANSPORT_HEADER","","",N,N],[17,"NFT_PAYLOAD_CSUM_NONE","","",N,N],[17,"NFT_PAYLOAD_CSUM_INET","","",N,N],[17,"NFT_META_LEN","","",N,N],[17,"NFT_META_PROTOCOL","","",N,N],[17,"NFT_META_PRIORITY","","",N,N],[17,"NFT_META_MARK","","",N,N],[17,"NFT_META_IIF","","",N,N],[17,"NFT_META_OIF","","",N,N],[17,"NFT_META_IIFNAME","","",N,N],[17,"NFT_META_OIFNAME","","",N,N],[17,"NFT_META_IIFTYPE","","",N,N],[17,"NFT_META_OIFTYPE","","",N,N],[17,"NFT_META_SKUID","","",N,N],[17,"NFT_META_SKGID","","",N,N],[17,"NFT_META_NFTRACE","","",N,N],[17,"NFT_META_RTCLASSID","","",N,N],[17,"NFT_META_SECMARK","","",N,N],[17,"NFT_META_NFPROTO","","",N,N],[17,"NFT_META_L4PROTO","","",N,N],[17,"NFT_META_BRI_IIFNAME","","",N,N],[17,"NFT_META_BRI_OIFNAME","","",N,N],[17,"NFT_META_PKTTYPE","","",N,N],[17,"NFT_META_CPU","","",N,N],[17,"NFT_META_IIFGROUP","","",N,N],[17,"NFT_META_OIFGROUP","","",N,N],[17,"NFT_META_CGROUP","","",N,N],[17,"NFT_META_PRANDOM","","",N,N],[17,"NFT_CT_STATE","","",N,N],[17,"NFT_CT_DIRECTION","","",N,N],[17,"NFT_CT_STATUS","","",N,N],[17,"NFT_CT_MARK","","",N,N],[17,"NFT_CT_SECMARK","","",N,N],[17,"NFT_CT_EXPIRATION","","",N,N],[17,"NFT_CT_HELPER","","",N,N],[17,"NFT_CT_L3PROTOCOL","","",N,N],[17,"NFT_CT_SRC","","",N,N],[17,"NFT_CT_DST","","",N,N],[17,"NFT_CT_PROTOCOL","","",N,N],[17,"NFT_CT_PROTO_SRC","","",N,N],[17,"NFT_CT_PROTO_DST","","",N,N],[17,"NFT_CT_LABELS","","",N,N],[17,"NFT_CT_PKTS","","",N,N],[17,"NFT_CT_BYTES","","",N,N],[17,"NFT_LIMIT_PKTS","","",N,N],[17,"NFT_LIMIT_PKT_BYTES","","",N,N],[17,"NFT_LIMIT_F_INV","","",N,N],[17,"NFT_QUEUE_FLAG_BYPASS","","",N,N],[17,"NFT_QUEUE_FLAG_CPU_FANOUT","","",N,N],[17,"NFT_QUEUE_FLAG_MASK","","",N,N],[17,"NFT_QUOTA_F_INV","","",N,N],[17,"NFT_REJECT_ICMP_UNREACH","","",N,N],[17,"NFT_REJECT_TCP_RST","","",N,N],[17,"NFT_REJECT_ICMPX_UNREACH","","",N,N],[17,"NFT_REJECT_ICMPX_NO_ROUTE","","",N,N],[17,"NFT_REJECT_ICMPX_PORT_UNREACH","","",N,N],[17,"NFT_REJECT_ICMPX_HOST_UNREACH","","",N,N],[17,"NFT_REJECT_ICMPX_ADMIN_PROHIBITED","","",N,N],[17,"NFT_NAT_SNAT","","",N,N],[17,"NFT_NAT_DNAT","","",N,N],[17,"NFT_TRACETYPE_UNSPEC","","",N,N],[17,"NFT_TRACETYPE_POLICY","","",N,N],[17,"NFT_TRACETYPE_RETURN","","",N,N],[17,"NFT_TRACETYPE_RULE","","",N,N],[17,"NFT_NG_INCREMENTAL","","",N,N],[17,"NFT_NG_RANDOM","","",N,N],[17,"M_MXFAST","","",N,N],[17,"M_NLBLKS","","",N,N],[17,"M_GRAIN","","",N,N],[17,"M_KEEP","","",N,N],[17,"M_TRIM_THRESHOLD","","",N,N],[17,"M_TOP_PAD","","",N,N],[17,"M_MMAP_THRESHOLD","","",N,N],[17,"M_MMAP_MAX","","",N,N],[17,"M_CHECK_ACTION","","",N,N],[17,"M_PERTURB","","",N,N],[17,"M_ARENA_TEST","","",N,N],[17,"M_ARENA_MAX","","",N,N],[17,"PTHREAD_STACK_MIN","","",N,N],[17,"PTHREAD_MUTEX_ADAPTIVE_NP","","",N,N],[17,"__SIZEOF_PTHREAD_RWLOCKATTR_T","","",N,N],[17,"O_LARGEFILE","","",N,N],[17,"TIOCGSOFTCAR","","",N,N],[17,"TIOCSSOFTCAR","","",N,N],[17,"RLIMIT_NOFILE","","",N,N],[17,"RLIMIT_NPROC","","",N,N],[17,"O_APPEND","","",N,N],[17,"O_CREAT","","",N,N],[17,"O_EXCL","","",N,N],[17,"O_NOCTTY","","",N,N],[17,"O_NONBLOCK","","",N,N],[17,"O_SYNC","","",N,N],[17,"O_RSYNC","","",N,N],[17,"O_DSYNC","","",N,N],[17,"O_FSYNC","","",N,N],[17,"O_NOATIME","","",N,N],[17,"O_PATH","","",N,N],[17,"O_TMPFILE","","",N,N],[17,"MAP_GROWSDOWN","","",N,N],[17,"EDEADLK","","",N,N],[17,"ENAMETOOLONG","","",N,N],[17,"ENOLCK","","",N,N],[17,"ENOSYS","","",N,N],[17,"ENOTEMPTY","","",N,N],[17,"ELOOP","","",N,N],[17,"ENOMSG","","",N,N],[17,"EIDRM","","",N,N],[17,"ECHRNG","","",N,N],[17,"EL2NSYNC","","",N,N],[17,"EL3HLT","","",N,N],[17,"EL3RST","","",N,N],[17,"ELNRNG","","",N,N],[17,"EUNATCH","","",N,N],[17,"ENOCSI","","",N,N],[17,"EL2HLT","","",N,N],[17,"EBADE","","",N,N],[17,"EBADR","","",N,N],[17,"EXFULL","","",N,N],[17,"ENOANO","","",N,N],[17,"EBADRQC","","",N,N],[17,"EBADSLT","","",N,N],[17,"EMULTIHOP","","",N,N],[17,"EOVERFLOW","","",N,N],[17,"ENOTUNIQ","","",N,N],[17,"EBADFD","","",N,N],[17,"EBADMSG","","",N,N],[17,"EREMCHG","","",N,N],[17,"ELIBACC","","",N,N],[17,"ELIBBAD","","",N,N],[17,"ELIBSCN","","",N,N],[17,"ELIBMAX","","",N,N],[17,"ELIBEXEC","","",N,N],[17,"EILSEQ","","",N,N],[17,"ERESTART","","",N,N],[17,"ESTRPIPE","","",N,N],[17,"EUSERS","","",N,N],[17,"ENOTSOCK","","",N,N],[17,"EDESTADDRREQ","","",N,N],[17,"EMSGSIZE","","",N,N],[17,"EPROTOTYPE","","",N,N],[17,"ENOPROTOOPT","","",N,N],[17,"EPROTONOSUPPORT","","",N,N],[17,"ESOCKTNOSUPPORT","","",N,N],[17,"EOPNOTSUPP","","",N,N],[17,"EPFNOSUPPORT","","",N,N],[17,"EAFNOSUPPORT","","",N,N],[17,"EADDRINUSE","","",N,N],[17,"EADDRNOTAVAIL","","",N,N],[17,"ENETDOWN","","",N,N],[17,"ENETUNREACH","","",N,N],[17,"ENETRESET","","",N,N],[17,"ECONNABORTED","","",N,N],[17,"ECONNRESET","","",N,N],[17,"ENOBUFS","","",N,N],[17,"EISCONN","","",N,N],[17,"ENOTCONN","","",N,N],[17,"ESHUTDOWN","","",N,N],[17,"ETOOMANYREFS","","",N,N],[17,"ETIMEDOUT","","",N,N],[17,"ECONNREFUSED","","",N,N],[17,"EHOSTDOWN","","",N,N],[17,"EHOSTUNREACH","","",N,N],[17,"EALREADY","","",N,N],[17,"EINPROGRESS","","",N,N],[17,"ESTALE","","",N,N],[17,"EDQUOT","","",N,N],[17,"ENOMEDIUM","","",N,N],[17,"EMEDIUMTYPE","","",N,N],[17,"ECANCELED","","",N,N],[17,"ENOKEY","","",N,N],[17,"EKEYEXPIRED","","",N,N],[17,"EKEYREVOKED","","",N,N],[17,"EKEYREJECTED","","",N,N],[17,"EOWNERDEAD","","",N,N],[17,"ENOTRECOVERABLE","","",N,N],[17,"EHWPOISON","","",N,N],[17,"ERFKILL","","",N,N],[17,"SOL_SOCKET","","",N,N],[17,"SO_REUSEADDR","","",N,N],[17,"SO_TYPE","","",N,N],[17,"SO_ERROR","","",N,N],[17,"SO_DONTROUTE","","",N,N],[17,"SO_BROADCAST","","",N,N],[17,"SO_SNDBUF","","",N,N],[17,"SO_RCVBUF","","",N,N],[17,"SO_SNDBUFFORCE","","",N,N],[17,"SO_RCVBUFFORCE","","",N,N],[17,"SO_KEEPALIVE","","",N,N],[17,"SO_OOBINLINE","","",N,N],[17,"SO_NO_CHECK","","",N,N],[17,"SO_PRIORITY","","",N,N],[17,"SO_LINGER","","",N,N],[17,"SO_BSDCOMPAT","","",N,N],[17,"SO_REUSEPORT","","",N,N],[17,"SO_PASSCRED","","",N,N],[17,"SO_PEERCRED","","",N,N],[17,"SO_RCVLOWAT","","",N,N],[17,"SO_SNDLOWAT","","",N,N],[17,"SO_RCVTIMEO","","",N,N],[17,"SO_SNDTIMEO","","",N,N],[17,"SO_SECURITY_AUTHENTICATION","","",N,N],[17,"SO_SECURITY_ENCRYPTION_TRANSPORT","","",N,N],[17,"SO_SECURITY_ENCRYPTION_NETWORK","","",N,N],[17,"SO_BINDTODEVICE","","",N,N],[17,"SO_ATTACH_FILTER","","",N,N],[17,"SO_DETACH_FILTER","","",N,N],[17,"SO_GET_FILTER","","",N,N],[17,"SO_PEERNAME","","",N,N],[17,"SO_TIMESTAMP","","",N,N],[17,"SO_ACCEPTCONN","","",N,N],[17,"SO_PEERSEC","","",N,N],[17,"SO_PASSSEC","","",N,N],[17,"SO_TIMESTAMPNS","","",N,N],[17,"SCM_TIMESTAMPNS","","",N,N],[17,"SO_MARK","","",N,N],[17,"SO_PROTOCOL","","",N,N],[17,"SO_DOMAIN","","",N,N],[17,"SO_RXQ_OVFL","","",N,N],[17,"SO_WIFI_STATUS","","",N,N],[17,"SCM_WIFI_STATUS","","",N,N],[17,"SO_PEEK_OFF","","",N,N],[17,"SO_NOFCS","","",N,N],[17,"SO_LOCK_FILTER","","",N,N],[17,"SO_SELECT_ERR_QUEUE","","",N,N],[17,"SO_BUSY_POLL","","",N,N],[17,"SO_MAX_PACING_RATE","","",N,N],[17,"SO_BPF_EXTENSIONS","","",N,N],[17,"SO_INCOMING_CPU","","",N,N],[17,"SO_ATTACH_BPF","","",N,N],[17,"SO_DETACH_BPF","","",N,N],[17,"SA_ONSTACK","","",N,N],[17,"SA_SIGINFO","","",N,N],[17,"SA_NOCLDWAIT","","",N,N],[17,"SIGCHLD","","",N,N],[17,"SIGBUS","","",N,N],[17,"SIGUSR1","","",N,N],[17,"SIGUSR2","","",N,N],[17,"SIGCONT","","",N,N],[17,"SIGSTOP","","",N,N],[17,"SIGTSTP","","",N,N],[17,"SIGURG","","",N,N],[17,"SIGIO","","",N,N],[17,"SIGSYS","","",N,N],[17,"SIGSTKFLT","","",N,N],[17,"SIGUNUSED","","",N,N],[17,"SIGPOLL","","",N,N],[17,"SIGPWR","","",N,N],[17,"SIG_SETMASK","","",N,N],[17,"SIG_BLOCK","","",N,N],[17,"SIG_UNBLOCK","","",N,N],[17,"POLLWRNORM","","",N,N],[17,"POLLWRBAND","","",N,N],[17,"O_ASYNC","","",N,N],[17,"O_NDELAY","","",N,N],[17,"PTRACE_DETACH","","",N,N],[17,"EFD_NONBLOCK","","",N,N],[17,"F_GETLK","","",N,N],[17,"F_GETOWN","","",N,N],[17,"F_SETOWN","","",N,N],[17,"F_SETLK","","",N,N],[17,"F_SETLKW","","",N,N],[17,"F_RDLCK","","",N,N],[17,"F_WRLCK","","",N,N],[17,"F_UNLCK","","",N,N],[17,"SFD_NONBLOCK","","",N,N],[17,"TIOCEXCL","","",N,N],[17,"TIOCNXCL","","",N,N],[17,"TIOCSCTTY","","",N,N],[17,"TIOCSTI","","",N,N],[17,"TIOCMGET","","",N,N],[17,"TIOCMBIS","","",N,N],[17,"TIOCMBIC","","",N,N],[17,"TIOCMSET","","",N,N],[17,"TIOCCONS","","",N,N],[17,"SFD_CLOEXEC","","",N,N],[17,"NCCS","","",N,N],[17,"O_TRUNC","","",N,N],[17,"O_CLOEXEC","","",N,N],[17,"EBFONT","","",N,N],[17,"ENOSTR","","",N,N],[17,"ENODATA","","",N,N],[17,"ETIME","","",N,N],[17,"ENOSR","","",N,N],[17,"ENONET","","",N,N],[17,"ENOPKG","","",N,N],[17,"EREMOTE","","",N,N],[17,"ENOLINK","","",N,N],[17,"EADV","","",N,N],[17,"ESRMNT","","",N,N],[17,"ECOMM","","",N,N],[17,"EPROTO","","",N,N],[17,"EDOTDOT","","",N,N],[17,"SA_NODEFER","","",N,N],[17,"SA_RESETHAND","","",N,N],[17,"SA_RESTART","","",N,N],[17,"SA_NOCLDSTOP","","",N,N],[17,"EPOLL_CLOEXEC","","",N,N],[17,"EFD_CLOEXEC","","",N,N],[17,"__SIZEOF_PTHREAD_CONDATTR_T","","",N,N],[17,"__SIZEOF_PTHREAD_MUTEXATTR_T","","",N,N],[17,"O_DIRECT","","",N,N],[17,"O_DIRECTORY","","",N,N],[17,"O_NOFOLLOW","","",N,N],[17,"MAP_LOCKED","","",N,N],[17,"MAP_NORESERVE","","",N,N],[17,"MAP_32BIT","","",N,N],[17,"EDEADLOCK","","",N,N],[17,"FIOCLEX","","",N,N],[17,"FIONBIO","","",N,N],[17,"PTRACE_GETFPREGS","","",N,N],[17,"PTRACE_SETFPREGS","","",N,N],[17,"PTRACE_GETFPXREGS","","",N,N],[17,"PTRACE_SETFPXREGS","","",N,N],[17,"PTRACE_GETREGS","","",N,N],[17,"PTRACE_SETREGS","","",N,N],[17,"PTRACE_PEEKSIGINFO_SHARED","","",N,N],[17,"MCL_CURRENT","","",N,N],[17,"MCL_FUTURE","","",N,N],[17,"SIGSTKSZ","","",N,N],[17,"MINSIGSTKSZ","","",N,N],[17,"CBAUD","","",N,N],[17,"TAB1","","",N,N],[17,"TAB2","","",N,N],[17,"TAB3","","",N,N],[17,"CR1","","",N,N],[17,"CR2","","",N,N],[17,"CR3","","",N,N],[17,"FF1","","",N,N],[17,"BS1","","",N,N],[17,"VT1","","",N,N],[17,"VWERASE","","",N,N],[17,"VREPRINT","","",N,N],[17,"VSUSP","","",N,N],[17,"VSTART","","",N,N],[17,"VSTOP","","",N,N],[17,"VDISCARD","","",N,N],[17,"VTIME","","",N,N],[17,"IXON","","",N,N],[17,"IXOFF","","",N,N],[17,"ONLCR","","",N,N],[17,"CSIZE","","",N,N],[17,"CS6","","",N,N],[17,"CS7","","",N,N],[17,"CS8","","",N,N],[17,"CSTOPB","","",N,N],[17,"CREAD","","",N,N],[17,"PARENB","","",N,N],[17,"PARODD","","",N,N],[17,"HUPCL","","",N,N],[17,"CLOCAL","","",N,N],[17,"ECHOKE","","",N,N],[17,"ECHOE","","",N,N],[17,"ECHOK","","",N,N],[17,"ECHONL","","",N,N],[17,"ECHOPRT","","",N,N],[17,"ECHOCTL","","",N,N],[17,"ISIG","","",N,N],[17,"ICANON","","",N,N],[17,"PENDIN","","",N,N],[17,"NOFLSH","","",N,N],[17,"CIBAUD","","",N,N],[17,"CBAUDEX","","",N,N],[17,"VSWTC","","",N,N],[17,"OLCUC","","",N,N],[17,"NLDLY","","",N,N],[17,"CRDLY","","",N,N],[17,"TABDLY","","",N,N],[17,"BSDLY","","",N,N],[17,"FFDLY","","",N,N],[17,"VTDLY","","",N,N],[17,"XTABS","","",N,N],[17,"B0","","",N,N],[17,"B50","","",N,N],[17,"B75","","",N,N],[17,"B110","","",N,N],[17,"B134","","",N,N],[17,"B150","","",N,N],[17,"B200","","",N,N],[17,"B300","","",N,N],[17,"B600","","",N,N],[17,"B1200","","",N,N],[17,"B1800","","",N,N],[17,"B2400","","",N,N],[17,"B4800","","",N,N],[17,"B9600","","",N,N],[17,"B19200","","",N,N],[17,"B38400","","",N,N],[17,"EXTA","","",N,N],[17,"EXTB","","",N,N],[17,"BOTHER","","",N,N],[17,"B57600","","",N,N],[17,"B115200","","",N,N],[17,"B230400","","",N,N],[17,"B460800","","",N,N],[17,"B500000","","",N,N],[17,"B576000","","",N,N],[17,"B921600","","",N,N],[17,"B1000000","","",N,N],[17,"B1152000","","",N,N],[17,"B1500000","","",N,N],[17,"B2000000","","",N,N],[17,"B2500000","","",N,N],[17,"B3000000","","",N,N],[17,"B3500000","","",N,N],[17,"B4000000","","",N,N],[17,"VEOL","","",N,N],[17,"VEOL2","","",N,N],[17,"VMIN","","",N,N],[17,"IEXTEN","","",N,N],[17,"TOSTOP","","",N,N],[17,"FLUSHO","","",N,N],[17,"EXTPROC","","",N,N],[17,"TCGETS","","",N,N],[17,"TCSETS","","",N,N],[17,"TCSETSW","","",N,N],[17,"TCSETSF","","",N,N],[17,"TCGETA","","",N,N],[17,"TCSETA","","",N,N],[17,"TCSETAW","","",N,N],[17,"TCSETAF","","",N,N],[17,"TCSBRK","","",N,N],[17,"TCXONC","","",N,N],[17,"TCFLSH","","",N,N],[17,"TIOCINQ","","",N,N],[17,"TIOCGPGRP","","",N,N],[17,"TIOCSPGRP","","",N,N],[17,"TIOCOUTQ","","",N,N],[17,"TIOCGWINSZ","","",N,N],[17,"TIOCSWINSZ","","",N,N],[17,"FIONREAD","","",N,N],[17,"R15","","",N,N],[17,"R14","","",N,N],[17,"R13","","",N,N],[17,"R12","","",N,N],[17,"RBP","","",N,N],[17,"RBX","","",N,N],[17,"R11","","",N,N],[17,"R10","","",N,N],[17,"R9","","",N,N],[17,"R8","","",N,N],[17,"RAX","","",N,N],[17,"RCX","","",N,N],[17,"RDX","","",N,N],[17,"RSI","","",N,N],[17,"RDI","","",N,N],[17,"ORIG_RAX","","",N,N],[17,"RIP","","",N,N],[17,"CS","","",N,N],[17,"EFLAGS","","",N,N],[17,"RSP","","",N,N],[17,"SS","","",N,N],[17,"FS_BASE","","",N,N],[17,"GS_BASE","","",N,N],[17,"DS","","",N,N],[17,"ES","","",N,N],[17,"FS","","",N,N],[17,"GS","","",N,N],[17,"REG_R8","","",N,N],[17,"REG_R9","","",N,N],[17,"REG_R10","","",N,N],[17,"REG_R11","","",N,N],[17,"REG_R12","","",N,N],[17,"REG_R13","","",N,N],[17,"REG_R14","","",N,N],[17,"REG_R15","","",N,N],[17,"REG_RDI","","",N,N],[17,"REG_RSI","","",N,N],[17,"REG_RBP","","",N,N],[17,"REG_RBX","","",N,N],[17,"REG_RDX","","",N,N],[17,"REG_RAX","","",N,N],[17,"REG_RCX","","",N,N],[17,"REG_RSP","","",N,N],[17,"REG_RIP","","",N,N],[17,"REG_EFL","","",N,N],[17,"REG_CSGSFS","","",N,N],[17,"REG_ERR","","",N,N],[17,"REG_TRAPNO","","",N,N],[17,"REG_OLDMASK","","",N,N],[17,"REG_CR2","","",N,N],[17,"__SIZEOF_PTHREAD_MUTEX_T","","",N,N],[17,"__SIZEOF_PTHREAD_RWLOCK_T","","",N,N],[17,"PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP","","",N,N],[17,"PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP","","",N,N],[17,"PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP","","",N,N],[17,"SYS_read","","",N,N],[17,"SYS_write","","",N,N],[17,"SYS_open","","",N,N],[17,"SYS_close","","",N,N],[17,"SYS_stat","","",N,N],[17,"SYS_fstat","","",N,N],[17,"SYS_lstat","","",N,N],[17,"SYS_poll","","",N,N],[17,"SYS_lseek","","",N,N],[17,"SYS_mmap","","",N,N],[17,"SYS_mprotect","","",N,N],[17,"SYS_munmap","","",N,N],[17,"SYS_brk","","",N,N],[17,"SYS_rt_sigaction","","",N,N],[17,"SYS_rt_sigprocmask","","",N,N],[17,"SYS_rt_sigreturn","","",N,N],[17,"SYS_ioctl","","",N,N],[17,"SYS_pread64","","",N,N],[17,"SYS_pwrite64","","",N,N],[17,"SYS_readv","","",N,N],[17,"SYS_writev","","",N,N],[17,"SYS_access","","",N,N],[17,"SYS_pipe","","",N,N],[17,"SYS_select","","",N,N],[17,"SYS_sched_yield","","",N,N],[17,"SYS_mremap","","",N,N],[17,"SYS_msync","","",N,N],[17,"SYS_mincore","","",N,N],[17,"SYS_madvise","","",N,N],[17,"SYS_shmget","","",N,N],[17,"SYS_shmat","","",N,N],[17,"SYS_shmctl","","",N,N],[17,"SYS_dup","","",N,N],[17,"SYS_dup2","","",N,N],[17,"SYS_pause","","",N,N],[17,"SYS_nanosleep","","",N,N],[17,"SYS_getitimer","","",N,N],[17,"SYS_alarm","","",N,N],[17,"SYS_setitimer","","",N,N],[17,"SYS_getpid","","",N,N],[17,"SYS_sendfile","","",N,N],[17,"SYS_socket","","",N,N],[17,"SYS_connect","","",N,N],[17,"SYS_accept","","",N,N],[17,"SYS_sendto","","",N,N],[17,"SYS_recvfrom","","",N,N],[17,"SYS_sendmsg","","",N,N],[17,"SYS_recvmsg","","",N,N],[17,"SYS_shutdown","","",N,N],[17,"SYS_bind","","",N,N],[17,"SYS_listen","","",N,N],[17,"SYS_getsockname","","",N,N],[17,"SYS_getpeername","","",N,N],[17,"SYS_socketpair","","",N,N],[17,"SYS_setsockopt","","",N,N],[17,"SYS_getsockopt","","",N,N],[17,"SYS_clone","","",N,N],[17,"SYS_fork","","",N,N],[17,"SYS_vfork","","",N,N],[17,"SYS_execve","","",N,N],[17,"SYS_exit","","",N,N],[17,"SYS_wait4","","",N,N],[17,"SYS_kill","","",N,N],[17,"SYS_uname","","",N,N],[17,"SYS_semget","","",N,N],[17,"SYS_semop","","",N,N],[17,"SYS_semctl","","",N,N],[17,"SYS_shmdt","","",N,N],[17,"SYS_msgget","","",N,N],[17,"SYS_msgsnd","","",N,N],[17,"SYS_msgrcv","","",N,N],[17,"SYS_msgctl","","",N,N],[17,"SYS_fcntl","","",N,N],[17,"SYS_flock","","",N,N],[17,"SYS_fsync","","",N,N],[17,"SYS_fdatasync","","",N,N],[17,"SYS_truncate","","",N,N],[17,"SYS_ftruncate","","",N,N],[17,"SYS_getdents","","",N,N],[17,"SYS_getcwd","","",N,N],[17,"SYS_chdir","","",N,N],[17,"SYS_fchdir","","",N,N],[17,"SYS_rename","","",N,N],[17,"SYS_mkdir","","",N,N],[17,"SYS_rmdir","","",N,N],[17,"SYS_creat","","",N,N],[17,"SYS_link","","",N,N],[17,"SYS_unlink","","",N,N],[17,"SYS_symlink","","",N,N],[17,"SYS_readlink","","",N,N],[17,"SYS_chmod","","",N,N],[17,"SYS_fchmod","","",N,N],[17,"SYS_chown","","",N,N],[17,"SYS_fchown","","",N,N],[17,"SYS_lchown","","",N,N],[17,"SYS_umask","","",N,N],[17,"SYS_gettimeofday","","",N,N],[17,"SYS_getrlimit","","",N,N],[17,"SYS_getrusage","","",N,N],[17,"SYS_sysinfo","","",N,N],[17,"SYS_times","","",N,N],[17,"SYS_ptrace","","",N,N],[17,"SYS_getuid","","",N,N],[17,"SYS_syslog","","",N,N],[17,"SYS_getgid","","",N,N],[17,"SYS_setuid","","",N,N],[17,"SYS_setgid","","",N,N],[17,"SYS_geteuid","","",N,N],[17,"SYS_getegid","","",N,N],[17,"SYS_setpgid","","",N,N],[17,"SYS_getppid","","",N,N],[17,"SYS_getpgrp","","",N,N],[17,"SYS_setsid","","",N,N],[17,"SYS_setreuid","","",N,N],[17,"SYS_setregid","","",N,N],[17,"SYS_getgroups","","",N,N],[17,"SYS_setgroups","","",N,N],[17,"SYS_setresuid","","",N,N],[17,"SYS_getresuid","","",N,N],[17,"SYS_setresgid","","",N,N],[17,"SYS_getresgid","","",N,N],[17,"SYS_getpgid","","",N,N],[17,"SYS_setfsuid","","",N,N],[17,"SYS_setfsgid","","",N,N],[17,"SYS_getsid","","",N,N],[17,"SYS_capget","","",N,N],[17,"SYS_capset","","",N,N],[17,"SYS_rt_sigpending","","",N,N],[17,"SYS_rt_sigtimedwait","","",N,N],[17,"SYS_rt_sigqueueinfo","","",N,N],[17,"SYS_rt_sigsuspend","","",N,N],[17,"SYS_sigaltstack","","",N,N],[17,"SYS_utime","","",N,N],[17,"SYS_mknod","","",N,N],[17,"SYS_uselib","","",N,N],[17,"SYS_personality","","",N,N],[17,"SYS_ustat","","",N,N],[17,"SYS_statfs","","",N,N],[17,"SYS_fstatfs","","",N,N],[17,"SYS_sysfs","","",N,N],[17,"SYS_getpriority","","",N,N],[17,"SYS_setpriority","","",N,N],[17,"SYS_sched_setparam","","",N,N],[17,"SYS_sched_getparam","","",N,N],[17,"SYS_sched_setscheduler","","",N,N],[17,"SYS_sched_getscheduler","","",N,N],[17,"SYS_sched_get_priority_max","","",N,N],[17,"SYS_sched_get_priority_min","","",N,N],[17,"SYS_sched_rr_get_interval","","",N,N],[17,"SYS_mlock","","",N,N],[17,"SYS_munlock","","",N,N],[17,"SYS_mlockall","","",N,N],[17,"SYS_munlockall","","",N,N],[17,"SYS_vhangup","","",N,N],[17,"SYS_modify_ldt","","",N,N],[17,"SYS_pivot_root","","",N,N],[17,"SYS__sysctl","","",N,N],[17,"SYS_prctl","","",N,N],[17,"SYS_arch_prctl","","",N,N],[17,"SYS_adjtimex","","",N,N],[17,"SYS_setrlimit","","",N,N],[17,"SYS_chroot","","",N,N],[17,"SYS_sync","","",N,N],[17,"SYS_acct","","",N,N],[17,"SYS_settimeofday","","",N,N],[17,"SYS_mount","","",N,N],[17,"SYS_umount2","","",N,N],[17,"SYS_swapon","","",N,N],[17,"SYS_swapoff","","",N,N],[17,"SYS_reboot","","",N,N],[17,"SYS_sethostname","","",N,N],[17,"SYS_setdomainname","","",N,N],[17,"SYS_iopl","","",N,N],[17,"SYS_ioperm","","",N,N],[17,"SYS_create_module","","",N,N],[17,"SYS_init_module","","",N,N],[17,"SYS_delete_module","","",N,N],[17,"SYS_get_kernel_syms","","",N,N],[17,"SYS_query_module","","",N,N],[17,"SYS_quotactl","","",N,N],[17,"SYS_nfsservctl","","",N,N],[17,"SYS_getpmsg","","",N,N],[17,"SYS_putpmsg","","",N,N],[17,"SYS_afs_syscall","","",N,N],[17,"SYS_tuxcall","","",N,N],[17,"SYS_security","","",N,N],[17,"SYS_gettid","","",N,N],[17,"SYS_readahead","","",N,N],[17,"SYS_setxattr","","",N,N],[17,"SYS_lsetxattr","","",N,N],[17,"SYS_fsetxattr","","",N,N],[17,"SYS_getxattr","","",N,N],[17,"SYS_lgetxattr","","",N,N],[17,"SYS_fgetxattr","","",N,N],[17,"SYS_listxattr","","",N,N],[17,"SYS_llistxattr","","",N,N],[17,"SYS_flistxattr","","",N,N],[17,"SYS_removexattr","","",N,N],[17,"SYS_lremovexattr","","",N,N],[17,"SYS_fremovexattr","","",N,N],[17,"SYS_tkill","","",N,N],[17,"SYS_time","","",N,N],[17,"SYS_futex","","",N,N],[17,"SYS_sched_setaffinity","","",N,N],[17,"SYS_sched_getaffinity","","",N,N],[17,"SYS_set_thread_area","","",N,N],[17,"SYS_io_setup","","",N,N],[17,"SYS_io_destroy","","",N,N],[17,"SYS_io_getevents","","",N,N],[17,"SYS_io_submit","","",N,N],[17,"SYS_io_cancel","","",N,N],[17,"SYS_get_thread_area","","",N,N],[17,"SYS_lookup_dcookie","","",N,N],[17,"SYS_epoll_create","","",N,N],[17,"SYS_epoll_ctl_old","","",N,N],[17,"SYS_epoll_wait_old","","",N,N],[17,"SYS_remap_file_pages","","",N,N],[17,"SYS_getdents64","","",N,N],[17,"SYS_set_tid_address","","",N,N],[17,"SYS_restart_syscall","","",N,N],[17,"SYS_semtimedop","","",N,N],[17,"SYS_fadvise64","","",N,N],[17,"SYS_timer_create","","",N,N],[17,"SYS_timer_settime","","",N,N],[17,"SYS_timer_gettime","","",N,N],[17,"SYS_timer_getoverrun","","",N,N],[17,"SYS_timer_delete","","",N,N],[17,"SYS_clock_settime","","",N,N],[17,"SYS_clock_gettime","","",N,N],[17,"SYS_clock_getres","","",N,N],[17,"SYS_clock_nanosleep","","",N,N],[17,"SYS_exit_group","","",N,N],[17,"SYS_epoll_wait","","",N,N],[17,"SYS_epoll_ctl","","",N,N],[17,"SYS_tgkill","","",N,N],[17,"SYS_utimes","","",N,N],[17,"SYS_vserver","","",N,N],[17,"SYS_mbind","","",N,N],[17,"SYS_set_mempolicy","","",N,N],[17,"SYS_get_mempolicy","","",N,N],[17,"SYS_mq_open","","",N,N],[17,"SYS_mq_unlink","","",N,N],[17,"SYS_mq_timedsend","","",N,N],[17,"SYS_mq_timedreceive","","",N,N],[17,"SYS_mq_notify","","",N,N],[17,"SYS_mq_getsetattr","","",N,N],[17,"SYS_kexec_load","","",N,N],[17,"SYS_waitid","","",N,N],[17,"SYS_add_key","","",N,N],[17,"SYS_request_key","","",N,N],[17,"SYS_keyctl","","",N,N],[17,"SYS_ioprio_set","","",N,N],[17,"SYS_ioprio_get","","",N,N],[17,"SYS_inotify_init","","",N,N],[17,"SYS_inotify_add_watch","","",N,N],[17,"SYS_inotify_rm_watch","","",N,N],[17,"SYS_migrate_pages","","",N,N],[17,"SYS_openat","","",N,N],[17,"SYS_mkdirat","","",N,N],[17,"SYS_mknodat","","",N,N],[17,"SYS_fchownat","","",N,N],[17,"SYS_futimesat","","",N,N],[17,"SYS_newfstatat","","",N,N],[17,"SYS_unlinkat","","",N,N],[17,"SYS_renameat","","",N,N],[17,"SYS_linkat","","",N,N],[17,"SYS_symlinkat","","",N,N],[17,"SYS_readlinkat","","",N,N],[17,"SYS_fchmodat","","",N,N],[17,"SYS_faccessat","","",N,N],[17,"SYS_pselect6","","",N,N],[17,"SYS_ppoll","","",N,N],[17,"SYS_unshare","","",N,N],[17,"SYS_set_robust_list","","",N,N],[17,"SYS_get_robust_list","","",N,N],[17,"SYS_splice","","",N,N],[17,"SYS_tee","","",N,N],[17,"SYS_sync_file_range","","",N,N],[17,"SYS_vmsplice","","",N,N],[17,"SYS_move_pages","","",N,N],[17,"SYS_utimensat","","",N,N],[17,"SYS_epoll_pwait","","",N,N],[17,"SYS_signalfd","","",N,N],[17,"SYS_timerfd_create","","",N,N],[17,"SYS_eventfd","","",N,N],[17,"SYS_fallocate","","",N,N],[17,"SYS_timerfd_settime","","",N,N],[17,"SYS_timerfd_gettime","","",N,N],[17,"SYS_accept4","","",N,N],[17,"SYS_signalfd4","","",N,N],[17,"SYS_eventfd2","","",N,N],[17,"SYS_epoll_create1","","",N,N],[17,"SYS_dup3","","",N,N],[17,"SYS_pipe2","","",N,N],[17,"SYS_inotify_init1","","",N,N],[17,"SYS_preadv","","",N,N],[17,"SYS_pwritev","","",N,N],[17,"SYS_rt_tgsigqueueinfo","","",N,N],[17,"SYS_perf_event_open","","",N,N],[17,"SYS_recvmmsg","","",N,N],[17,"SYS_fanotify_init","","",N,N],[17,"SYS_fanotify_mark","","",N,N],[17,"SYS_prlimit64","","",N,N],[17,"SYS_name_to_handle_at","","",N,N],[17,"SYS_open_by_handle_at","","",N,N],[17,"SYS_clock_adjtime","","",N,N],[17,"SYS_syncfs","","",N,N],[17,"SYS_sendmmsg","","",N,N],[17,"SYS_setns","","",N,N],[17,"SYS_getcpu","","",N,N],[17,"SYS_process_vm_readv","","",N,N],[17,"SYS_process_vm_writev","","",N,N],[17,"SYS_kcmp","","",N,N],[17,"SYS_finit_module","","",N,N],[17,"SYS_sched_setattr","","",N,N],[17,"SYS_sched_getattr","","",N,N],[17,"SYS_renameat2","","",N,N],[17,"SYS_seccomp","","",N,N],[17,"SYS_getrandom","","",N,N],[17,"SYS_memfd_create","","",N,N],[17,"SYS_kexec_file_load","","",N,N],[17,"SYS_bpf","","",N,N],[17,"SYS_execveat","","",N,N],[17,"SYS_userfaultfd","","",N,N],[17,"SYS_membarrier","","",N,N],[17,"SYS_mlock2","","",N,N],[17,"SYS_copy_file_range","","",N,N],[17,"SYS_preadv2","","",N,N],[17,"SYS_pwritev2","","",N,N],[17,"SYS_pkey_mprotect","","",N,N],[17,"SYS_pkey_alloc","","",N,N],[17,"SYS_pkey_free","","",N,N],[11,"try_from","","",127,[[["u"]],["result"]]],[11,"from","","",127,[[["t"]],["t"]]],[11,"try_into","","",127,[[["self"]],["result"]]],[11,"into","","",127,[[["self"]],["u"]]],[11,"borrow","","",127,[[["self"]],["t"]]],[11,"borrow_mut","","",127,[[["self"]],["t"]]],[11,"get_type_id","","",127,[[["self"]],["typeid"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"from","","",10,[[["t"]],["t"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"try_from","","",128,[[["u"]],["result"]]],[11,"from","","",128,[[["t"]],["t"]]],[11,"try_into","","",128,[[["self"]],["result"]]],[11,"into","","",128,[[["self"]],["u"]]],[11,"borrow","","",128,[[["self"]],["t"]]],[11,"borrow_mut","","",128,[[["self"]],["t"]]],[11,"get_type_id","","",128,[[["self"]],["typeid"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"from","","",27,[[["t"]],["t"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"from","","",28,[[["t"]],["t"]]],[11,"try_into","","",28,[[["self"]],["result"]]],[11,"into","","",28,[[["self"]],["u"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"get_type_id","","",28,[[["self"]],["typeid"]]],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"from","","",29,[[["t"]],["t"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"into","","",29,[[["self"]],["u"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"from","","",30,[[["t"]],["t"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"from","","",31,[[["t"]],["t"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"try_from","","",129,[[["u"]],["result"]]],[11,"from","","",129,[[["t"]],["t"]]],[11,"try_into","","",129,[[["self"]],["result"]]],[11,"into","","",129,[[["self"]],["u"]]],[11,"borrow","","",129,[[["self"]],["t"]]],[11,"borrow_mut","","",129,[[["self"]],["t"]]],[11,"get_type_id","","",129,[[["self"]],["typeid"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"from","","",32,[[["t"]],["t"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"from","","",33,[[["t"]],["t"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"from","","",34,[[["t"]],["t"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"from","","",35,[[["t"]],["t"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"from","","",36,[[["t"]],["t"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"from","","",37,[[["t"]],["t"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"from","","",38,[[["t"]],["t"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"from","","",39,[[["t"]],["t"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"from","","",40,[[["t"]],["t"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"from","","",41,[[["t"]],["t"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"from","","",42,[[["t"]],["t"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"from","","",43,[[["t"]],["t"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"from","","",44,[[["t"]],["t"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"from","","",45,[[["t"]],["t"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"from","","",46,[[["t"]],["t"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"from","","",47,[[["t"]],["t"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"into","","",47,[[["self"]],["u"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"try_from","","",130,[[["u"]],["result"]]],[11,"from","","",130,[[["t"]],["t"]]],[11,"try_into","","",130,[[["self"]],["result"]]],[11,"into","","",130,[[["self"]],["u"]]],[11,"borrow","","",130,[[["self"]],["t"]]],[11,"borrow_mut","","",130,[[["self"]],["t"]]],[11,"get_type_id","","",130,[[["self"]],["typeid"]]],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"from","","",48,[[["t"]],["t"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"into","","",48,[[["self"]],["u"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"from","","",49,[[["t"]],["t"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"try_from","","",131,[[["u"]],["result"]]],[11,"from","","",131,[[["t"]],["t"]]],[11,"try_into","","",131,[[["self"]],["result"]]],[11,"into","","",131,[[["self"]],["u"]]],[11,"borrow","","",131,[[["self"]],["t"]]],[11,"borrow_mut","","",131,[[["self"]],["t"]]],[11,"get_type_id","","",131,[[["self"]],["typeid"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"from","","",50,[[["t"]],["t"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"try_from","","",51,[[["u"]],["result"]]],[11,"from","","",51,[[["t"]],["t"]]],[11,"try_into","","",51,[[["self"]],["result"]]],[11,"into","","",51,[[["self"]],["u"]]],[11,"borrow","","",51,[[["self"]],["t"]]],[11,"borrow_mut","","",51,[[["self"]],["t"]]],[11,"get_type_id","","",51,[[["self"]],["typeid"]]],[11,"try_from","","",52,[[["u"]],["result"]]],[11,"from","","",52,[[["t"]],["t"]]],[11,"try_into","","",52,[[["self"]],["result"]]],[11,"into","","",52,[[["self"]],["u"]]],[11,"borrow","","",52,[[["self"]],["t"]]],[11,"borrow_mut","","",52,[[["self"]],["t"]]],[11,"get_type_id","","",52,[[["self"]],["typeid"]]],[11,"try_from","","",53,[[["u"]],["result"]]],[11,"from","","",53,[[["t"]],["t"]]],[11,"try_into","","",53,[[["self"]],["result"]]],[11,"into","","",53,[[["self"]],["u"]]],[11,"borrow","","",53,[[["self"]],["t"]]],[11,"borrow_mut","","",53,[[["self"]],["t"]]],[11,"get_type_id","","",53,[[["self"]],["typeid"]]],[11,"try_from","","",54,[[["u"]],["result"]]],[11,"from","","",54,[[["t"]],["t"]]],[11,"try_into","","",54,[[["self"]],["result"]]],[11,"into","","",54,[[["self"]],["u"]]],[11,"borrow","","",54,[[["self"]],["t"]]],[11,"borrow_mut","","",54,[[["self"]],["t"]]],[11,"get_type_id","","",54,[[["self"]],["typeid"]]],[11,"try_from","","",55,[[["u"]],["result"]]],[11,"from","","",55,[[["t"]],["t"]]],[11,"try_into","","",55,[[["self"]],["result"]]],[11,"into","","",55,[[["self"]],["u"]]],[11,"borrow","","",55,[[["self"]],["t"]]],[11,"borrow_mut","","",55,[[["self"]],["t"]]],[11,"get_type_id","","",55,[[["self"]],["typeid"]]],[11,"try_from","","",56,[[["u"]],["result"]]],[11,"from","","",56,[[["t"]],["t"]]],[11,"try_into","","",56,[[["self"]],["result"]]],[11,"into","","",56,[[["self"]],["u"]]],[11,"borrow","","",56,[[["self"]],["t"]]],[11,"borrow_mut","","",56,[[["self"]],["t"]]],[11,"get_type_id","","",56,[[["self"]],["typeid"]]],[11,"try_from","","",57,[[["u"]],["result"]]],[11,"from","","",57,[[["t"]],["t"]]],[11,"try_into","","",57,[[["self"]],["result"]]],[11,"into","","",57,[[["self"]],["u"]]],[11,"borrow","","",57,[[["self"]],["t"]]],[11,"borrow_mut","","",57,[[["self"]],["t"]]],[11,"get_type_id","","",57,[[["self"]],["typeid"]]],[11,"try_from","","",58,[[["u"]],["result"]]],[11,"from","","",58,[[["t"]],["t"]]],[11,"try_into","","",58,[[["self"]],["result"]]],[11,"into","","",58,[[["self"]],["u"]]],[11,"borrow","","",58,[[["self"]],["t"]]],[11,"borrow_mut","","",58,[[["self"]],["t"]]],[11,"get_type_id","","",58,[[["self"]],["typeid"]]],[11,"try_from","","",59,[[["u"]],["result"]]],[11,"from","","",59,[[["t"]],["t"]]],[11,"try_into","","",59,[[["self"]],["result"]]],[11,"into","","",59,[[["self"]],["u"]]],[11,"borrow","","",59,[[["self"]],["t"]]],[11,"borrow_mut","","",59,[[["self"]],["t"]]],[11,"get_type_id","","",59,[[["self"]],["typeid"]]],[11,"try_from","","",60,[[["u"]],["result"]]],[11,"from","","",60,[[["t"]],["t"]]],[11,"try_into","","",60,[[["self"]],["result"]]],[11,"into","","",60,[[["self"]],["u"]]],[11,"borrow","","",60,[[["self"]],["t"]]],[11,"borrow_mut","","",60,[[["self"]],["t"]]],[11,"get_type_id","","",60,[[["self"]],["typeid"]]],[11,"try_from","","",61,[[["u"]],["result"]]],[11,"from","","",61,[[["t"]],["t"]]],[11,"try_into","","",61,[[["self"]],["result"]]],[11,"into","","",61,[[["self"]],["u"]]],[11,"borrow","","",61,[[["self"]],["t"]]],[11,"borrow_mut","","",61,[[["self"]],["t"]]],[11,"get_type_id","","",61,[[["self"]],["typeid"]]],[11,"try_from","","",62,[[["u"]],["result"]]],[11,"from","","",62,[[["t"]],["t"]]],[11,"try_into","","",62,[[["self"]],["result"]]],[11,"into","","",62,[[["self"]],["u"]]],[11,"borrow","","",62,[[["self"]],["t"]]],[11,"borrow_mut","","",62,[[["self"]],["t"]]],[11,"get_type_id","","",62,[[["self"]],["typeid"]]],[11,"try_from","","",63,[[["u"]],["result"]]],[11,"from","","",63,[[["t"]],["t"]]],[11,"try_into","","",63,[[["self"]],["result"]]],[11,"into","","",63,[[["self"]],["u"]]],[11,"borrow","","",63,[[["self"]],["t"]]],[11,"borrow_mut","","",63,[[["self"]],["t"]]],[11,"get_type_id","","",63,[[["self"]],["typeid"]]],[11,"try_from","","",64,[[["u"]],["result"]]],[11,"from","","",64,[[["t"]],["t"]]],[11,"try_into","","",64,[[["self"]],["result"]]],[11,"into","","",64,[[["self"]],["u"]]],[11,"borrow","","",64,[[["self"]],["t"]]],[11,"borrow_mut","","",64,[[["self"]],["t"]]],[11,"get_type_id","","",64,[[["self"]],["typeid"]]],[11,"try_from","","",65,[[["u"]],["result"]]],[11,"from","","",65,[[["t"]],["t"]]],[11,"try_into","","",65,[[["self"]],["result"]]],[11,"into","","",65,[[["self"]],["u"]]],[11,"borrow","","",65,[[["self"]],["t"]]],[11,"borrow_mut","","",65,[[["self"]],["t"]]],[11,"get_type_id","","",65,[[["self"]],["typeid"]]],[11,"try_from","","",66,[[["u"]],["result"]]],[11,"from","","",66,[[["t"]],["t"]]],[11,"try_into","","",66,[[["self"]],["result"]]],[11,"into","","",66,[[["self"]],["u"]]],[11,"borrow","","",66,[[["self"]],["t"]]],[11,"borrow_mut","","",66,[[["self"]],["t"]]],[11,"get_type_id","","",66,[[["self"]],["typeid"]]],[11,"try_from","","",67,[[["u"]],["result"]]],[11,"from","","",67,[[["t"]],["t"]]],[11,"try_into","","",67,[[["self"]],["result"]]],[11,"into","","",67,[[["self"]],["u"]]],[11,"borrow","","",67,[[["self"]],["t"]]],[11,"borrow_mut","","",67,[[["self"]],["t"]]],[11,"get_type_id","","",67,[[["self"]],["typeid"]]],[11,"try_from","","",68,[[["u"]],["result"]]],[11,"from","","",68,[[["t"]],["t"]]],[11,"try_into","","",68,[[["self"]],["result"]]],[11,"into","","",68,[[["self"]],["u"]]],[11,"borrow","","",68,[[["self"]],["t"]]],[11,"borrow_mut","","",68,[[["self"]],["t"]]],[11,"get_type_id","","",68,[[["self"]],["typeid"]]],[11,"try_from","","",69,[[["u"]],["result"]]],[11,"from","","",69,[[["t"]],["t"]]],[11,"try_into","","",69,[[["self"]],["result"]]],[11,"into","","",69,[[["self"]],["u"]]],[11,"borrow","","",69,[[["self"]],["t"]]],[11,"borrow_mut","","",69,[[["self"]],["t"]]],[11,"get_type_id","","",69,[[["self"]],["typeid"]]],[11,"try_from","","",70,[[["u"]],["result"]]],[11,"from","","",70,[[["t"]],["t"]]],[11,"try_into","","",70,[[["self"]],["result"]]],[11,"into","","",70,[[["self"]],["u"]]],[11,"borrow","","",70,[[["self"]],["t"]]],[11,"borrow_mut","","",70,[[["self"]],["t"]]],[11,"get_type_id","","",70,[[["self"]],["typeid"]]],[11,"try_from","","",71,[[["u"]],["result"]]],[11,"from","","",71,[[["t"]],["t"]]],[11,"try_into","","",71,[[["self"]],["result"]]],[11,"into","","",71,[[["self"]],["u"]]],[11,"borrow","","",71,[[["self"]],["t"]]],[11,"borrow_mut","","",71,[[["self"]],["t"]]],[11,"get_type_id","","",71,[[["self"]],["typeid"]]],[11,"try_from","","",72,[[["u"]],["result"]]],[11,"from","","",72,[[["t"]],["t"]]],[11,"try_into","","",72,[[["self"]],["result"]]],[11,"into","","",72,[[["self"]],["u"]]],[11,"borrow","","",72,[[["self"]],["t"]]],[11,"borrow_mut","","",72,[[["self"]],["t"]]],[11,"get_type_id","","",72,[[["self"]],["typeid"]]],[11,"try_from","","",73,[[["u"]],["result"]]],[11,"from","","",73,[[["t"]],["t"]]],[11,"try_into","","",73,[[["self"]],["result"]]],[11,"into","","",73,[[["self"]],["u"]]],[11,"borrow","","",73,[[["self"]],["t"]]],[11,"borrow_mut","","",73,[[["self"]],["t"]]],[11,"get_type_id","","",73,[[["self"]],["typeid"]]],[11,"try_from","","",74,[[["u"]],["result"]]],[11,"from","","",74,[[["t"]],["t"]]],[11,"try_into","","",74,[[["self"]],["result"]]],[11,"into","","",74,[[["self"]],["u"]]],[11,"borrow","","",74,[[["self"]],["t"]]],[11,"borrow_mut","","",74,[[["self"]],["t"]]],[11,"get_type_id","","",74,[[["self"]],["typeid"]]],[11,"try_from","","",75,[[["u"]],["result"]]],[11,"from","","",75,[[["t"]],["t"]]],[11,"try_into","","",75,[[["self"]],["result"]]],[11,"into","","",75,[[["self"]],["u"]]],[11,"borrow","","",75,[[["self"]],["t"]]],[11,"borrow_mut","","",75,[[["self"]],["t"]]],[11,"get_type_id","","",75,[[["self"]],["typeid"]]],[11,"try_from","","",76,[[["u"]],["result"]]],[11,"from","","",76,[[["t"]],["t"]]],[11,"try_into","","",76,[[["self"]],["result"]]],[11,"into","","",76,[[["self"]],["u"]]],[11,"borrow","","",76,[[["self"]],["t"]]],[11,"borrow_mut","","",76,[[["self"]],["t"]]],[11,"get_type_id","","",76,[[["self"]],["typeid"]]],[11,"try_from","","",77,[[["u"]],["result"]]],[11,"from","","",77,[[["t"]],["t"]]],[11,"try_into","","",77,[[["self"]],["result"]]],[11,"into","","",77,[[["self"]],["u"]]],[11,"borrow","","",77,[[["self"]],["t"]]],[11,"borrow_mut","","",77,[[["self"]],["t"]]],[11,"get_type_id","","",77,[[["self"]],["typeid"]]],[11,"try_from","","",78,[[["u"]],["result"]]],[11,"from","","",78,[[["t"]],["t"]]],[11,"try_into","","",78,[[["self"]],["result"]]],[11,"into","","",78,[[["self"]],["u"]]],[11,"borrow","","",78,[[["self"]],["t"]]],[11,"borrow_mut","","",78,[[["self"]],["t"]]],[11,"get_type_id","","",78,[[["self"]],["typeid"]]],[11,"try_from","","",79,[[["u"]],["result"]]],[11,"from","","",79,[[["t"]],["t"]]],[11,"try_into","","",79,[[["self"]],["result"]]],[11,"into","","",79,[[["self"]],["u"]]],[11,"borrow","","",79,[[["self"]],["t"]]],[11,"borrow_mut","","",79,[[["self"]],["t"]]],[11,"get_type_id","","",79,[[["self"]],["typeid"]]],[11,"try_from","","",132,[[["u"]],["result"]]],[11,"from","","",132,[[["t"]],["t"]]],[11,"try_into","","",132,[[["self"]],["result"]]],[11,"into","","",132,[[["self"]],["u"]]],[11,"borrow","","",132,[[["self"]],["t"]]],[11,"borrow_mut","","",132,[[["self"]],["t"]]],[11,"get_type_id","","",132,[[["self"]],["typeid"]]],[11,"try_from","","",133,[[["u"]],["result"]]],[11,"from","","",133,[[["t"]],["t"]]],[11,"try_into","","",133,[[["self"]],["result"]]],[11,"into","","",133,[[["self"]],["u"]]],[11,"borrow","","",133,[[["self"]],["t"]]],[11,"borrow_mut","","",133,[[["self"]],["t"]]],[11,"get_type_id","","",133,[[["self"]],["typeid"]]],[11,"try_from","","",80,[[["u"]],["result"]]],[11,"from","","",80,[[["t"]],["t"]]],[11,"try_into","","",80,[[["self"]],["result"]]],[11,"into","","",80,[[["self"]],["u"]]],[11,"borrow","","",80,[[["self"]],["t"]]],[11,"borrow_mut","","",80,[[["self"]],["t"]]],[11,"get_type_id","","",80,[[["self"]],["typeid"]]],[11,"try_from","","",81,[[["u"]],["result"]]],[11,"from","","",81,[[["t"]],["t"]]],[11,"try_into","","",81,[[["self"]],["result"]]],[11,"into","","",81,[[["self"]],["u"]]],[11,"borrow","","",81,[[["self"]],["t"]]],[11,"borrow_mut","","",81,[[["self"]],["t"]]],[11,"get_type_id","","",81,[[["self"]],["typeid"]]],[11,"try_from","","",82,[[["u"]],["result"]]],[11,"from","","",82,[[["t"]],["t"]]],[11,"try_into","","",82,[[["self"]],["result"]]],[11,"into","","",82,[[["self"]],["u"]]],[11,"borrow","","",82,[[["self"]],["t"]]],[11,"borrow_mut","","",82,[[["self"]],["t"]]],[11,"get_type_id","","",82,[[["self"]],["typeid"]]],[11,"try_from","","",83,[[["u"]],["result"]]],[11,"from","","",83,[[["t"]],["t"]]],[11,"try_into","","",83,[[["self"]],["result"]]],[11,"into","","",83,[[["self"]],["u"]]],[11,"borrow","","",83,[[["self"]],["t"]]],[11,"borrow_mut","","",83,[[["self"]],["t"]]],[11,"get_type_id","","",83,[[["self"]],["typeid"]]],[11,"try_from","","",84,[[["u"]],["result"]]],[11,"from","","",84,[[["t"]],["t"]]],[11,"try_into","","",84,[[["self"]],["result"]]],[11,"into","","",84,[[["self"]],["u"]]],[11,"borrow","","",84,[[["self"]],["t"]]],[11,"borrow_mut","","",84,[[["self"]],["t"]]],[11,"get_type_id","","",84,[[["self"]],["typeid"]]],[11,"try_from","","",85,[[["u"]],["result"]]],[11,"from","","",85,[[["t"]],["t"]]],[11,"try_into","","",85,[[["self"]],["result"]]],[11,"into","","",85,[[["self"]],["u"]]],[11,"borrow","","",85,[[["self"]],["t"]]],[11,"borrow_mut","","",85,[[["self"]],["t"]]],[11,"get_type_id","","",85,[[["self"]],["typeid"]]],[11,"try_from","","",86,[[["u"]],["result"]]],[11,"from","","",86,[[["t"]],["t"]]],[11,"try_into","","",86,[[["self"]],["result"]]],[11,"into","","",86,[[["self"]],["u"]]],[11,"borrow","","",86,[[["self"]],["t"]]],[11,"borrow_mut","","",86,[[["self"]],["t"]]],[11,"get_type_id","","",86,[[["self"]],["typeid"]]],[11,"try_from","","",87,[[["u"]],["result"]]],[11,"from","","",87,[[["t"]],["t"]]],[11,"try_into","","",87,[[["self"]],["result"]]],[11,"into","","",87,[[["self"]],["u"]]],[11,"borrow","","",87,[[["self"]],["t"]]],[11,"borrow_mut","","",87,[[["self"]],["t"]]],[11,"get_type_id","","",87,[[["self"]],["typeid"]]],[11,"try_from","","",88,[[["u"]],["result"]]],[11,"from","","",88,[[["t"]],["t"]]],[11,"try_into","","",88,[[["self"]],["result"]]],[11,"into","","",88,[[["self"]],["u"]]],[11,"borrow","","",88,[[["self"]],["t"]]],[11,"borrow_mut","","",88,[[["self"]],["t"]]],[11,"get_type_id","","",88,[[["self"]],["typeid"]]],[11,"try_from","","",89,[[["u"]],["result"]]],[11,"from","","",89,[[["t"]],["t"]]],[11,"try_into","","",89,[[["self"]],["result"]]],[11,"into","","",89,[[["self"]],["u"]]],[11,"borrow","","",89,[[["self"]],["t"]]],[11,"borrow_mut","","",89,[[["self"]],["t"]]],[11,"get_type_id","","",89,[[["self"]],["typeid"]]],[11,"try_from","","",90,[[["u"]],["result"]]],[11,"from","","",90,[[["t"]],["t"]]],[11,"try_into","","",90,[[["self"]],["result"]]],[11,"into","","",90,[[["self"]],["u"]]],[11,"borrow","","",90,[[["self"]],["t"]]],[11,"borrow_mut","","",90,[[["self"]],["t"]]],[11,"get_type_id","","",90,[[["self"]],["typeid"]]],[11,"try_from","","",91,[[["u"]],["result"]]],[11,"from","","",91,[[["t"]],["t"]]],[11,"try_into","","",91,[[["self"]],["result"]]],[11,"into","","",91,[[["self"]],["u"]]],[11,"borrow","","",91,[[["self"]],["t"]]],[11,"borrow_mut","","",91,[[["self"]],["t"]]],[11,"get_type_id","","",91,[[["self"]],["typeid"]]],[11,"try_from","","",92,[[["u"]],["result"]]],[11,"from","","",92,[[["t"]],["t"]]],[11,"try_into","","",92,[[["self"]],["result"]]],[11,"into","","",92,[[["self"]],["u"]]],[11,"borrow","","",92,[[["self"]],["t"]]],[11,"borrow_mut","","",92,[[["self"]],["t"]]],[11,"get_type_id","","",92,[[["self"]],["typeid"]]],[11,"try_from","","",93,[[["u"]],["result"]]],[11,"from","","",93,[[["t"]],["t"]]],[11,"try_into","","",93,[[["self"]],["result"]]],[11,"into","","",93,[[["self"]],["u"]]],[11,"borrow","","",93,[[["self"]],["t"]]],[11,"borrow_mut","","",93,[[["self"]],["t"]]],[11,"get_type_id","","",93,[[["self"]],["typeid"]]],[11,"try_from","","",94,[[["u"]],["result"]]],[11,"from","","",94,[[["t"]],["t"]]],[11,"try_into","","",94,[[["self"]],["result"]]],[11,"into","","",94,[[["self"]],["u"]]],[11,"borrow","","",94,[[["self"]],["t"]]],[11,"borrow_mut","","",94,[[["self"]],["t"]]],[11,"get_type_id","","",94,[[["self"]],["typeid"]]],[11,"try_from","","",95,[[["u"]],["result"]]],[11,"from","","",95,[[["t"]],["t"]]],[11,"try_into","","",95,[[["self"]],["result"]]],[11,"into","","",95,[[["self"]],["u"]]],[11,"borrow","","",95,[[["self"]],["t"]]],[11,"borrow_mut","","",95,[[["self"]],["t"]]],[11,"get_type_id","","",95,[[["self"]],["typeid"]]],[11,"try_from","","",96,[[["u"]],["result"]]],[11,"from","","",96,[[["t"]],["t"]]],[11,"try_into","","",96,[[["self"]],["result"]]],[11,"into","","",96,[[["self"]],["u"]]],[11,"borrow","","",96,[[["self"]],["t"]]],[11,"borrow_mut","","",96,[[["self"]],["t"]]],[11,"get_type_id","","",96,[[["self"]],["typeid"]]],[11,"try_from","","",97,[[["u"]],["result"]]],[11,"from","","",97,[[["t"]],["t"]]],[11,"try_into","","",97,[[["self"]],["result"]]],[11,"into","","",97,[[["self"]],["u"]]],[11,"borrow","","",97,[[["self"]],["t"]]],[11,"borrow_mut","","",97,[[["self"]],["t"]]],[11,"get_type_id","","",97,[[["self"]],["typeid"]]],[11,"try_from","","",98,[[["u"]],["result"]]],[11,"from","","",98,[[["t"]],["t"]]],[11,"try_into","","",98,[[["self"]],["result"]]],[11,"into","","",98,[[["self"]],["u"]]],[11,"borrow","","",98,[[["self"]],["t"]]],[11,"borrow_mut","","",98,[[["self"]],["t"]]],[11,"get_type_id","","",98,[[["self"]],["typeid"]]],[11,"try_from","","",99,[[["u"]],["result"]]],[11,"from","","",99,[[["t"]],["t"]]],[11,"try_into","","",99,[[["self"]],["result"]]],[11,"into","","",99,[[["self"]],["u"]]],[11,"borrow","","",99,[[["self"]],["t"]]],[11,"borrow_mut","","",99,[[["self"]],["t"]]],[11,"get_type_id","","",99,[[["self"]],["typeid"]]],[11,"try_from","","",100,[[["u"]],["result"]]],[11,"from","","",100,[[["t"]],["t"]]],[11,"try_into","","",100,[[["self"]],["result"]]],[11,"into","","",100,[[["self"]],["u"]]],[11,"borrow","","",100,[[["self"]],["t"]]],[11,"borrow_mut","","",100,[[["self"]],["t"]]],[11,"get_type_id","","",100,[[["self"]],["typeid"]]],[11,"try_from","","",101,[[["u"]],["result"]]],[11,"from","","",101,[[["t"]],["t"]]],[11,"try_into","","",101,[[["self"]],["result"]]],[11,"into","","",101,[[["self"]],["u"]]],[11,"borrow","","",101,[[["self"]],["t"]]],[11,"borrow_mut","","",101,[[["self"]],["t"]]],[11,"get_type_id","","",101,[[["self"]],["typeid"]]],[11,"try_from","","",102,[[["u"]],["result"]]],[11,"from","","",102,[[["t"]],["t"]]],[11,"try_into","","",102,[[["self"]],["result"]]],[11,"into","","",102,[[["self"]],["u"]]],[11,"borrow","","",102,[[["self"]],["t"]]],[11,"borrow_mut","","",102,[[["self"]],["t"]]],[11,"get_type_id","","",102,[[["self"]],["typeid"]]],[11,"try_from","","",103,[[["u"]],["result"]]],[11,"from","","",103,[[["t"]],["t"]]],[11,"try_into","","",103,[[["self"]],["result"]]],[11,"into","","",103,[[["self"]],["u"]]],[11,"borrow","","",103,[[["self"]],["t"]]],[11,"borrow_mut","","",103,[[["self"]],["t"]]],[11,"get_type_id","","",103,[[["self"]],["typeid"]]],[11,"try_from","","",104,[[["u"]],["result"]]],[11,"from","","",104,[[["t"]],["t"]]],[11,"try_into","","",104,[[["self"]],["result"]]],[11,"into","","",104,[[["self"]],["u"]]],[11,"borrow","","",104,[[["self"]],["t"]]],[11,"borrow_mut","","",104,[[["self"]],["t"]]],[11,"get_type_id","","",104,[[["self"]],["typeid"]]],[11,"try_from","","",105,[[["u"]],["result"]]],[11,"from","","",105,[[["t"]],["t"]]],[11,"try_into","","",105,[[["self"]],["result"]]],[11,"into","","",105,[[["self"]],["u"]]],[11,"borrow","","",105,[[["self"]],["t"]]],[11,"borrow_mut","","",105,[[["self"]],["t"]]],[11,"get_type_id","","",105,[[["self"]],["typeid"]]],[11,"try_from","","",106,[[["u"]],["result"]]],[11,"from","","",106,[[["t"]],["t"]]],[11,"try_into","","",106,[[["self"]],["result"]]],[11,"into","","",106,[[["self"]],["u"]]],[11,"borrow","","",106,[[["self"]],["t"]]],[11,"borrow_mut","","",106,[[["self"]],["t"]]],[11,"get_type_id","","",106,[[["self"]],["typeid"]]],[11,"try_from","","",107,[[["u"]],["result"]]],[11,"from","","",107,[[["t"]],["t"]]],[11,"try_into","","",107,[[["self"]],["result"]]],[11,"into","","",107,[[["self"]],["u"]]],[11,"borrow","","",107,[[["self"]],["t"]]],[11,"borrow_mut","","",107,[[["self"]],["t"]]],[11,"get_type_id","","",107,[[["self"]],["typeid"]]],[11,"try_from","","",134,[[["u"]],["result"]]],[11,"from","","",134,[[["t"]],["t"]]],[11,"try_into","","",134,[[["self"]],["result"]]],[11,"into","","",134,[[["self"]],["u"]]],[11,"borrow","","",134,[[["self"]],["t"]]],[11,"borrow_mut","","",134,[[["self"]],["t"]]],[11,"get_type_id","","",134,[[["self"]],["typeid"]]],[11,"try_from","","",108,[[["u"]],["result"]]],[11,"from","","",108,[[["t"]],["t"]]],[11,"try_into","","",108,[[["self"]],["result"]]],[11,"into","","",108,[[["self"]],["u"]]],[11,"borrow","","",108,[[["self"]],["t"]]],[11,"borrow_mut","","",108,[[["self"]],["t"]]],[11,"get_type_id","","",108,[[["self"]],["typeid"]]],[11,"try_from","","",109,[[["u"]],["result"]]],[11,"from","","",109,[[["t"]],["t"]]],[11,"try_into","","",109,[[["self"]],["result"]]],[11,"into","","",109,[[["self"]],["u"]]],[11,"borrow","","",109,[[["self"]],["t"]]],[11,"borrow_mut","","",109,[[["self"]],["t"]]],[11,"get_type_id","","",109,[[["self"]],["typeid"]]],[11,"try_from","","",110,[[["u"]],["result"]]],[11,"from","","",110,[[["t"]],["t"]]],[11,"try_into","","",110,[[["self"]],["result"]]],[11,"into","","",110,[[["self"]],["u"]]],[11,"borrow","","",110,[[["self"]],["t"]]],[11,"borrow_mut","","",110,[[["self"]],["t"]]],[11,"get_type_id","","",110,[[["self"]],["typeid"]]],[11,"try_from","","",111,[[["u"]],["result"]]],[11,"from","","",111,[[["t"]],["t"]]],[11,"try_into","","",111,[[["self"]],["result"]]],[11,"into","","",111,[[["self"]],["u"]]],[11,"borrow","","",111,[[["self"]],["t"]]],[11,"borrow_mut","","",111,[[["self"]],["t"]]],[11,"get_type_id","","",111,[[["self"]],["typeid"]]],[11,"try_from","","",112,[[["u"]],["result"]]],[11,"from","","",112,[[["t"]],["t"]]],[11,"try_into","","",112,[[["self"]],["result"]]],[11,"into","","",112,[[["self"]],["u"]]],[11,"borrow","","",112,[[["self"]],["t"]]],[11,"borrow_mut","","",112,[[["self"]],["t"]]],[11,"get_type_id","","",112,[[["self"]],["typeid"]]],[11,"try_from","","",113,[[["u"]],["result"]]],[11,"from","","",113,[[["t"]],["t"]]],[11,"try_into","","",113,[[["self"]],["result"]]],[11,"into","","",113,[[["self"]],["u"]]],[11,"borrow","","",113,[[["self"]],["t"]]],[11,"borrow_mut","","",113,[[["self"]],["t"]]],[11,"get_type_id","","",113,[[["self"]],["typeid"]]],[11,"try_from","","",135,[[["u"]],["result"]]],[11,"from","","",135,[[["t"]],["t"]]],[11,"try_into","","",135,[[["self"]],["result"]]],[11,"into","","",135,[[["self"]],["u"]]],[11,"borrow","","",135,[[["self"]],["t"]]],[11,"borrow_mut","","",135,[[["self"]],["t"]]],[11,"get_type_id","","",135,[[["self"]],["typeid"]]],[11,"try_from","","",114,[[["u"]],["result"]]],[11,"from","","",114,[[["t"]],["t"]]],[11,"try_into","","",114,[[["self"]],["result"]]],[11,"into","","",114,[[["self"]],["u"]]],[11,"borrow","","",114,[[["self"]],["t"]]],[11,"borrow_mut","","",114,[[["self"]],["t"]]],[11,"get_type_id","","",114,[[["self"]],["typeid"]]],[11,"try_from","","",115,[[["u"]],["result"]]],[11,"from","","",115,[[["t"]],["t"]]],[11,"try_into","","",115,[[["self"]],["result"]]],[11,"into","","",115,[[["self"]],["u"]]],[11,"borrow","","",115,[[["self"]],["t"]]],[11,"borrow_mut","","",115,[[["self"]],["t"]]],[11,"get_type_id","","",115,[[["self"]],["typeid"]]],[11,"try_from","","",116,[[["u"]],["result"]]],[11,"from","","",116,[[["t"]],["t"]]],[11,"try_into","","",116,[[["self"]],["result"]]],[11,"into","","",116,[[["self"]],["u"]]],[11,"borrow","","",116,[[["self"]],["t"]]],[11,"borrow_mut","","",116,[[["self"]],["t"]]],[11,"get_type_id","","",116,[[["self"]],["typeid"]]],[11,"try_from","","",117,[[["u"]],["result"]]],[11,"from","","",117,[[["t"]],["t"]]],[11,"try_into","","",117,[[["self"]],["result"]]],[11,"into","","",117,[[["self"]],["u"]]],[11,"borrow","","",117,[[["self"]],["t"]]],[11,"borrow_mut","","",117,[[["self"]],["t"]]],[11,"get_type_id","","",117,[[["self"]],["typeid"]]],[11,"try_from","","",118,[[["u"]],["result"]]],[11,"from","","",118,[[["t"]],["t"]]],[11,"try_into","","",118,[[["self"]],["result"]]],[11,"into","","",118,[[["self"]],["u"]]],[11,"borrow","","",118,[[["self"]],["t"]]],[11,"borrow_mut","","",118,[[["self"]],["t"]]],[11,"get_type_id","","",118,[[["self"]],["typeid"]]],[11,"try_from","","",119,[[["u"]],["result"]]],[11,"from","","",119,[[["t"]],["t"]]],[11,"try_into","","",119,[[["self"]],["result"]]],[11,"into","","",119,[[["self"]],["u"]]],[11,"borrow","","",119,[[["self"]],["t"]]],[11,"borrow_mut","","",119,[[["self"]],["t"]]],[11,"get_type_id","","",119,[[["self"]],["typeid"]]],[11,"try_from","","",120,[[["u"]],["result"]]],[11,"from","","",120,[[["t"]],["t"]]],[11,"try_into","","",120,[[["self"]],["result"]]],[11,"into","","",120,[[["self"]],["u"]]],[11,"borrow","","",120,[[["self"]],["t"]]],[11,"borrow_mut","","",120,[[["self"]],["t"]]],[11,"get_type_id","","",120,[[["self"]],["typeid"]]],[11,"try_from","","",121,[[["u"]],["result"]]],[11,"from","","",121,[[["t"]],["t"]]],[11,"try_into","","",121,[[["self"]],["result"]]],[11,"into","","",121,[[["self"]],["u"]]],[11,"borrow","","",121,[[["self"]],["t"]]],[11,"borrow_mut","","",121,[[["self"]],["t"]]],[11,"get_type_id","","",121,[[["self"]],["typeid"]]],[11,"try_from","","",122,[[["u"]],["result"]]],[11,"from","","",122,[[["t"]],["t"]]],[11,"try_into","","",122,[[["self"]],["result"]]],[11,"into","","",122,[[["self"]],["u"]]],[11,"borrow","","",122,[[["self"]],["t"]]],[11,"borrow_mut","","",122,[[["self"]],["t"]]],[11,"get_type_id","","",122,[[["self"]],["typeid"]]],[11,"try_from","","",123,[[["u"]],["result"]]],[11,"from","","",123,[[["t"]],["t"]]],[11,"try_into","","",123,[[["self"]],["result"]]],[11,"into","","",123,[[["self"]],["u"]]],[11,"borrow","","",123,[[["self"]],["t"]]],[11,"borrow_mut","","",123,[[["self"]],["t"]]],[11,"get_type_id","","",123,[[["self"]],["typeid"]]],[11,"try_from","","",124,[[["u"]],["result"]]],[11,"from","","",124,[[["t"]],["t"]]],[11,"try_into","","",124,[[["self"]],["result"]]],[11,"into","","",124,[[["self"]],["u"]]],[11,"borrow","","",124,[[["self"]],["t"]]],[11,"borrow_mut","","",124,[[["self"]],["t"]]],[11,"get_type_id","","",124,[[["self"]],["typeid"]]],[11,"try_from","","",125,[[["u"]],["result"]]],[11,"from","","",125,[[["t"]],["t"]]],[11,"try_into","","",125,[[["self"]],["result"]]],[11,"into","","",125,[[["self"]],["u"]]],[11,"borrow","","",125,[[["self"]],["t"]]],[11,"borrow_mut","","",125,[[["self"]],["t"]]],[11,"get_type_id","","",125,[[["self"]],["typeid"]]],[11,"try_from","","",136,[[["u"]],["result"]]],[11,"from","","",136,[[["t"]],["t"]]],[11,"try_into","","",136,[[["self"]],["result"]]],[11,"into","","",136,[[["self"]],["u"]]],[11,"borrow","","",136,[[["self"]],["t"]]],[11,"borrow_mut","","",136,[[["self"]],["t"]]],[11,"get_type_id","","",136,[[["self"]],["typeid"]]],[11,"try_from","","",137,[[["u"]],["result"]]],[11,"from","","",137,[[["t"]],["t"]]],[11,"try_into","","",137,[[["self"]],["result"]]],[11,"into","","",137,[[["self"]],["u"]]],[11,"borrow","","",137,[[["self"]],["t"]]],[11,"borrow_mut","","",137,[[["self"]],["t"]]],[11,"get_type_id","","",137,[[["self"]],["typeid"]]],[11,"try_from","","",138,[[["u"]],["result"]]],[11,"from","","",138,[[["t"]],["t"]]],[11,"try_into","","",138,[[["self"]],["result"]]],[11,"into","","",138,[[["self"]],["u"]]],[11,"borrow","","",138,[[["self"]],["t"]]],[11,"borrow_mut","","",138,[[["self"]],["t"]]],[11,"get_type_id","","",138,[[["self"]],["typeid"]]],[11,"try_from","","",139,[[["u"]],["result"]]],[11,"from","","",139,[[["t"]],["t"]]],[11,"try_into","","",139,[[["self"]],["result"]]],[11,"into","","",139,[[["self"]],["u"]]],[11,"borrow","","",139,[[["self"]],["t"]]],[11,"borrow_mut","","",139,[[["self"]],["t"]]],[11,"get_type_id","","",139,[[["self"]],["typeid"]]],[11,"try_from","","",140,[[["u"]],["result"]]],[11,"from","","",140,[[["t"]],["t"]]],[11,"try_into","","",140,[[["self"]],["result"]]],[11,"into","","",140,[[["self"]],["u"]]],[11,"borrow","","",140,[[["self"]],["t"]]],[11,"borrow_mut","","",140,[[["self"]],["t"]]],[11,"get_type_id","","",140,[[["self"]],["typeid"]]],[11,"try_from","","",141,[[["u"]],["result"]]],[11,"from","","",141,[[["t"]],["t"]]],[11,"try_into","","",141,[[["self"]],["result"]]],[11,"into","","",141,[[["self"]],["u"]]],[11,"borrow","","",141,[[["self"]],["t"]]],[11,"borrow_mut","","",141,[[["self"]],["t"]]],[11,"get_type_id","","",141,[[["self"]],["typeid"]]],[11,"try_from","","",142,[[["u"]],["result"]]],[11,"from","","",142,[[["t"]],["t"]]],[11,"try_into","","",142,[[["self"]],["result"]]],[11,"into","","",142,[[["self"]],["u"]]],[11,"borrow","","",142,[[["self"]],["t"]]],[11,"borrow_mut","","",142,[[["self"]],["t"]]],[11,"get_type_id","","",142,[[["self"]],["typeid"]]],[11,"try_from","","",126,[[["u"]],["result"]]],[11,"from","","",126,[[["t"]],["t"]]],[11,"try_into","","",126,[[["self"]],["result"]]],[11,"into","","",126,[[["self"]],["u"]]],[11,"borrow","","",126,[[["self"]],["t"]]],[11,"borrow_mut","","",126,[[["self"]],["t"]]],[11,"get_type_id","","",126,[[["self"]],["typeid"]]],[11,"try_from","","",143,[[["u"]],["result"]]],[11,"from","","",143,[[["t"]],["t"]]],[11,"try_into","","",143,[[["self"]],["result"]]],[11,"into","","",143,[[["self"]],["u"]]],[11,"borrow","","",143,[[["self"]],["t"]]],[11,"borrow_mut","","",143,[[["self"]],["t"]]],[11,"get_type_id","","",143,[[["self"]],["typeid"]]],[11,"try_from","","",144,[[["u"]],["result"]]],[11,"from","","",144,[[["t"]],["t"]]],[11,"try_into","","",144,[[["self"]],["result"]]],[11,"into","","",144,[[["self"]],["u"]]],[11,"borrow","","",144,[[["self"]],["t"]]],[11,"borrow_mut","","",144,[[["self"]],["t"]]],[11,"get_type_id","","",144,[[["self"]],["typeid"]]],[11,"try_from","","",145,[[["u"]],["result"]]],[11,"from","","",145,[[["t"]],["t"]]],[11,"try_into","","",145,[[["self"]],["result"]]],[11,"into","","",145,[[["self"]],["u"]]],[11,"borrow","","",145,[[["self"]],["t"]]],[11,"borrow_mut","","",145,[[["self"]],["t"]]],[11,"get_type_id","","",145,[[["self"]],["typeid"]]],[11,"try_from","","",146,[[["u"]],["result"]]],[11,"from","","",146,[[["t"]],["t"]]],[11,"try_into","","",146,[[["self"]],["result"]]],[11,"into","","",146,[[["self"]],["u"]]],[11,"borrow","","",146,[[["self"]],["t"]]],[11,"borrow_mut","","",146,[[["self"]],["t"]]],[11,"get_type_id","","",146,[[["self"]],["typeid"]]],[11,"try_from","","",147,[[["u"]],["result"]]],[11,"from","","",147,[[["t"]],["t"]]],[11,"try_into","","",147,[[["self"]],["result"]]],[11,"into","","",147,[[["self"]],["u"]]],[11,"borrow","","",147,[[["self"]],["t"]]],[11,"borrow_mut","","",147,[[["self"]],["t"]]],[11,"get_type_id","","",147,[[["self"]],["typeid"]]],[11,"try_from","","",148,[[["u"]],["result"]]],[11,"from","","",148,[[["t"]],["t"]]],[11,"try_into","","",148,[[["self"]],["result"]]],[11,"into","","",148,[[["self"]],["u"]]],[11,"borrow","","",148,[[["self"]],["t"]]],[11,"borrow_mut","","",148,[[["self"]],["t"]]],[11,"get_type_id","","",148,[[["self"]],["typeid"]]],[11,"fmt","","",127,[[["self"],["formatter"]],["result",["error"]]]],[11,"clone","","",143,[[["self"]],["dir"]]],[11,"clone","","",144,[[["self"]],["locale_t"]]],[11,"clone","","",0,[[["self"]],["group"]]],[11,"clone","","",1,[[["self"]],["utimbuf"]]],[11,"clone","","",2,[[["self"]],["timeval"]]],[11,"clone","","",3,[[["self"]],["timespec"]]],[11,"clone","","",4,[[["self"]],["rlimit"]]],[11,"clone","","",5,[[["self"]],["rusage"]]],[11,"clone","","",6,[[["self"]],["ipv6_mreq"]]],[11,"clone","","",7,[[["self"]],["hostent"]]],[11,"clone","","",8,[[["self"]],["iovec"]]],[11,"clone","","",9,[[["self"]],["pollfd"]]],[11,"clone","","",10,[[["self"]],["winsize"]]],[11,"clone","","",11,[[["self"]],["linger"]]],[11,"clone","","",12,[[["self"]],["sigval"]]],[11,"clone","","",13,[[["self"]],["itimerval"]]],[11,"clone","","",14,[[["self"]],["tms"]]],[11,"clone","","",15,[[["self"]],["servent"]]],[11,"clone","","",16,[[["self"]],["protoent"]]],[11,"clone","","",145,[[["self"]],["file"]]],[11,"clone","","",146,[[["self"]],["fpos_t"]]],[11,"clone","","",147,[[["self"]],["timezone"]]],[11,"clone","","",17,[[["self"]],["in_addr"]]],[11,"clone","","",18,[[["self"]],["ip_mreq"]]],[11,"clone","","",19,[[["self"]],["sockaddr"]]],[11,"clone","","",20,[[["self"]],["sockaddr_in"]]],[11,"clone","","",21,[[["self"]],["sockaddr_in6"]]],[11,"clone","","",22,[[["self"]],["addrinfo"]]],[11,"clone","","",23,[[["self"]],["sockaddr_nl"]]],[11,"clone","","",24,[[["self"]],["sockaddr_ll"]]],[11,"clone","","",128,[[["self"]],["fd_set"]]],[11,"clone","","",25,[[["self"]],["tm"]]],[11,"clone","","",26,[[["self"]],["sched_param"]]],[11,"clone","","",27,[[["self"]],["dl_info"]]],[11,"clone","","",28,[[["self"]],["lconv"]]],[11,"clone","","",29,[[["self"]],["sigevent"]]],[11,"clone","","",30,[[["self"]],["in_pktinfo"]]],[11,"clone","","",31,[[["self"]],["ifaddrs"]]],[11,"clone","","",129,[[["self"]],["in6_rtmsg"]]],[11,"clone","","",32,[[["self"]],["arpreq"]]],[11,"clone","","",33,[[["self"]],["arpreq_old"]]],[11,"clone","","",34,[[["self"]],["arphdr"]]],[11,"clone","","",35,[[["self"]],["inotify_event"]]],[11,"clone","","",36,[[["self"]],["mmsghdr"]]],[11,"clone","","",37,[[["self"]],["epoll_event"]]],[11,"clone","","",38,[[["self"]],["sockaddr_un"]]],[11,"clone","","",39,[[["self"]],["sockaddr_storage"]]],[11,"clone","","",40,[[["self"]],["utsname"]]],[11,"clone","","",148,[[["self"]],["fpos64_t"]]],[11,"clone","","",41,[[["self"]],["rlimit64"]]],[11,"clone","","",42,[[["self"]],["glob_t"]]],[11,"clone","","",43,[[["self"]],["passwd"]]],[11,"clone","","",44,[[["self"]],["spwd"]]],[11,"clone","","",45,[[["self"]],["dqblk"]]],[11,"clone","","",46,[[["self"]],["signalfd_siginfo"]]],[11,"clone","","",47,[[["self"]],["itimerspec"]]],[11,"clone","","",130,[[["self"]],["fsid_t"]]],[11,"clone","","",48,[[["self"]],["mq_attr"]]],[11,"clone","","",49,[[["self"]],["packet_mreq"]]],[11,"clone","","",131,[[["self"]],["cpu_set_t"]]],[11,"clone","","",50,[[["self"]],["if_nameindex"]]],[11,"clone","","",51,[[["self"]],["msginfo"]]],[11,"clone","","",52,[[["self"]],["sembuf"]]],[11,"clone","","",53,[[["self"]],["input_event"]]],[11,"clone","","",54,[[["self"]],["input_id"]]],[11,"clone","","",55,[[["self"]],["input_absinfo"]]],[11,"clone","","",56,[[["self"]],["input_keymap_entry"]]],[11,"clone","","",57,[[["self"]],["input_mask"]]],[11,"clone","","",58,[[["self"]],["ff_replay"]]],[11,"clone","","",59,[[["self"]],["ff_trigger"]]],[11,"clone","","",60,[[["self"]],["ff_envelope"]]],[11,"clone","","",61,[[["self"]],["ff_constant_effect"]]],[11,"clone","","",62,[[["self"]],["ff_ramp_effect"]]],[11,"clone","","",63,[[["self"]],["ff_condition_effect"]]],[11,"clone","","",64,[[["self"]],["ff_periodic_effect"]]],[11,"clone","","",65,[[["self"]],["ff_rumble_effect"]]],[11,"clone","","",66,[[["self"]],["ff_effect"]]],[11,"clone","","",67,[[["self"]],["dl_phdr_info"]]],[11,"clone","","",68,[[["self"]],["elf32_ehdr"]]],[11,"clone","","",69,[[["self"]],["elf64_ehdr"]]],[11,"clone","","",70,[[["self"]],["elf32_sym"]]],[11,"clone","","",71,[[["self"]],["elf64_sym"]]],[11,"clone","","",72,[[["self"]],["elf32_phdr"]]],[11,"clone","","",73,[[["self"]],["elf64_phdr"]]],[11,"clone","","",74,[[["self"]],["elf32_shdr"]]],[11,"clone","","",75,[[["self"]],["elf64_shdr"]]],[11,"clone","","",76,[[["self"]],["elf32_chdr"]]],[11,"clone","","",77,[[["self"]],["elf64_chdr"]]],[11,"clone","","",78,[[["self"]],["ucred"]]],[11,"clone","","",79,[[["self"]],["mntent"]]],[11,"clone","","",132,[[["self"]],["posix_spawn_file_actions_t"]]],[11,"clone","","",133,[[["self"]],["posix_spawnattr_t"]]],[11,"clone","","",80,[[["self"]],["genlmsghdr"]]],[11,"clone","","",81,[[["self"]],["in6_pktinfo"]]],[11,"clone","","",82,[[["self"]],["arpd_request"]]],[11,"clone","","",83,[[["self"]],["dirent"]]],[11,"clone","","",84,[[["self"]],["dirent64"]]],[11,"clone","","",85,[[["self"]],["sockaddr_alg"]]],[11,"clone","","",86,[[["self"]],["af_alg_iv"]]],[11,"clone","","",87,[[["self"]],["aiocb"]]],[11,"clone","","",88,[[["self"]],["__exit_status"]]],[11,"clone","","",89,[[["self"]],["__timeval"]]],[11,"clone","","",90,[[["self"]],["sigaction"]]],[11,"clone","","",91,[[["self"]],["stack_t"]]],[11,"clone","","",92,[[["self"]],["siginfo_t"]]],[11,"clone","","",93,[[["self"]],["glob64_t"]]],[11,"clone","","",94,[[["self"]],["statfs"]]],[11,"clone","","",95,[[["self"]],["msghdr"]]],[11,"clone","","",96,[[["self"]],["cmsghdr"]]],[11,"clone","","",97,[[["self"]],["termios"]]],[11,"clone","","",98,[[["self"]],["flock"]]],[11,"clone","","",99,[[["self"]],["mallinfo"]]],[11,"clone","","",100,[[["self"]],["nlmsghdr"]]],[11,"clone","","",101,[[["self"]],["nlmsgerr"]]],[11,"clone","","",102,[[["self"]],["nl_pktinfo"]]],[11,"clone","","",103,[[["self"]],["nl_mmap_req"]]],[11,"clone","","",104,[[["self"]],["nl_mmap_hdr"]]],[11,"clone","","",105,[[["self"]],["nlattr"]]],[11,"clone","","",106,[[["self"]],["rtentry"]]],[11,"clone","","",107,[[["self"]],["utmpx"]]],[11,"clone","","",134,[[["self"]],["sigset_t"]]],[11,"clone","","",108,[[["self"]],["sysinfo"]]],[11,"clone","","",109,[[["self"]],["msqid_ds"]]],[11,"clone","","",110,[[["self"]],["stat"]]],[11,"clone","","",111,[[["self"]],["stat64"]]],[11,"clone","","",112,[[["self"]],["statfs64"]]],[11,"clone","","",113,[[["self"]],["statvfs64"]]],[11,"clone","","",135,[[["self"]],["pthread_attr_t"]]],[11,"clone","","",114,[[["self"]],["_libc_fpxreg"]]],[11,"clone","","",115,[[["self"]],["_libc_xmmreg"]]],[11,"clone","","",116,[[["self"]],["_libc_fpstate"]]],[11,"clone","","",117,[[["self"]],["user_regs_struct"]]],[11,"clone","","",118,[[["self"]],["user"]]],[11,"clone","","",119,[[["self"]],["mcontext_t"]]],[11,"clone","","",120,[[["self"]],["ipc_perm"]]],[11,"clone","","",121,[[["self"]],["shmid_ds"]]],[11,"clone","","",122,[[["self"]],["termios2"]]],[11,"clone","","",123,[[["self"]],["user_fpregs_struct"]]],[11,"clone","","",124,[[["self"]],["ucontext_t"]]],[11,"clone","","",125,[[["self"]],["statvfs"]]],[11,"clone","","",136,[[["self"]],["sem_t"]]],[11,"clone","","",137,[[["self"]],["pthread_mutexattr_t"]]],[11,"clone","","",138,[[["self"]],["pthread_rwlockattr_t"]]],[11,"clone","","",139,[[["self"]],["pthread_condattr_t"]]],[11,"clone","","",140,[[["self"]],["pthread_cond_t"]]],[11,"clone","","",141,[[["self"]],["pthread_mutex_t"]]],[11,"clone","","",142,[[["self"]],["pthread_rwlock_t"]]],[11,"clone","","",126,[[["self"]],["in6_addr"]]]],"paths":[[3,"group"],[3,"utimbuf"],[3,"timeval"],[3,"timespec"],[3,"rlimit"],[3,"rusage"],[3,"ipv6_mreq"],[3,"hostent"],[3,"iovec"],[3,"pollfd"],[3,"winsize"],[3,"linger"],[3,"sigval"],[3,"itimerval"],[3,"tms"],[3,"servent"],[3,"protoent"],[3,"in_addr"],[3,"ip_mreq"],[3,"sockaddr"],[3,"sockaddr_in"],[3,"sockaddr_in6"],[3,"addrinfo"],[3,"sockaddr_nl"],[3,"sockaddr_ll"],[3,"tm"],[3,"sched_param"],[3,"Dl_info"],[3,"lconv"],[3,"sigevent"],[3,"in_pktinfo"],[3,"ifaddrs"],[3,"arpreq"],[3,"arpreq_old"],[3,"arphdr"],[3,"inotify_event"],[3,"mmsghdr"],[3,"epoll_event"],[3,"sockaddr_un"],[3,"sockaddr_storage"],[3,"utsname"],[3,"rlimit64"],[3,"glob_t"],[3,"passwd"],[3,"spwd"],[3,"dqblk"],[3,"signalfd_siginfo"],[3,"itimerspec"],[3,"mq_attr"],[3,"packet_mreq"],[3,"if_nameindex"],[3,"msginfo"],[3,"sembuf"],[3,"input_event"],[3,"input_id"],[3,"input_absinfo"],[3,"input_keymap_entry"],[3,"input_mask"],[3,"ff_replay"],[3,"ff_trigger"],[3,"ff_envelope"],[3,"ff_constant_effect"],[3,"ff_ramp_effect"],[3,"ff_condition_effect"],[3,"ff_periodic_effect"],[3,"ff_rumble_effect"],[3,"ff_effect"],[3,"dl_phdr_info"],[3,"Elf32_Ehdr"],[3,"Elf64_Ehdr"],[3,"Elf32_Sym"],[3,"Elf64_Sym"],[3,"Elf32_Phdr"],[3,"Elf64_Phdr"],[3,"Elf32_Shdr"],[3,"Elf64_Shdr"],[3,"Elf32_Chdr"],[3,"Elf64_Chdr"],[3,"ucred"],[3,"mntent"],[3,"genlmsghdr"],[3,"in6_pktinfo"],[3,"arpd_request"],[3,"dirent"],[3,"dirent64"],[3,"sockaddr_alg"],[3,"af_alg_iv"],[3,"aiocb"],[3,"__exit_status"],[3,"__timeval"],[3,"sigaction"],[3,"stack_t"],[3,"siginfo_t"],[3,"glob64_t"],[3,"statfs"],[3,"msghdr"],[3,"cmsghdr"],[3,"termios"],[3,"flock"],[3,"mallinfo"],[3,"nlmsghdr"],[3,"nlmsgerr"],[3,"nl_pktinfo"],[3,"nl_mmap_req"],[3,"nl_mmap_hdr"],[3,"nlattr"],[3,"rtentry"],[3,"utmpx"],[3,"sysinfo"],[3,"msqid_ds"],[3,"stat"],[3,"stat64"],[3,"statfs64"],[3,"statvfs64"],[3,"_libc_fpxreg"],[3,"_libc_xmmreg"],[3,"_libc_fpstate"],[3,"user_regs_struct"],[3,"user"],[3,"mcontext_t"],[3,"ipc_perm"],[3,"shmid_ds"],[3,"termios2"],[3,"user_fpregs_struct"],[3,"ucontext_t"],[3,"statvfs"],[3,"in6_addr"],[4,"c_void"],[3,"fd_set"],[3,"in6_rtmsg"],[3,"fsid_t"],[3,"cpu_set_t"],[3,"posix_spawn_file_actions_t"],[3,"posix_spawnattr_t"],[3,"sigset_t"],[3,"pthread_attr_t"],[3,"sem_t"],[3,"pthread_mutexattr_t"],[3,"pthread_rwlockattr_t"],[3,"pthread_condattr_t"],[3,"pthread_cond_t"],[3,"pthread_mutex_t"],[3,"pthread_rwlock_t"],[4,"DIR"],[4,"locale_t"],[4,"FILE"],[4,"fpos_t"],[4,"timezone"],[4,"fpos64_t"]]};
searchIndex["log"]={"doc":"A lightweight logging facade.","items":[[3,"Record","log","The \"payload\" of a log message.",N,N],[3,"RecordBuilder","","Builder for `Record`.",N,N],[3,"Metadata","","Metadata about a log message.",N,N],[3,"MetadataBuilder","","Builder for `Metadata`.",N,N],[3,"SetLoggerError","","The type returned by [`set_logger`] if [`set_logger`] has already been called.",N,N],[3,"ParseLevelError","","The type returned by [`from_str`] when the string doesn't match any of the log levels.",N,N],[4,"Level","","An enum representing the available verbosity levels of the logger.",N,N],[13,"Error","","The \"error\" level.",0,N],[13,"Warn","","The \"warn\" level.",0,N],[13,"Info","","The \"info\" level.",0,N],[13,"Debug","","The \"debug\" level.",0,N],[13,"Trace","","The \"trace\" level.",0,N],[4,"LevelFilter","","An enum representing the available verbosity level filters of the logger.",N,N],[13,"Off","","A level lower than all log levels.",1,N],[13,"Error","","Corresponds to the `Error` log level.",1,N],[13,"Warn","","Corresponds to the `Warn` log level.",1,N],[13,"Info","","Corresponds to the `Info` log level.",1,N],[13,"Debug","","Corresponds to the `Debug` log level.",1,N],[13,"Trace","","Corresponds to the `Trace` log level.",1,N],[5,"set_max_level","","Sets the global maximum log level.",N,[[["levelfilter"]]]],[5,"max_level","","Returns the current maximum log level.",N,[[],["levelfilter"]]],[5,"set_logger","","Sets the global logger to a `&'static Log`.",N,[[["log"]],["result",["setloggererror"]]]],[5,"logger","","Returns a reference to the logger.",N,[[],["log"]]],[17,"STATIC_MAX_LEVEL","","The statically resolved maximum log level.",N,N],[8,"Log","","A trait encapsulating the operations required of a logger.",N,N],[10,"enabled","","Determines if a log message with the specified metadata would be logged.",2,[[["self"],["metadata"]],["bool"]]],[10,"log","","Logs the `Record`.",2,[[["self"],["record"]]]],[10,"flush","","Flushes any buffered records.",2,[[["self"]]]],[11,"max","","Returns the most verbose logging level.",0,[[],["level"]]],[11,"to_level_filter","","Converts the `Level` to the equivalent `LevelFilter`.",0,[[["self"]],["levelfilter"]]],[11,"max","","Returns the most verbose logging level filter.",1,[[],["levelfilter"]]],[11,"to_level","","Converts `self` to the equivalent `Level`.",1,[[["self"]],["option",["level"]]]],[11,"builder","","Returns a new builder.",3,[[],["recordbuilder"]]],[11,"args","","The message body.",3,[[["self"]],["arguments"]]],[11,"metadata","","Metadata about the log directive.",3,[[["self"]],["metadata"]]],[11,"level","","The verbosity level of the message.",3,[[["self"]],["level"]]],[11,"target","","The name of the target of the directive.",3,[[["self"]],["str"]]],[11,"module_path","","The module path of the message.",3,[[["self"]],["option",["str"]]]],[11,"file","","The source file containing the message.",3,[[["self"]],["option",["str"]]]],[11,"line","","The line containing the message.",3,[[["self"]],["option",["u32"]]]],[11,"new","","Construct new `RecordBuilder`.",4,[[],["recordbuilder"]]],[11,"args","","Set `args`.",4,[[["self"],["arguments"]],["recordbuilder"]]],[11,"metadata","","Set `metadata`. Construct a `Metadata` object with `MetadataBuilder`.",4,[[["self"],["metadata"]],["recordbuilder"]]],[11,"level","","Set `Metadata::level`.",4,[[["self"],["level"]],["recordbuilder"]]],[11,"target","","Set `Metadata::target`",4,[[["self"],["str"]],["recordbuilder"]]],[11,"module_path","","Set `module_path`",4,[[["self"],["option",["str"]]],["recordbuilder"]]],[11,"file","","Set `file`",4,[[["self"],["option",["str"]]],["recordbuilder"]]],[11,"line","","Set `line`",4,[[["self"],["option",["u32"]]],["recordbuilder"]]],[11,"build","","Invoke the builder and return a `Record`",4,[[["self"]],["record"]]],[11,"builder","","Returns a new builder.",5,[[],["metadatabuilder"]]],[11,"level","","The verbosity level of the message.",5,[[["self"]],["level"]]],[11,"target","","The name of the target of the directive.",5,[[["self"]],["str"]]],[11,"new","","Construct a new `MetadataBuilder`.",6,[[],["metadatabuilder"]]],[11,"level","","Setter for `level`.",6,[[["self"],["level"]],["metadatabuilder"]]],[11,"target","","Setter for `target`.",6,[[["self"],["str"]],["metadatabuilder"]]],[11,"build","","Returns a `Metadata` object.",6,[[["self"]],["metadata"]]],[14,"log","","The standard logging macro.",N,N],[14,"error","","Logs a message at the error level.",N,N],[14,"warn","","Logs a message at the warn level.",N,N],[14,"info","","Logs a message at the info level.",N,N],[14,"debug","","Logs a message at the debug level.",N,N],[14,"trace","","Logs a message at the trace level.",N,N],[14,"log_enabled","","Determines if a message logged at the specified level in that module will be logged.",N,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"eq","","",0,[[["self"],["level"]],["bool"]]],[11,"eq","","",0,[[["self"],["levelfilter"]],["bool"]]],[11,"eq","","",1,[[["self"],["levelfilter"]],["bool"]]],[11,"eq","","",1,[[["self"],["level"]],["bool"]]],[11,"eq","","",5,[[["self"],["metadata"]],["bool"]]],[11,"ne","","",5,[[["self"],["metadata"]],["bool"]]],[11,"eq","","",6,[[["self"],["metadatabuilder"]],["bool"]]],[11,"ne","","",6,[[["self"],["metadatabuilder"]],["bool"]]],[11,"eq","","",8,[[["self"],["parselevelerror"]],["bool"]]],[11,"ne","","",8,[[["self"],["parselevelerror"]],["bool"]]],[11,"cmp","","",0,[[["self"],["level"]],["ordering"]]],[11,"cmp","","",1,[[["self"],["levelfilter"]],["ordering"]]],[11,"cmp","","",5,[[["self"],["metadata"]],["ordering"]]],[11,"cmp","","",6,[[["self"],["metadatabuilder"]],["ordering"]]],[11,"partial_cmp","","",0,[[["self"],["level"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["level"]],["bool"]]],[11,"le","","",0,[[["self"],["level"]],["bool"]]],[11,"gt","","",0,[[["self"],["level"]],["bool"]]],[11,"ge","","",0,[[["self"],["level"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["levelfilter"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["levelfilter"]],["bool"]]],[11,"le","","",0,[[["self"],["levelfilter"]],["bool"]]],[11,"gt","","",0,[[["self"],["levelfilter"]],["bool"]]],[11,"ge","","",0,[[["self"],["levelfilter"]],["bool"]]],[11,"partial_cmp","","",1,[[["self"],["levelfilter"]],["option",["ordering"]]]],[11,"lt","","",1,[[["self"],["levelfilter"]],["bool"]]],[11,"le","","",1,[[["self"],["levelfilter"]],["bool"]]],[11,"gt","","",1,[[["self"],["levelfilter"]],["bool"]]],[11,"ge","","",1,[[["self"],["levelfilter"]],["bool"]]],[11,"partial_cmp","","",1,[[["self"],["level"]],["option",["ordering"]]]],[11,"lt","","",1,[[["self"],["level"]],["bool"]]],[11,"le","","",1,[[["self"],["level"]],["bool"]]],[11,"gt","","",1,[[["self"],["level"]],["bool"]]],[11,"ge","","",1,[[["self"],["level"]],["bool"]]],[11,"partial_cmp","","",5,[[["self"],["metadata"]],["option",["ordering"]]]],[11,"lt","","",5,[[["self"],["metadata"]],["bool"]]],[11,"le","","",5,[[["self"],["metadata"]],["bool"]]],[11,"gt","","",5,[[["self"],["metadata"]],["bool"]]],[11,"ge","","",5,[[["self"],["metadata"]],["bool"]]],[11,"partial_cmp","","",6,[[["self"],["metadatabuilder"]],["option",["ordering"]]]],[11,"lt","","",6,[[["self"],["metadatabuilder"]],["bool"]]],[11,"le","","",6,[[["self"],["metadatabuilder"]],["bool"]]],[11,"gt","","",6,[[["self"],["metadatabuilder"]],["bool"]]],[11,"ge","","",6,[[["self"],["metadatabuilder"]],["bool"]]],[11,"hash","","",0,N],[11,"hash","","",1,N],[11,"hash","","",5,N],[11,"hash","","",6,N],[11,"from_str","","",0,[[["str"]],["result",["level"]]]],[11,"from_str","","",1,[[["str"]],["result",["levelfilter"]]]],[11,"clone","","",0,[[["self"]],["level"]]],[11,"clone","","",1,[[["self"]],["levelfilter"]]],[11,"clone","","",3,[[["self"]],["record"]]],[11,"clone","","",5,[[["self"]],["metadata"]]]],"paths":[[4,"Level"],[4,"LevelFilter"],[8,"Log"],[3,"Record"],[3,"RecordBuilder"],[3,"Metadata"],[3,"MetadataBuilder"],[3,"SetLoggerError"],[3,"ParseLevelError"]]};
searchIndex["rgsl"]={"doc":"A Rust binding for the [GSL library][] (the GNU Scientific Library).","items":[[3,"RootFunction","rgsl","",N,N],[12,"function","","",0,N],[12,"params","","",0,N],[3,"RootFunctionFdf","","",N,N],[12,"f","","",1,N],[12,"df","","",1,N],[12,"fdf","","",1,N],[12,"params","","",1,N],[3,"IOStream","","A wrapper to handle I/O operations between GSL and rust",N,N],[4,"Mode","","",N,N],[13,"PrecDouble","","",2,N],[13,"PrecSingle","","",2,N],[13,"PrecApprox","","",2,N],[4,"Value","","",N,N],[13,"Success","","",3,N],[13,"Failure","","",3,N],[13,"Continue","","iteration has not converged",3,N],[13,"Domain","","input domain error, e.g sqrt(-1)",3,N],[13,"Range","","output range error, e.g. exp(1e100)",3,N],[13,"Fault","","invalid pointer",3,N],[13,"Invalid","","invalid argument supplied by user",3,N],[13,"Failed","","generic failure",3,N],[13,"Factorization","","factorization failed",3,N],[13,"Sanity","","sanity check failed - shouldn't happen",3,N],[13,"NoMemory","","malloc failed",3,N],[13,"BadFunction","","problem with user-supplied function",3,N],[13,"RunAway","","iterative process is out of control",3,N],[13,"MaxIteration","","exceeded max number of iterations",3,N],[13,"ZeroDiv","","tried to divide by zero",3,N],[13,"BadTolerance","","user specified an invalid tolerance",3,N],[13,"Tolerance","","failed to reach the specified tolerance",3,N],[13,"UnderFlow","","underflow",3,N],[13,"OverFlow","","overflow",3,N],[13,"Loss","","loss of accuracy",3,N],[13,"Round","","failed because of roundoff error",3,N],[13,"BadLength","","matrix, vector lengths are not conformant",3,N],[13,"NotSquare","","matrix not square",3,N],[13,"Singularity","","apparent singularity detected",3,N],[13,"Diverge","","integral or series is divergent",3,N],[13,"Unsupported","","requested feature is not supported by the hardware",3,N],[13,"Unimplemented","","requested feature not (yet) implemented",3,N],[13,"Cache","","cache limit exceeded",3,N],[13,"Table","","table limit exceeded",3,N],[13,"NoProgress","","iteration is not making progress towards solution",3,N],[13,"NoProgressJacobian","","jacobian evaluations are not improving the solution",3,N],[13,"ToleranceF","","cannot reach the specified tolerance in F",3,N],[13,"ToleranceX","","cannot reach the specified tolerance in X",3,N],[13,"ToleranceG","","cannot reach the specified tolerance in gradient",3,N],[13,"EOF","","cannot reach the specified tolerance in gradient",3,N],[13,"Unknown","","Unknown value.",3,N],[4,"EigenSort","","",N,N],[13,"ValAsc","","ascending order in numerical value",4,N],[13,"ValDesc","","descending order in numerical value",4,N],[13,"AbsAsc","","ascending order in magnitude",4,N],[13,"AbsDesc","","descending order in magnitude",4,N],[4,"FftDirection","","this gives the sign in the formula",N,N],[13,"Forward","","",5,N],[13,"Backward","","",5,N],[4,"GaussKonrodRule","","The low-level integration rules in QUADPACK are identified by small integers (1-6). We'll use symbolic constants to refer to them.",N,N],[13,"Gauss15","","15 point Gauss-Kronrod rule",6,N],[13,"Gauss21","","21 point Gauss-Kronrod rule",6,N],[13,"Gauss31","","31 point Gauss-Kronrod rule",6,N],[13,"Gauss41","","41 point Gauss-Kronrod rule",6,N],[13,"Gauss51","","51 point Gauss-Kronrod rule",6,N],[13,"Gauss61","","61 point Gauss-Kronrod rule",6,N],[4,"IntegrationQawo","","Used by workspace for QAWO integrator",N,N],[13,"Cosine","","",7,N],[13,"Sine","","",7,N],[4,"VegasMode","","Used by VegasMonteCarlo struct",N,N],[13,"Importance","","",8,N],[13,"ImportanceOnly","","",8,N],[13,"Stratified","","",8,N],[4,"ODEiv","","Possible return values for an hadjust() evolution method for ordinary differential equations",N,N],[13,"Inc","","step was increased",9,N],[13,"Nil","","step unchanged",9,N],[13,"Dec","","step decreased",9,N],[4,"WaveletDirection","","",N,N],[13,"Forward","","",10,N],[13,"Backward","","",10,N],[4,"SfLegendreNorm","","",N,N],[13,"Schmidt","","",11,N],[13,"SphericalHarmonic","","",11,N],[13,"Full","","",11,N],[13,"None","","",11,N],[11,"fwrite_handle","","Open a file in write mode.",12,[[["p"]],["result",["iostream","errorkind"]]]],[11,"write_mode","","",12,[[["self"]],["bool"]]],[0,"randist","","#Random Number Distributions",N,N],[0,"bernoulli","rgsl::randist","",N,N],[5,"bernoulli","rgsl::randist::bernoulli","This function returns either 0 or 1, the result of a Bernoulli trial with probability p. The probability distribution for a Bernoulli trial is,",N,[[["rng"],["f64"]],["u32"]]],[5,"bernoulli_pdf","","This function computes the probability p(k) of obtaining k from a Bernoulli distribution with probability parameter p, using the formula given above.",N,[[["u32"],["f64"]],["f64"]]],[0,"beta","rgsl::randist","",N,N],[5,"beta","rgsl::randist::beta","This function returns a random variate from the beta distribution. The distribution function is,",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"beta_pdf","","This function computes the probability density p(x) at x for a beta distribution with parameters a and b, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"beta_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the beta distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"beta_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the beta distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"beta_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the beta distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"beta_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the beta distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[0,"binomial","rgsl::randist","",N,N],[5,"binomial","rgsl::randist::binomial","This function returns a random integer from the binomial distribution, the number of successes in n independent trials with probability p. The probability distribution for binomial variates is,",N,[[["rng"],["f64"],["u32"]],["u32"]]],[5,"binomial_pdf","","This function computes the probability p(k) of obtaining k from a binomial distribution with parameters p and n, using the formula given above.",N,[[["u32"],["f64"],["u32"]],["f64"]]],[5,"binomial_P","","This function computes the cumulative distribution functions P(k), Q(k) for the binomial distribution with parameters p and n.",N,[[["u32"],["f64"],["u32"]],["f64"]]],[5,"binomial_Q","","This function computes the cumulative distribution functions P(k), Q(k) for the binomial distribution with parameters p and n.",N,[[["u32"],["f64"],["u32"]],["f64"]]],[0,"bivariate_gaussian","rgsl::randist","",N,N],[5,"gaussian_tail","rgsl::randist::bivariate_gaussian","This function generates a pair of correlated Gaussian variates, with mean zero, correlation coefficient rho and standard deviations sigma_x and sigma_y in the x and y directions. The probability distribution for bivariate Gaussian random variates is,",N,[[["rng"],["f64"],["f64"],["f64"],["f64"],["f64"]]]],[5,"gaussian_tail_pdf","","This function computes the probability density p(x,y) at (x,y) for a bivariate Gaussian distribution with standard deviations sigma_x, sigma_y and correlation coefficient rho, using the formula given above.",N,[[["f64"],["f64"],["f64"],["f64"],["f64"]],["f64"]]],[0,"cauchy","rgsl::randist","",N,N],[5,"cauchy","rgsl::randist::cauchy","This function returns a random variate from the Cauchy distribution with scale parameter a. The probability distribution for Cauchy random variates is,",N,[[["rng"],["f64"]],["f64"]]],[5,"cauchy_pdf","","This function computes the probability density p(x) at x for a Cauchy distribution with scale parameter a, using the formula given above.",N,[[["f64"],["f64"]],["f64"]]],[5,"cauchy_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Cauchy distribution with scale parameter a.",N,[[["f64"],["f64"]],["f64"]]],[5,"cauchy_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Cauchy distribution with scale parameter a.",N,[[["f64"],["f64"]],["f64"]]],[5,"cauchy_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Cauchy distribution with scale parameter a.",N,[[["f64"],["f64"]],["f64"]]],[5,"cauchy_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Cauchy distribution with scale parameter a.",N,[[["f64"],["f64"]],["f64"]]],[0,"chi_squared","rgsl::randist","The chi-squared distribution arises in statistics. If Y_i are n independent Gaussian random variates with unit variance then the sum-of-squares,",N,N],[5,"chisq","rgsl::randist::chi_squared","This function returns a random variate from the chi-squared distribution with nu degrees of freedom. The distribution function is,",N,[[["rng"],["f64"]],["f64"]]],[5,"chisq_pdf","","This function computes the probability density p(x) at x for a chi-squared distribution with nu degrees of freedom, using the formula given above.",N,[[["f64"],["f64"]],["f64"]]],[5,"chisq_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the chi-squared distribution with nu degrees of freedom.",N,[[["f64"],["f64"]],["f64"]]],[5,"chisq_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the chi-squared distribution with nu degrees of freedom.",N,[[["f64"],["f64"]],["f64"]]],[5,"chisq_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the chi-squared distribution with nu degrees of freedom.",N,[[["f64"],["f64"]],["f64"]]],[5,"chisq_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the chi-squared distribution with nu degrees of freedom.",N,[[["f64"],["f64"]],["f64"]]],[0,"dirichlet","rgsl::randist","",N,N],[5,"dirichlet","rgsl::randist::dirichlet","This function returns an array of K random variates from a Dirichlet distribution of order K-1. The distribution function is",N,N],[5,"dirichlet_pdf","","This function computes the probability density p(\\theta_1, ... , \\theta_K) at theta[K] for a Dirichlet distribution with parameters alpha[K], using the formula given above.",N,N],[5,"dirichlet_lnpdf","","This function computes the logarithm of the probability density p(\\theta_1, ... , \\theta_K) for a Dirichlet distribution with parameters alpha[K].",N,N],[0,"exponential","rgsl::randist","",N,N],[5,"exponential","rgsl::randist::exponential","This function returns a random variate from the exponential distribution with mean mu. The distribution is,",N,[[["rng"],["f64"]],["f64"]]],[5,"exponential_pdf","","This function computes the probability density p(x) at x for an exponential distribution with mean mu, using the formula given above.",N,[[["f64"],["f64"]],["f64"]]],[5,"exponential_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the exponential distribution with mean mu.",N,[[["f64"],["f64"]],["f64"]]],[5,"exponential_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the exponential distribution with mean mu.",N,[[["f64"],["f64"]],["f64"]]],[5,"exponential_Pinv","","",N,[[["f64"],["f64"]],["f64"]]],[5,"exponential_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the exponential distribution with mean mu.",N,[[["f64"],["f64"]],["f64"]]],[0,"exponential_power","rgsl::randist","",N,N],[5,"exppow","rgsl::randist::exponential_power","This function returns a random variate from the exponential power distribution with scale parameter a and exponent b. The distribution is,",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"exppow_pdf","","This function computes the probability density p(x) at x for an exponential power distribution with scale parameter a and exponent b, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"exppow_P","","This function computes tthe cumulative distribution functions P(x), Q(x) for the exponential power distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"exppow_Q","","This function computes tthe cumulative distribution functions P(x), Q(x) for the exponential power distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[0,"f_distribution","rgsl::randist","The F-distribution arises in statistics. If Y_1 and Y_2 are chi-squared deviates with \\nu_1 and \\nu_2 degrees of freedom then the ratio,",N,N],[5,"fdist","rgsl::randist::f_distribution","This function returns a random variate from the F-distribution with degrees of freedom nu1 and nu2. The distribution function is,",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"fdist_pdf","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"fdist_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"fdist_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"fdist_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"fdist_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[0,"flat","rgsl::randist","",N,N],[5,"flat","rgsl::randist::flat","This function returns a random variate from the flat (uniform) distribution from a to b. The distribution is,",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"flat_pdf","","This function computes the probability density p(x) at x for a uniform distribution from a to b, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"flat_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for a uniform distribution from a to b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"flat_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for a uniform distribution from a to b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"flat_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for a uniform distribution from a to b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"flat_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for a uniform distribution from a to b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[0,"gamma","rgsl::randist","",N,N],[5,"gamma","rgsl::randist::gamma","This function returns a random variate from the gamma distribution. The distribution function is,",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"gamma_knuth","","This function returns a gamma variate using the algorithms from Knuth (vol 2).",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"gamma_pdf","","This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"gamma_P","","This function computes This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"gamma_Q","","This function computes This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"gamma_Pinv","","This function computes This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"gamma_Qinv","","This function computes This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[0,"gaussian","rgsl::randist","",N,N],[5,"gaussian","rgsl::randist::gaussian","This function returns a Gaussian random variate, with mean zero and standard deviation sigma. The probability distribution for Gaussian random variates is,",N,[[["rng"],["f64"]],["f64"]]],[5,"gaussian_pdf","","This function computes the probability density p(x) at x for a Gaussian distribution with standard deviation sigma, using the formula given above.",N,[[["f64"],["f64"]],["f64"]]],[5,"gaussian_ziggurat","","",N,[[["rng"],["f64"]],["f64"]]],[5,"gaussian_ratio_method","","This function computes a Gaussian random variate using the alternative Marsaglia-Tsang ziggurat and Kinderman-Monahan-Leva ratio methods. The Ziggurat algorithm is the fastest available algorithm in most cases.",N,[[["rng"],["f64"]],["f64"]]],[5,"ugaussian","","This function computes results for the unit Gaussian distribution. They are equivalent to the functions above with a standard deviation of one, sigma = 1.",N,[[["rng"]],["f64"]]],[5,"ugaussian_pdf","","This function computes results for the unit Gaussian distribution. They are equivalent to the functions above with a standard deviation of one, sigma = 1.",N,[[["f64"]],["f64"]]],[5,"ugaussian_ratio_method","","This function computes results for the unit Gaussian distribution. They are equivalent to the functions above with a standard deviation of one, sigma = 1.",N,[[["rng"]],["f64"]]],[5,"gaussian_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Gaussian distribution with standard deviation sigma.",N,[[["f64"],["f64"]],["f64"]]],[5,"gaussian_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Gaussian distribution with standard deviation sigma.",N,[[["f64"],["f64"]],["f64"]]],[5,"gaussian_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Gaussian distribution with standard deviation sigma.",N,[[["f64"],["f64"]],["f64"]]],[5,"gaussian_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Gaussian distribution with standard deviation sigma.",N,[[["f64"],["f64"]],["f64"]]],[5,"ugaussian_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the unit Gaussian distribution.",N,[[["f64"]],["f64"]]],[5,"ugaussian_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the unit Gaussian distribution.",N,[[["f64"]],["f64"]]],[5,"ugaussian_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the unit Gaussian distribution.",N,[[["f64"]],["f64"]]],[5,"ugaussian_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the unit Gaussian distribution.",N,[[["f64"]],["f64"]]],[0,"gaussian_tail","rgsl::randist","",N,N],[5,"gaussian_tail","rgsl::randist::gaussian_tail","This function provides random variates from the upper tail of a Gaussian distribution with standard deviation sigma. The values returned are larger than the lower limit a, which must be positive. The method is based on Marsaglias famous rectangle-wedge-tail algorithm (Ann. Math. Stat. 32, 894899 (1961)), with this aspect explained in Knuth, v2, 3rd ed, p139,586 (exercise 11).",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"gaussian_tail_pdf","","This function computes the probability density p(x) at x for a Gaussian tail distribution with standard deviation sigma and lower limit a, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"ugaussian_tail","","This function computes results for the tail of a unit Gaussian distribution. They are equivalent to the functions above with a standard deviation of one, sigma = 1.",N,[[["rng"],["f64"]],["f64"]]],[5,"ugaussian_tail_pdf","","This function computes results for the tail of a unit Gaussian distribution. They are equivalent to the functions above with a standard deviation of one, sigma = 1.",N,[[["f64"],["f64"]],["f64"]]],[0,"geometric","rgsl::randist","",N,N],[5,"geometric","rgsl::randist::geometric","This function returns a random integer from the geometric distribution, the number of independent trials with probability p until the first success. The probability distribution for geometric variates is,",N,[[["rng"],["f64"]],["u32"]]],[5,"geometric_pdf","","This function computes the probability p(k) of obtaining k from a geometric distribution with probability parameter p, using the formula given above.",N,[[["u32"],["f64"]],["f64"]]],[5,"geometric_P","","This function computes the cumulative distribution functions P(k), Q(k) for the geometric distribution with parameter p.",N,[[["u32"],["f64"]],["f64"]]],[5,"geometric_Q","","This function computes the cumulative distribution functions P(k), Q(k) for the geometric distribution with parameter p.",N,[[["u32"],["f64"]],["f64"]]],[0,"gumbel","rgsl::randist","",N,N],[0,"type_1","rgsl::randist::gumbel","",N,N],[5,"gumbel1","rgsl::randist::gumbel::type_1","This function returns a random variate from the Type-1 Gumbel distribution. The Type-1 Gumbel distribution function is,",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"gumbel1_pdf","","This function computes the probability density p(x) at x for a Type-1 Gumbel distribution with parameters a and b, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"gumbel1_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-1 Gumbel distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"gumbel1_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-1 Gumbel distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"gumbel1_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-1 Gumbel distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"gumbel1_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-1 Gumbel distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[0,"type_2","rgsl::randist::gumbel","",N,N],[5,"gumbel2","rgsl::randist::gumbel::type_2","This function returns a random variate from the Type-2 Gumbel distribution. The Type-2 Gumbel distribution function is,",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"gumbel2_pdf","","This function computes the probability density p(x) at x for a Type-2 Gumbel distribution with parameters a and b, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"gumbel2_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-2 Gumbel distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"gumbel2_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-2 Gumbel distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"gumbel2_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-2 Gumbel distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"gumbel2_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-2 Gumbel distribution with parameters a and b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[0,"hypergeometric","rgsl::randist","",N,N],[5,"hypergeometric","rgsl::randist::hypergeometric","This function returns a random integer from the hypergeometric distribution. The probability distribution for hypergeometric random variates is,",N,[[["rng"],["u32"],["u32"],["u32"]],["u32"]]],[5,"hypergeometric_pdf","","This function computes the probability p(k) of obtaining k from a hypergeometric distribution with parameters n1, n2, t, using the formula given above.",N,[[["u32"],["u32"],["u32"],["u32"]],["f64"]]],[5,"hypergeometric_P","","This function computes the cumulative distribution functions P(k), Q(k) for the hypergeometric distribution with parameters n1, n2 and t.",N,[[["u32"],["u32"],["u32"],["u32"]],["f64"]]],[5,"hypergeometric_Q","","This function computes the cumulative distribution functions P(k), Q(k) for the hypergeometric distribution with parameters n1, n2 and t.",N,[[["u32"],["u32"],["u32"],["u32"]],["f64"]]],[0,"landau","rgsl::randist","",N,N],[5,"landau","rgsl::randist::landau","This function returns a random variate from the Landau distribution. The probability distribution for Landau random variates is defined analytically by the complex integral,",N,[[["rng"]],["f64"]]],[5,"landau_pdf","","This function computes the probability density p(x) at x for the Landau distribution using an approximation to the formula given above.",N,[[["f64"]],["f64"]]],[0,"laplace","rgsl::randist","",N,N],[5,"laplace","rgsl::randist::laplace","This function returns a random variate from the Laplace distribution with width a. The distribution is,",N,[[["rng"],["f64"]],["f64"]]],[5,"laplace_pdf","","This function computes the probability density p(x) at x for a Laplace distribution with width a, using the formula given above.",N,[[["f64"],["f64"]],["f64"]]],[5,"laplace_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Laplace distribution with width a.",N,[[["f64"],["f64"]],["f64"]]],[5,"laplace_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Laplace distribution with width a.",N,[[["f64"],["f64"]],["f64"]]],[5,"laplace_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Laplace distribution with width a.",N,[[["f64"],["f64"]],["f64"]]],[5,"laplace_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Laplace distribution with width a.",N,[[["f64"],["f64"]],["f64"]]],[0,"levy_alpha","rgsl::randist","",N,N],[5,"levy","rgsl::randist::levy_alpha","This function returns a random variate from the Levy symmetric stable distribution with scale c and exponent alpha. The symmetric stable probability distribution is defined by a Fourier transform,",N,[[["rng"],["f64"],["f64"]],["f64"]]],[0,"levy_skew","rgsl::randist","",N,N],[5,"levy_skew","rgsl::randist::levy_skew","This function returns a random variate from the Levy skew stable distribution with scale c, exponent alpha and skewness parameter beta. The skewness parameter must lie in the range [-1,1]. The Levy skew stable probability distribution is defined by a Fourier transform,",N,[[["rng"],["f64"],["f64"],["f64"]],["f64"]]],[0,"logarithmic","rgsl::randist","",N,N],[5,"logarithmic","rgsl::randist::logarithmic","This function returns a random integer from the logarithmic distribution. The probability distribution for logarithmic random variates is,",N,[[["rng"],["f64"]],["u32"]]],[5,"logarithmic_pdf","","This function computes the probability p(k) of obtaining k from a logarithmic distribution with probability parameter p, using the formula given above.",N,[[["u32"],["f64"]],["f64"]]],[0,"logistic","rgsl::randist","",N,N],[5,"logistic","rgsl::randist::logistic","This function returns a random variate from the logistic distribution. The distribution function is,",N,[[["rng"],["f64"]],["f64"]]],[5,"logistic_pdf","","This function computes the probability density p(x) at x for a logistic distribution with scale parameter a, using the formula given above.",N,[[["f64"],["f64"]],["f64"]]],[5,"logistic_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the logistic distribution with scale parameter a.",N,[[["f64"],["f64"]],["f64"]]],[5,"logistic_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the logistic distribution with scale parameter a.",N,[[["f64"],["f64"]],["f64"]]],[5,"logistic_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the logistic distribution with scale parameter a.",N,[[["f64"],["f64"]],["f64"]]],[5,"logistic_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the logistic distribution with scale parameter a.",N,[[["f64"],["f64"]],["f64"]]],[0,"lognormal","rgsl::randist","",N,N],[5,"lognormal","rgsl::randist::lognormal","This function returns a random variate from the lognormal distribution. The distribution function is,",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"lognormal_pdf","","This function computes the probability density p(x) at x for a lognormal distribution with parameters zeta and sigma, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"lognormal_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the lognormal distribution with parameters zeta and sigma.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"lognormal_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the lognormal distribution with parameters zeta and sigma.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"lognormal_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the lognormal distribution with parameters zeta and sigma.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"lognormal_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the lognormal distribution with parameters zeta and sigma.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[0,"multinomial","rgsl::randist","",N,N],[5,"multinomial","rgsl::randist::multinomial","This function computes a random sample n[] from the multinomial distribution formed by N trials from an underlying distribution p[K]. The distribution function for n[] is,",N,N],[5,"multinomial_pdf","","This function computes the probability P(n_1, n_2, ..., n_K) of sampling n[K] from a multinomial distribution with parameters p[K], using the formula given above.",N,N],[5,"multinomial_lnpdf","","This function returns the logarithm of the probability for the multinomial distribution P(n_1, n_2, ..., n_K) with parameters p[K].",N,N],[0,"negative_binomial","rgsl::randist","",N,N],[5,"negative_binomial","rgsl::randist::negative_binomial","This function returns a random integer from the negative binomial distribution, the number of failures occurring before n successes in independent trials with probability p of success. The probability distribution for negative binomial variates is,",N,[[["rng"],["f64"],["f64"]],["u32"]]],[5,"negative_binomial_pdf","","This function computes the probability p(k) of obtaining k from a negative binomial distribution with parameters p and n, using the formula given above.",N,[[["u32"],["f64"],["f64"]],["f64"]]],[5,"negative_binomial_P","","This function computes the cumulative distribution functions P(k), Q(k) for the negative binomial distribution with parameters p and n.",N,[[["u32"],["f64"],["f64"]],["f64"]]],[5,"negative_binomial_Q","","This function computes the cumulative distribution functions P(k), Q(k) for the negative binomial distribution with parameters p and n.",N,[[["u32"],["f64"],["f64"]],["f64"]]],[0,"pareto","rgsl::randist","",N,N],[5,"pareto","rgsl::randist::pareto","This function returns a random variate from the Pareto distribution of order a. The distribution function is,",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"pareto_pdf","","This function computes the probability density p(x) at x for a Pareto distribution with exponent a and scale b, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"pareto_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Pareto distribution with exponent a and scale b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"pareto_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Pareto distribution with exponent a and scale b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"pareto_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Pareto distribution with exponent a and scale b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"pareto_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Pareto distribution with exponent a and scale b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[0,"pascal","rgsl::randist","",N,N],[5,"pascal","rgsl::randist::pascal","This function returns a random integer from the Pascal distribution. The Pascal distribution is simply a negative binomial distribution with an integer value of n.",N,[[["rng"],["f64"],["u32"]],["u32"]]],[5,"pascal_pdf","","This function computes the probability p(k) of obtaining k from a Pascal distribution with parameters p and n, using the formula given above.",N,[[["u32"],["f64"],["u32"]],["f64"]]],[5,"pascal_P","","This function computes the cumulative distribution functions P(k), Q(k) for the Pascal distribution with parameters p and n.",N,[[["u32"],["f64"],["u32"]],["f64"]]],[5,"pascal_Q","","This function computes the cumulative distribution functions P(k), Q(k) for the Pascal distribution with parameters p and n.",N,[[["u32"],["f64"],["u32"]],["f64"]]],[0,"poisson","rgsl::randist","",N,N],[5,"poisson","rgsl::randist::poisson","This function returns a random integer from the Poisson distribution with mean mu. The probability distribution for Poisson variates is,",N,[[["rng"],["f64"]],["u32"]]],[5,"poisson_pdf","","This function computes the probability p(k) of obtaining k from a Poisson distribution with mean mu, using the formula given above.",N,[[["u32"],["f64"]],["f64"]]],[5,"poisson_P","","This function computes the cumulative distribution functions P(k), Q(k) for the Poisson distribution with parameter mu.",N,[[["u32"],["f64"]],["f64"]]],[5,"poisson_Q","","This function computes the cumulative distribution functions P(k), Q(k) for the Poisson distribution with parameter mu.",N,[[["u32"],["f64"]],["f64"]]],[0,"rayleigh","rgsl::randist","",N,N],[5,"rayleigh","rgsl::randist::rayleigh","This function returns a random variate from the Rayleigh distribution with scale parameter sigma. The distribution is,",N,[[["rng"],["f64"]],["f64"]]],[5,"rayleigh_pdf","","This function computes the probability density p(x) at x for a Rayleigh distribution with scale parameter sigma, using the formula given above.",N,[[["f64"],["f64"]],["f64"]]],[5,"rayleigh_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Rayleigh distribution with scale parameter sigma.",N,[[["f64"],["f64"]],["f64"]]],[5,"rayleigh_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Rayleigh distribution with scale parameter sigma.",N,[[["f64"],["f64"]],["f64"]]],[5,"rayleigh_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Rayleigh distribution with scale parameter sigma.",N,[[["f64"],["f64"]],["f64"]]],[5,"rayleigh_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Rayleigh distribution with scale parameter sigma.",N,[[["f64"],["f64"]],["f64"]]],[0,"rayleigh_tail","rgsl::randist","",N,N],[5,"rayleigh_tail","rgsl::randist::rayleigh_tail","This function returns a random variate from the tail of the Rayleigh distribution with scale parameter sigma and a lower limit of a. The distribution is,",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"rayleigh_tail_pdf","","This function computes the probability density p(x) at x for a Rayleigh tail distribution with scale parameter sigma and lower limit a, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[0,"shuffling_sampling","rgsl::randist","The following functions allow the shuffling and sampling of a set of objects. The algorithms rely on a random number generator as a source of randomness and a poor quality generator can lead to correlations in the output. In particular it is important to avoid generators with a short period. For more information see Knuth, v2, 3rd ed, Section 3.4.2, Random Sampling and Shuffling.",N,N],[5,"shuffle","rgsl::randist::shuffling_sampling","This function randomly shuffles the order of n objects, each of size size, stored in the array base[0..n-1]. The output of the random number generator r is used to produce the permutation. The algorithm generates all possible n! permutations with equal probability, assuming a perfect source of random numbers.",N,N],[5,"choose","","This function fills the array dest[k] with k objects taken randomly from the n elements of the array src[0..n-1]. The objects are each of size size. The output of the random number generator r is used to make the selection. The algorithm ensures all possible samples are equally likely, assuming a perfect source of randomness.",N,N],[5,"sample","","This function is like gsl_ran_choose but samples k items from the original array of n items src with replacement, so the same object can appear more than once in the output sequence dest. There is no requirement that k be less than n in this case.",N,N],[0,"spherical_vector","rgsl::randist","The spherical distributions generate random vectors, located on a spherical surface. They can be used as random directions, for example in the steps of a random walk.",N,N],[5,"dir_2d","rgsl::randist::spherical_vector","This function returns a random direction vector v = (x,y) in two dimensions. The vector is normalized such that |v|^2 = x^2 + y^2 = 1. The obvious way to do this is to take a uniform random number between 0 and 2\\pi and let x and y be the sine and cosine respectively. Two trig functions would have been expensive in the old days, but with modern hardware implementations, this is sometimes the fastest way to go. This is the case for the Pentium (but not the case for the Sun Sparcstation). One can avoid the trig evaluations by choosing x and y in the interior of a unit circle (choose them at random from the interior of the enclosing square, and then reject those that are outside the unit circle), and then dividing by \\sqrt{x^2 + y^2}. A much cleverer approach, attributed to von Neumann (See Knuth, v2, 3rd ed, p140, exercise 23), requires neither trig nor a square root. In this approach, u and v are chosen at random from the interior of a unit circle, and then x=(u^2-v^2)/(u^2+v^2) and y=2uv/(u^2+v^2).",N,[[["rng"],["f64"],["f64"]]]],[5,"dir_2d_trig_method","","This function returns a random direction vector v = (x,y) in two dimensions. The vector is normalized such that |v|^2 = x^2 + y^2 = 1. The obvious way to do this is to take a uniform random number between 0 and 2\\pi and let x and y be the sine and cosine respectively. Two trig functions would have been expensive in the old days, but with modern hardware implementations, this is sometimes the fastest way to go. This is the case for the Pentium (but not the case for the Sun Sparcstation). One can avoid the trig evaluations by choosing x and y in the interior of a unit circle (choose them at random from the interior of the enclosing square, and then reject those that are outside the unit circle), and then dividing by \\sqrt{x^2 + y^2}. A much cleverer approach, attributed to von Neumann (See Knuth, v2, 3rd ed, p140, exercise 23), requires neither trig nor a square root. In this approach, u and v are chosen at random from the interior of a unit circle, and then x=(u^2-v^2)/(u^2+v^2) and y=2uv/(u^2+v^2).",N,[[["rng"],["f64"],["f64"]]]],[5,"dir_3d","","This function returns a random direction vector v = (x,y,z) in three dimensions. The vector is normalized such that |v|^2 = x^2 + y^2 + z^2 = 1. The method employed is due to Robert E. Knop (CACM 13, 326 (1970)), and explained in Knuth, v2, 3rd ed, p136. It uses the surprising fact that the distribution projected along any axis is actually uniform (this is only true for 3 dimensions).",N,[[["rng"],["f64"],["f64"],["f64"]]]],[5,"dir_nd","","This function returns a random direction vector v = (x_1,x_2,...,x_n) in n dimensions. The vector is normalized such that |v|^2 = x_1^2 + x_2^2 + ... + x_n^2 = 1. The method uses the fact that a multivariate Gaussian distribution is spherically symmetric. Each component is generated to have a Gaussian distribution, and then the components are normalized. The method is described by Knuth, v2, 3rd ed, p135136, and attributed to G. W. Brown, Modern Mathematics for the Engineer (1956).",N,N],[0,"t_distribution","rgsl::randist","The t-distribution arises in statistics. If Y_1 has a normal distribution and Y_2 has a chi-squared distribution with \\nu degrees of freedom then the ratio,",N,N],[5,"tdist","rgsl::randist::t_distribution","This function returns a random variate from the t-distribution. The distribution function is,",N,[[["rng"],["f64"]],["f64"]]],[5,"tdist_pdf","","This function computes the probability density p(x) at x for a t-distribution with nu degrees of freedom, using the formula given above.",N,[[["f64"],["f64"]],["f64"]]],[5,"tdist_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the t-distribution with nu degrees of freedom.",N,[[["f64"],["f64"]],["f64"]]],[5,"tdist_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the t-distribution with nu degrees of freedom.",N,[[["f64"],["f64"]],["f64"]]],[5,"tdist_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the t-distribution with nu degrees of freedom.",N,[[["f64"],["f64"]],["f64"]]],[5,"tdist_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the t-distribution with nu degrees of freedom.",N,[[["f64"],["f64"]],["f64"]]],[0,"weibull","rgsl::randist","",N,N],[5,"weibull","rgsl::randist::weibull","This function returns a random variate from the Weibull distribution. The distribution function is,",N,[[["rng"],["f64"],["f64"]],["f64"]]],[5,"weibull_pdf","","This function computes the probability density p(x) at x for a Weibull distribution with scale a and exponent b, using the formula given above.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"weibull_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Weibull distribution with scale a and exponent b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"weibull_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Weibull distribution with scale a and exponent b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"weibull_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Weibull distribution with scale a and exponent b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"weibull_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Weibull distribution with scale a and exponent b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[0,"types","rgsl","",N,N],[3,"RootFunction","rgsl::types","",N,N],[12,"function","","",0,N],[12,"params","","",0,N],[3,"RootFunctionFdf","","",N,N],[12,"f","","",1,N],[12,"df","","",1,N],[12,"fdf","","",1,N],[12,"params","","",1,N],[0,"basis_spline","","B-splines are commonly used as basis functions to fit smoothing curves to large data sets. To do this, the abscissa axis is broken up into some number of intervals, where the endpoints of each interval are called breakpoints.",N,N],[3,"BSpLineWorkspace","rgsl::types::basis_spline","",N,N],[3,"BSpLineDerivWorkspace","","",N,N],[11,"new","","This function allocates a workspace for computing B-splines of order k.",13,[[["usize"],["usize"]],["option",["bsplineworkspace"]]]],[11,"knots","","This function computes the knots associated with the given breakpoints and stores them internally in w->knots.",13,[[["self"],["vectorf64"]],["value"]]],[11,"knots_uniform","","This function assumes uniformly spaced breakpoints on [a,b] and constructs the corresponding knot vector using the previously specified nbreak parameter. The knots are stored in w->knots.",13,[[["self"],["f64"],["f64"]],["value"]]],[11,"eval","","This function evaluates all B-spline basis functions at the position x and stores them in the vector B, so that the i-th element is B_i(x).",13,[[["self"],["f64"],["vectorf64"]],["value"]]],[11,"eval_non_zero","","This function evaluates all potentially nonzero B-spline basis functions at the position x and stores them in the vector Bk, so that the i-th element is B_(istart+i)(x).",13,[[["self"],["f64"],["vectorf64"],["usize"],["usize"]],["value"]]],[11,"ncoeffs","","This function returns the number of B-spline coefficients given by n = nbreak + k - 2.",13,[[["self"]],["usize"]]],[11,"greville_abscissa","","The Greville abscissae are defined to be the mean location of k-1 consecutive knots in the knot vector for each basis spline function of order k.",13,[[["self"],["usize"]],["f64"]]],[11,"new","","This function allocates a workspace for computing the derivatives of a B-spline basis function of order k.",14,[[["usize"]],["option",["bsplinederivworkspace"]]]],[11,"eval","","This function evaluates all B-spline basis function derivatives of orders 0 through nderiv (inclusive) at the position x and stores them in the matrix dB. The (i,j)-th element of dB is d^jB_i(x)/dx^j. The matrix dB must be of size n = nbreak + k - 2 by nderiv + 1. The value n may also be obtained by calling gsl_bspline_ncoeffs. Note that function evaluations are included as the zeroth order derivatives in dB. Computing all the basis function derivatives at once is more efficient than computing them individually, due to the nature of the defining recurrence relation.",14,[[["self"],["f64"],["usize"],["matrixf64"],["bsplineworkspace"]],["value"]]],[11,"eval_non_zero","","This function evaluates all potentially nonzero B-spline basis function derivatives of orders 0 through nderiv (inclusive) at the position x and stores them in the matrix dB.",14,[[["self"],["f64"],["usize"],["matrixf64"],["usize"],["usize"],["bsplineworkspace"]],["value"]]],[0,"chebyshev","rgsl::types","#Chebyshev Approximations",N,N],[3,"ChebSeries","rgsl::types::chebyshev","",N,N],[11,"new","","",15,[[["usize"]],["option",["chebseries"]]]],[11,"init","","This function computes the Chebyshev approximation cs for the function f over the range (a,b) to the previously specified order. The computation of the Chebyshev approximation is an O(n^2) process, and requires n function evaluations.",15,[[["self"],["function"],["f64"],["f64"],["t"]],["value"]]],[11,"order","","This function returns the order of Chebyshev series cs.",15,[[["self"]],["usize"]]],[11,"size","","This function returns the size of the Chebyshev coefficient array c[] for the Chebyshev series cs.",15,[[["self"]],["usize"]]],[11,"as_slice","","This function returns a pointer to the coefficient array c[] location in memory for the Chebyshev series cs.",15,N],[11,"as_mut_slice","","This function returns a pointer to the coefficient array c[] location in memory for the Chebyshev series cs.",15,N],[11,"eval","","This function evaluates the Chebyshev series cs at a given point x.",15,[[["self"],["f64"]],["f64"]]],[11,"eval_err","","This function computes the Chebyshev series cs at a given point x, estimating both the series result and its absolute error abserr. The error estimate is made from the first neglected term in the series.",15,[[["self"],["f64"],["f64"],["f64"]],["value"]]],[11,"eval_n","","This function evaluates the Chebyshev series cs at a given point x, to (at most) the given order order.",15,[[["self"],["usize"],["f64"]],["f64"]]],[11,"eval_n_err","","This function evaluates a Chebyshev series cs at a given point x, estimating both the series result and its absolute error abserr, to (at most) the given order order. The error estimate is made from the first neglected term in the series.",15,[[["self"],["usize"],["f64"],["f64"],["f64"]],["value"]]],[11,"calc_deriv","","This function computes the derivative of the series cs, storing the derivative coefficients in the previously allocated deriv. The two series cs and deriv must have been allocated with the same order.",15,[[["self"],["chebseries"]],["value"]]],[11,"calc_integ","","This function computes the integral of the series cs, storing the integral coefficients in the previously allocated integ. The two series cs and integ must have been allocated with the same order. The lower limit of the integration is taken to be the left hand end of the range a.",15,[[["self"],["chebseries"]],["value"]]],[0,"combination","rgsl::types","#Combinations",N,N],[3,"Combination","rgsl::types::combination","",N,N],[11,"new","","This function allocates memory for a new combination with parameters n, k. The combination is not initialized and its elements are undefined. Use the function `Combination::new_init_first` if you want to create a combination which is initialized to the lexicographically first combination. A null pointer is returned if insufficient memory is available to create the combination.",16,[[["usize"],["usize"]],["option",["combination"]]]],[11,"new_init_first","","This function allocates memory for a new combination with parameters n, k and initializes it to the lexicographically first combination. A null pointer is returned if insufficient memory is available to create the combination.",16,[[["usize"],["usize"]],["option",["combination"]]]],[11,"init_first","","This function initializes the combination c to the lexicographically first combination, i.e. (0,1,2,...,k-1).",16,[[["self"]]]],[11,"init_last","","This function initializes the combination c to the lexicographically last combination, i.e. (n-k,n-k+1,,n-1).",16,[[["self"]]]],[11,"copy","","This function copies the elements of the combination self into the combination dest. The two combinations must have the same size.",16,[[["self"],["combination"]],["value"]]],[11,"get","","This function returns the value of the i-th element of the combination self. If i lies outside the allowed range of 0 to k-1 then the error handler is invoked and 0 is returned.",16,[[["self"],["usize"]],["usize"]]],[11,"n","","This function returns the range (n) of the combination self.",16,[[["self"]],["usize"]]],[11,"k","","This function returns the number of elements (k) in the combination self.",16,[[["self"]],["usize"]]],[11,"as_slice","","This function returns a pointer to the array of elements in the combination self.",16,N],[11,"as_mut_slice","","This function returns a pointer to the array of elements in the combination self.",16,N],[11,"is_valid","","This function checks that the combination self is valid. The k elements should lie in the range 0 to n-1, with each value occurring once at most and in increasing order.",16,[[["self"]],["value"]]],[11,"next","","This function advances the combination self to the next combination in lexicographic order and returns `Success`. If no further combinations are available it returns Failure and leaves self unmodified. Starting with the first combination and repeatedly applying this function will iterate through all possible combinations of a given order.",16,[[["self"]],["value"]]],[11,"prev","","This function steps backwards from the combination self to the previous combination in lexicographic order, returning `Success`. If no previous combination is available it returns `Failure` and leaves self unmodified.",16,[[["self"]],["value"]]],[0,"complex","rgsl::types","",N,N],[3,"ComplexF64","rgsl::types::complex","",N,N],[12,"dat","","",17,N],[3,"ComplexF32","","",N,N],[12,"dat","","",18,N],[11,"rect","","This function uses the rectangular Cartesian components (x,y) to return the complex number z = x + i y.",17,[[["f64"],["f64"]],["complexf64"]]],[11,"polar","","This function returns the complex number z = r \\exp(i \\theta) = r (\\cos(\\theta) + i \\sin(\\theta)) from the polar representation (r,theta).",17,[[["f64"],["f64"]],["complexf64"]]],[11,"arg","","This function returns the argument of the complex number z, \\arg(z), where -\\pi < \\arg(z) <= \\pi.",17,[[["self"]],["f64"]]],[11,"abs","","This function returns the magnitude of the complex number z, |z|.",17,[[["self"]],["f64"]]],[11,"abs2","","This function returns the squared magnitude of the complex number z, |z|^2.",17,[[["self"]],["f64"]]],[11,"logabs","","This function returns the natural logarithm of the magnitude of the complex number z, \\log|z|.",17,[[["self"]],["f64"]]],[11,"add","","This function returns the sum of the complex numbers a and b, z=a+b.",17,[[["self"],["complexf64"]],["complexf64"]]],[11,"sub","","This function returns the difference of the complex numbers a and b, z=a-b.",17,[[["self"],["complexf64"]],["complexf64"]]],[11,"mul","","This function returns the product of the complex numbers a and b, z=ab.",17,[[["self"],["complexf64"]],["complexf64"]]],[11,"div","","This function returns the quotient of the complex numbers a and b, z=a/b.",17,[[["self"],["complexf64"]],["complexf64"]]],[11,"add_real","","This function returns the sum of the complex number a and the real number x, z=a+x.",17,[[["self"],["f64"]],["complexf64"]]],[11,"sub_real","","This function returns the difference of the complex number a and the real number x, z=a-x.",17,[[["self"],["f64"]],["complexf64"]]],[11,"mul_real","","This function returns the product of the complex number a and the real number x, z=ax.",17,[[["self"],["f64"]],["complexf64"]]],[11,"div_real","","This function returns the quotient of the complex number a and the real number x, z=a/x.",17,[[["self"],["f64"]],["complexf64"]]],[11,"add_imag","","This function returns the sum of the complex number a and the imaginary number iy, z=a+iy.",17,[[["self"],["f64"]],["complexf64"]]],[11,"sub_imag","","This function returns the difference of the complex number a and the imaginary number iy, z=a-iy.",17,[[["self"],["f64"]],["complexf64"]]],[11,"mul_imag","","This function returns the product of the complex number a and the imaginary number iy, z=a*(iy).",17,[[["self"],["f64"]],["complexf64"]]],[11,"div_imag","","This function returns the quotient of the complex number a and the imaginary number iy, z=a/(iy).",17,[[["self"],["f64"]],["complexf64"]]],[11,"conjugate","","This function returns the complex conjugate of the complex number z, z^* = x - i y.",17,[[["self"]],["complexf64"]]],[11,"inverse","","This function returns the inverse, or reciprocal, of the complex number z, 1/z = (x - i y)/ (x^2 + y^2).",17,[[["self"]],["complexf64"]]],[11,"negative","","This function returns the negative of the complex number z, -z = (-x) + i(-y).",17,[[["self"]],["complexf64"]]],[11,"sqrt","","This function returns the square root of the complex number z, \\sqrt z.",17,[[["self"]],["complexf64"]]],[11,"sqrt_real","","This function returns the complex square root of the real number x, where x may be negative.",17,[[["f64"]],["complexf64"]]],[11,"pow","","The function returns the complex number z raised to the complex power a, z^a. This is computed as \\exp(\\log(z)*a) using complex logarithms and complex exponentials.",17,[[["self"],["complexf64"]],["complexf64"]]],[11,"pow_real","","This function returns the complex number z raised to the real power x, z^x.",17,[[["self"],["f64"]],["complexf64"]]],[11,"exp","","This function returns the complex exponential of the complex number z, \\exp(z).",17,[[["self"]],["complexf64"]]],[11,"log","","This function returns the complex natural logarithm (base e) of the complex number z, \\log(z).",17,[[["self"]],["complexf64"]]],[11,"log10","","This function returns the complex base-10 logarithm of the complex number z, \\log_10 (z).",17,[[["self"]],["complexf64"]]],[11,"log_b","","This function returns the complex base-b logarithm of the complex number z, \\log_b(z). This quantity is computed as the ratio \\log(z)/\\log(b).",17,[[["self"],["complexf64"]],["complexf64"]]],[11,"sin","","This function returns the complex sine of the complex number z, \\sin(z) = (\\exp(iz) - \\exp(-iz))/(2i).",17,[[["self"]],["complexf64"]]],[11,"cos","","This function returns the complex cosine of the complex number z, \\cos(z) = (\\exp(iz) + \\exp(-iz))/2.",17,[[["self"]],["complexf64"]]],[11,"tan","","This function returns the complex tangent of the complex number z, \\tan(z) = \\sin(z)/\\cos(z).",17,[[["self"]],["complexf64"]]],[11,"sec","","This function returns the complex secant of the complex number z, \\sec(z) = 1/\\cos(z).",17,[[["self"]],["complexf64"]]],[11,"csc","","This function returns the complex cosecant of the complex number z, \\csc(z) = 1/\\sin(z).",17,[[["self"]],["complexf64"]]],[11,"cot","","This function returns the complex cotangent of the complex number z, \\cot(z) = 1/\\tan(z).",17,[[["self"]],["complexf64"]]],[11,"arcsin","","This function returns the complex arcsine of the complex number z, \\arcsin(z). The branch cuts are on the real axis, less than -1 and greater than 1.",17,[[["self"]],["complexf64"]]],[11,"arcsin_real","","This function returns the complex arcsine of the real number z, \\arcsin(z).",17,[[["f64"]],["complexf64"]]],[11,"arccos","","This function returns the complex arccosine of the complex number z, \\arccos(z). The branch cuts are on the real axis, less than -1 and greater than 1.",17,[[["self"]],["complexf64"]]],[11,"arccos_real","","This function returns the complex arccosine of the real number z, \\arccos(z).",17,[[["f64"]],["complexf64"]]],[11,"arctan","","This function returns the complex arctangent of the complex number z, \\arctan(z). The branch cuts are on the imaginary axis, below -i and above i.",17,[[["self"]],["complexf64"]]],[11,"arcsec","","This function returns the complex arcsecant of the complex number z, \\arcsec(z) = \\arccos(1/z).",17,[[["self"]],["complexf64"]]],[11,"arcsec_real","","This function returns the complex arcsecant of the real number z, \\arcsec(z) = \\arccos(1/z).",17,[[["f64"]],["complexf64"]]],[11,"arccsc","","This function returns the complex arccosecant of the complex number z, \\arccsc(z) = \\arcsin(1/z).",17,[[["self"]],["complexf64"]]],[11,"arccsc_real","","This function returns the complex arccosecant of the real number z, \\arccsc(z) = \\arcsin(1/z).",17,[[["f64"]],["complexf64"]]],[11,"arccot","","This function returns the complex arccotangent of the complex number z, \\arccot(z) = \\arctan(1/z).",17,[[["self"]],["complexf64"]]],[11,"sinh","","This function returns the complex hyperbolic sine of the complex number z, \\sinh(z) = (\\exp(z) - \\exp(-z))/2.",17,[[["self"]],["complexf64"]]],[11,"cosh","","This function returns the complex hyperbolic cosine of the complex number z, \\cosh(z) = (\\exp(z) + \\exp(-z))/2.",17,[[["self"]],["complexf64"]]],[11,"tanh","","This function returns the complex hyperbolic tangent of the complex number z, \\tanh(z) = \\sinh(z)/\\cosh(z).",17,[[["self"]],["complexf64"]]],[11,"sech","","This function returns the complex hyperbolic secant of the complex number z, \\sech(z) = 1/\\cosh(z).",17,[[["self"]],["complexf64"]]],[11,"csch","","This function returns the complex hyperbolic cosecant of the complex number z, \\csch(z) = 1/\\sinh(z).",17,[[["self"]],["complexf64"]]],[11,"coth","","This function returns the complex hyperbolic cotangent of the complex number z, \\coth(z) = 1/\\tanh(z).",17,[[["self"]],["complexf64"]]],[11,"arcsinh","","This function returns the complex hyperbolic arcsine of the complex number z, \\arcsinh(z). The branch cuts are on the imaginary axis, below -i and above i.",17,[[["self"]],["complexf64"]]],[11,"arccosh","","This function returns the complex hyperbolic arccosine of the complex number z, \\arccosh(z). The branch cut is on the real axis, less than 1. Note that in this case we use the negative square root in formula 4.6.21 of Abramowitz & Stegun giving \\arccosh(z)=\\log(z-\\sqrt{z^2-1}).",17,[[["self"]],["complexf64"]]],[11,"arccosh_real","","This function returns the complex hyperbolic arccosine of the real number z, \\arccosh(z).",17,[[["f64"]],["complexf64"]]],[11,"arctanh","","This function returns the complex hyperbolic arctangent of the complex number z, \\arctanh(z).",17,[[["self"]],["complexf64"]]],[11,"arctanh_real","","This function returns the complex hyperbolic arctangent of the real number z, \\arctanh(z).",17,[[["f64"]],["complexf64"]]],[11,"arcsech","","This function returns the complex hyperbolic arcsecant of the complex number z, \\arcsech(z) = \\arccosh(1/z).",17,[[["self"]],["complexf64"]]],[11,"arccsch","","This function returns the complex hyperbolic arccosecant of the complex number z, \\arccsch(z) = \\arcsin(1/z).",17,[[["self"]],["complexf64"]]],[11,"arccoth","","This function returns the complex hyperbolic arccotangent of the complex number z, \\arccoth(z) = \\arctanh(1/z).",17,[[["self"]],["complexf64"]]],[11,"rect","","This function uses the rectangular Cartesian components (x,y) to return the complex number z = x + i y.",18,[[["f32"],["f32"]],["complexf32"]]],[11,"polar","","This function returns the complex number z = r \\exp(i \\theta) = r (\\cos(\\theta) + i \\sin(\\theta)) from the polar representation (r,theta).",18,[[["f32"],["f32"]],["complexf32"]]],[11,"arg","","This function returns the argument of the complex number z, \\arg(z), where -\\pi < \\arg(z) <= \\pi.",18,[[["self"]],["f32"]]],[11,"abs","","This function returns the magnitude of the complex number z, |z|.",18,[[["self"]],["f32"]]],[11,"abs2","","This function returns the squared magnitude of the complex number z, |z|^2.",18,[[["self"]],["f32"]]],[11,"logabs","","This function returns the natural logarithm of the magnitude of the complex number z, \\log|z|.",18,[[["self"]],["f32"]]],[11,"add","","This function returns the sum of the complex numbers a and b, z=a+b.",18,[[["self"],["complexf32"]],["complexf32"]]],[11,"sub","","This function returns the difference of the complex numbers a and b, z=a-b.",18,[[["self"],["complexf32"]],["complexf32"]]],[11,"mul","","This function returns the product of the complex numbers a and b, z=ab.",18,[[["self"],["complexf32"]],["complexf32"]]],[11,"div","","This function returns the quotient of the complex numbers a and b, z=a/b.",18,[[["self"],["complexf32"]],["complexf32"]]],[11,"add_real","","This function returns the sum of the complex number a and the real number x, z=a+x.",18,[[["self"],["f32"]],["complexf32"]]],[11,"sub_real","","This function returns the difference of the complex number a and the real number x, z=a-x.",18,[[["self"],["f32"]],["complexf32"]]],[11,"mul_real","","This function returns the product of the complex number a and the real number x, z=ax.",18,[[["self"],["f32"]],["complexf32"]]],[11,"div_real","","This function returns the quotient of the complex number a and the real number x, z=a/x.",18,[[["self"],["f32"]],["complexf32"]]],[11,"add_imag","","This function returns the sum of the complex number a and the imaginary number iy, z=a+iy.",18,[[["self"],["f32"]],["complexf32"]]],[11,"sub_imag","","This function returns the difference of the complex number a and the imaginary number iy, z=a-iy.",18,[[["self"],["f32"]],["complexf32"]]],[11,"mul_imag","","This function returns the product of the complex number a and the imaginary number iy, z=a*(iy).",18,[[["self"],["f32"]],["complexf32"]]],[11,"div_imag","","This function returns the quotient of the complex number a and the imaginary number iy, z=a/(iy).",18,[[["self"],["f32"]],["complexf32"]]],[11,"conjugate","","This function returns the complex conjugate of the complex number z, z^* = x - i y.",18,[[["self"]],["complexf32"]]],[11,"inverse","","This function returns the inverse, or reciprocal, of the complex number z, 1/z = (x - i y)/ (x^2 + y^2).",18,[[["self"]],["complexf32"]]],[11,"negative","","This function returns the negative of the complex number z, -z = (-x) + i(-y).",18,[[["self"]],["complexf32"]]],[11,"sqrt","","This function returns the square root of the complex number z, \\sqrt z.",18,[[["self"]],["complexf32"]]],[11,"sqrt_real","","This function returns the complex square root of the real number x, where x may be negative.",18,[[["f32"]],["complexf32"]]],[11,"pow","","The function returns the complex number z raised to the complex power a, z^a.",18,[[["self"],["complexf32"]],["complexf32"]]],[11,"pow_real","","This function returns the complex number z raised to the real power x, z^x.",18,[[["self"],["f32"]],["complexf32"]]],[11,"exp","","This function returns the complex exponential of the complex number z, \\exp(z).",18,[[["self"]],["complexf32"]]],[11,"log","","This function returns the complex natural logarithm (base e) of the complex number z, \\log(z). The branch cut is the negative real axis.",18,[[["self"]],["complexf32"]]],[11,"log10","","This function returns the complex base-10 logarithm of the complex number z, \\log_10 (z).",18,[[["self"]],["complexf32"]]],[11,"log_b","","This function returns the complex base-b logarithm of the complex number z, \\log_b(z). This quantity is computed as the ratio \\log(z)/\\log(b).",18,[[["self"],["complexf32"]],["complexf32"]]],[11,"sin","","This function returns the complex sine of the complex number z, \\sin(z) = (\\exp(iz) - \\exp(-iz))/(2i).",18,[[["self"]],["complexf32"]]],[11,"cos","","This function returns the complex cosine of the complex number z, \\cos(z) = (\\exp(iz) + \\exp(-iz))/2.",18,[[["self"]],["complexf32"]]],[11,"tan","","This function returns the complex tangent of the complex number z, \\tan(z) = \\sin(z)/\\cos(z).",18,[[["self"]],["complexf32"]]],[11,"sec","","This function returns the complex secant of the complex number z, \\sec(z) = 1/\\cos(z).",18,[[["self"]],["complexf32"]]],[11,"csc","","This function returns the complex cosecant of the complex number z, \\csc(z) = 1/\\sin(z).",18,[[["self"]],["complexf32"]]],[11,"cot","","This function returns the complex cotangent of the complex number z, \\cot(z) = 1/\\tan(z).",18,[[["self"]],["complexf32"]]],[11,"arcsin","","This function returns the complex arcsine of the complex number z, \\arcsin(z). The branch cuts are on the real axis, less than -1 and greater than 1.",18,[[["self"]],["complexf32"]]],[11,"arcsin_real","","This function returns the complex arcsine of the real number z, \\arcsin(z).",18,[[["f32"]],["complexf32"]]],[11,"arccos","","This function returns the complex arccosine of the complex number z, \\arccos(z). The branch cuts are on the real axis, less than -1 and greater than 1.",18,[[["self"]],["complexf32"]]],[11,"arccos_real","","This function returns the complex arccosine of the real number z, \\arccos(z).",18,[[["f32"]],["complexf32"]]],[11,"arctan","","This function returns the complex arctangent of the complex number z, \\arctan(z). The branch cuts are on the imaginary axis, below -i and above i.",18,[[["self"]],["complexf32"]]],[11,"arcsec","","This function returns the complex arcsecant of the complex number z, \\arcsec(z) =  \\arccos(1/z).",18,[[["self"]],["complexf32"]]],[11,"arcsec_real","","This function returns the complex arcsecant of the real number z, \\arcsec(z) = \\arccos(1/z).",18,[[["f32"]],["complexf32"]]],[11,"arccsc","","This function returns the complex arccosecant of the complex number z, \\arccsc(z) = \\arcsin(1/z).",18,[[["self"]],["complexf32"]]],[11,"arccsc_real","","This function returns the complex arccosecant of the real number z, \\arccsc(z) = \\arcsin(1/z).",18,[[["f32"]],["complexf32"]]],[11,"arccot","","This function returns the complex arccotangent of the complex number z, \\arccot(z) = \\arctan(1/z).",18,[[["self"]],["complexf32"]]],[11,"sinh","","This function returns the complex hyperbolic sine of the complex number z, \\sinh(z) = (\\exp(z) - \\exp(-z))/2.",18,[[["self"]],["complexf32"]]],[11,"cosh","","This function returns the complex hyperbolic cosine of the complex number z, \\cosh(z) = (\\exp(z) + \\exp(-z))/2.",18,[[["self"]],["complexf32"]]],[11,"tanh","","This function returns the complex hyperbolic tangent of the complex number z, \\tanh(z) = \\sinh(z)/\\cosh(z).",18,[[["self"]],["complexf32"]]],[11,"sech","","This function returns the complex hyperbolic secant of the complex number z, \\sech(z) = 1/\\cosh(z).",18,[[["self"]],["complexf32"]]],[11,"csch","","This function returns the complex hyperbolic cosecant of the complex number z, \\csch(z) = 1/\\sinh(z).",18,[[["self"]],["complexf32"]]],[11,"coth","","This function returns the complex hyperbolic cotangent of the complex number z, \\coth(z) = 1/\\tanh(z).",18,[[["self"]],["complexf32"]]],[11,"arcsinh","","This function returns the complex hyperbolic arcsine of the complex number z, \\arcsinh(z). The branch cuts are on the imaginary axis, below -i and above i.",18,[[["self"]],["complexf32"]]],[11,"arccosh","","This function returns the complex hyperbolic arccosine of the complex number z, \\arccosh(z).",18,[[["self"]],["complexf32"]]],[11,"arccosh_real","","This function returns the complex hyperbolic arccosine of the real number z, \\arccosh(z).",18,[[["f32"]],["complexf32"]]],[11,"arctanh","","This function returns the complex hyperbolic arctangent of the complex number z,  arctanh(z).",18,[[["self"]],["complexf32"]]],[11,"arctanh_real","","This function returns the complex hyperbolic arctangent of the real number z, \\arctanh(z).",18,[[["f32"]],["complexf32"]]],[11,"arcsech","","This function returns the complex hyperbolic arcsecant of the complex number z, \\arcsech(z) = \\arccosh(1/z).",18,[[["self"]],["complexf32"]]],[11,"arccsch","","This function returns the complex hyperbolic arccosecant of the complex number z, \\arccsch(z) = \\arcsin(1/z).",18,[[["self"]],["complexf32"]]],[11,"arccoth","","This function returns the complex hyperbolic arccotangent of the complex number z, \\arccoth(z) = \\arctanh(1/z).",18,[[["self"]],["complexf32"]]],[0,"discrete_hankel","rgsl::types","#Discrete Hankel Transforms",N,N],[3,"DiscreteHankel","rgsl::types::discrete_hankel","",N,N],[11,"new","","This function allocates a Discrete Hankel transform object of size `size`.",19,[[["usize"]],["option",["discretehankel"]]]],[11,"new_with_init","","This function allocates a Discrete Hankel transform object of size `size` and initializes it for the given values of `nu` and `xmax`.",19,[[["usize"],["f64"],["f64"]],["option",["discretehankel"]]]],[11,"init","","This function initializes the transform `self` for the given values of `nu` and `xmax`.",19,[[["self"],["f64"],["f64"]],["value"]]],[11,"apply","","This function applies the transform t to the array f_in whose size is equal to the size of the transform. The result is stored in the array `f_out` which must be of the same length.",19,N],[11,"x_sample","","This function returns the value of the n-th sample point in the unit interval, (j_{\\nu,n+1}/j_{\\nu,M}) X. These are the points where the function f(t) is assumed to be sampled.",19,[[["self"],["i32"]],["f64"]]],[11,"k_sample","","This function returns the value of the n-th sample point in k-space, j_{\\nu,n+1}/X.",19,[[["self"],["i32"]],["f64"]]],[0,"eigen_symmetric_workspace","rgsl::types","#Real Symmetric Matrices",N,N],[3,"EigenSymmetricWorkspace","rgsl::types::eigen_symmetric_workspace","",N,N],[3,"EigenSymmetricVWorkspace","","",N,N],[3,"EigenHermitianWorkspace","","",N,N],[3,"EigenHermitianVWorkspace","","",N,N],[3,"EigenNonSymmWorkspace","","",N,N],[3,"EigenNonSymmVWorkspace","","",N,N],[3,"EigenGenSymmWorkspace","","",N,N],[3,"EigenGenSymmVWorkspace","","",N,N],[3,"EigenGenHermWorkspace","","",N,N],[3,"EigenGenHermVWorkspace","","",N,N],[3,"EigenGenWorkspace","","",N,N],[3,"EigenGenVWorkspace","","",N,N],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n real symmetric matrices. The size of the workspace is O(2n).",20,[[["usize"]],["option",["eigensymmetricworkspace"]]]],[11,"symm","","This function computes the eigenvalues of the real symmetric matrix `A`. The diagonal and lower triangular part of `A` are destroyed during the computation, but the strict upper triangular part is not referenced. The eigenvalues are stored in the vector `eval` and are unordered.",20,[[["self"],["matrixf64"],["vectorf64"]],["value"]]],[11,"new","","This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n real symmetric matrices. The size of the workspace is O(4n).",21,[[["usize"]],["option",["eigensymmetricvworkspace"]]]],[11,"symmv","","This function computes the eigenvalues and eigenvectors of the real symmetric matrix `A`. The diagonal and lower triangular part of `A` are destroyed during the computation, but the strict upper triangular part is not referenced. The eigenvalues are stored in the vector `eval` and are unordered. The corresponding eigenvectors are stored in the columns of the matrix `evec`. For example, the eigenvector in the first column corresponds to the first eigenvalue. The eigenvectors are guaranteed to be mutually orthogonal and normalised to unit magnitude.",21,[[["self"],["matrixf64"],["vectorf64"],["matrixf64"]],["value"]]],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n complex hermitian matrices. The size of the workspace is O(3n).",22,[[["usize"]],["option",["eigenhermitianworkspace"]]]],[11,"herm","","This function computes the eigenvalues of the complex hermitian matrix `A`. Additional workspace of the appropriate size must be provided in `self`. The diagonal and lower triangular part of `A` are destroyed during the computation, but the strict upper triangular part is not referenced. The imaginary parts of the diagonal are assumed to be zero and are not referenced. The eigenvalues are stored in the vector `eval` and are unordered.",22,[[["self"],["matrixcomplexf64"],["vectorf64"]],["value"]]],[11,"new","","This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n complex hermitian matrices. The size of the workspace is O(5n).",23,[[["usize"]],["option",["eigenhermitianvworkspace"]]]],[11,"hermv","","This function computes the eigenvalues and eigenvectors of the complex hermitian matrix `A`. Additional workspace of the appropriate size must be provided in `self`. The diagonal and lower triangular part of `A` are destroyed during the computation, but the strict upper triangular part is not referenced. The imaginary parts of the diagonal are assumed to be zero and are not referenced. The eigenvalues are stored in the vector `eval` and are unordered. The corresponding complex eigenvectors are stored in the columns of the matrix `evec`. For example, the eigenvector in the first column corresponds to the first eigenvalue. The eigenvectors are guaranteed to be mutually orthogonal and normalised to unit magnitude.",23,[[["self"],["matrixcomplexf64"],["vectorf64"],["matrixcomplexf64"]],["value"]]],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n complex hermitian matrices. The size of the workspace is O(3n).",24,[[["usize"]],["option",["eigennonsymmworkspace"]]]],[11,"params","","This function sets some parameters which determine how the eigenvalue problem is solved in subsequent calls to gsl_eigen_nonsymm.",24,[[["self"],["i32"],["i32"]]]],[11,"nonsymm","","This function computes the eigenvalues of the real nonsymmetric matrix `A` and stores them in the vector `eval`. If T is desired, it is stored in the upper portion of `A` on output. Otherwise, on output, the diagonal of `A` will contain the 1-by-1 real eigenvalues and 2-by-2 complex conjugate eigenvalue systems, and the rest of `A` is destroyed. In rare cases, this function may fail to find all eigenvalues. If this happens, an error code is returned and the number of converged eigenvalues is stored in w->n_evals. The converged eigenvalues are stored in the beginning of `eval`.",24,[[["self"],["matrixf64"],["vectorcomplexf64"]],["value"]]],[11,"nonsymm_Z","","This function is identical to gsl_eigen_nonsymm except that it also computes the Schur vectors and stores them into `Z`.",24,[[["self"],["matrixf64"],["vectorcomplexf64"],["matrixf64"]],["value"]]],[11,"n_evals","","",24,[[["self"]],["usize"]]],[11,"new","","This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n real nonsymmetric matrices. The size of the workspace is O(5n).",25,[[["usize"]],["option",["eigennonsymmvworkspace"]]]],[11,"params","","This function sets parameters which determine how the eigenvalue problem is solved in subsequent calls to gsl_eigen_nonsymmv. If `balance` is set to 1, a balancing transformation is applied to the matrix. See gsl_eigen_nonsymm_params for more information. Balancing is turned off by default since it does not preserve the orthogonality of the Schur vectors.",25,[[["self"],["i32"]]]],[11,"nonsymmv","","This function computes eigenvalues and right eigenvectors of the n-by-n real nonsymmetric matrix `A`. It first calls gsl_eigen_nonsymm to compute the eigenvalues, Schur form T, and Schur vectors. Then it finds eigenvectors of T and backtransforms them using the Schur vectors. The Schur vectors are destroyed in the process, but can be saved by using gsl_eigen_nonsymmv_Z. The computed eigenvectors are normalized to have unit magnitude. On output, the upper portion of `A` contains the Schur form T. If gsl_eigen_nonsymm fails, no eigenvectors are computed, and an error code is returned.",25,[[["self"],["matrixf64"],["vectorcomplexf64"],["matrixcomplexf64"]],["value"]]],[11,"nonsymmv_Z","","This function is identical to gsl_eigen_nonsymmv except that it also saves the Schur vectors into `Z`.",25,[[["self"],["matrixf64"],["vectorcomplexf64"],["matrixcomplexf64"],["matrixf64"]],["value"]]],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n real generalized symmetric-definite eigensystems. The size of the workspace is O(2n).",26,[[["usize"]],["option",["eigengensymmworkspace"]]]],[11,"gensymm","","This function computes the eigenvalues of the real generalized symmetric-definite matrix pair (A, B), and stores them in `eval`, using the method outlined above. On output, `B` contains its Cholesky decomposition and `A` is destroyed.",26,[[["self"],["matrixf64"],["matrixf64"],["vectorf64"]],["value"]]],[11,"new","","This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n real generalized symmetric-definite eigensystems. The size of the workspace is O(4n).",27,[[["usize"]],["option",["eigengensymmvworkspace"]]]],[11,"gensymmv","","This function computes the eigenvalues and eigenvectors of the real generalized symmetric-definite matrix pair (A, B), and stores them in `eval` and `evec` respectively. The computed eigenvectors are normalized to have unit magnitude. On output, `B` contains its Cholesky decomposition and `A` is destroyed.",27,[[["self"],["matrixf64"],["matrixf64"],["vectorf64"],["matrixf64"]],["value"]]],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n complex generalized hermitian-definite eigensystems. The size of the workspace is O(3n).",28,[[["usize"]],["option",["eigengenhermworkspace"]]]],[11,"genherm","","This function computes the eigenvalues of the complex generalized hermitian-definite matrix pair (A, B), and stores them in `eval`, using the method outlined above. On output, `B` contains its Cholesky decomposition and `A` is destroyed.",28,[[["self"],["matrixcomplexf64"],["matrixcomplexf64"],["vectorf64"]],["value"]]],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n complex generalized hermitian-definite eigensystems. The size of the workspace is O(3n).",29,[[["usize"]],["option",["eigengenhermvworkspace"]]]],[11,"genhermv","","This function computes the eigenvalues of the complex generalized hermitian-definite matrix pair (A, B), and stores them in `eval`, using the method outlined above. On output, `B` contains its Cholesky decomposition and `A` is destroyed.",29,[[["self"],["matrixcomplexf64"],["matrixcomplexf64"],["vectorf64"],["matrixcomplexf64"]],["value"]]],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n real generalized nonsymmetric eigensystems. The size of the workspace is O(n).",30,[[["usize"]],["option",["eigengenworkspace"]]]],[11,"params","","This function sets some parameters which determine how the eigenvalue problem is solved in subsequent calls to gsl_eigen_gen.",30,[[["self"],["i32"],["i32"],["i32"]]]],[11,"gen","","This function computes the eigenvalues of the real generalized nonsymmetric matrix pair (A, B), and stores them as pairs in (alpha, beta), where alpha is complex and beta is real. If \\beta_i is non-zero, then \\lambda = \\alpha_i / \\beta_i is an eigenvalue. Likewise, if \\alpha_i is non-zero, then \\mu = \\beta_i / \\alpha_i is an eigenvalue of the alternate problem \\mu A y = B y. The elements of beta are normalized to be non-negative.",30,[[["self"],["matrixf64"],["matrixf64"],["vectorcomplexf64"],["vectorf64"]],["value"]]],[11,"gen_QZ","","This function is identical to gsl_eigen_gen except that it also computes the left and right Schur vectors and stores them into `Q` and `Z` respectively.",30,[[["self"],["matrixf64"],["matrixf64"],["vectorcomplexf64"],["vectorf64"],["matrixf64"],["matrixf64"]],["value"]]],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n real generalized nonsymmetric eigensystems. The size of the workspace is O(n).",31,[[["usize"]],["option",["eigengenvworkspace"]]]],[11,"genv","","This function computes eigenvalues and right eigenvectors of the n-by-n real generalized nonsymmetric matrix pair (A, B). The eigenvalues are stored in (alpha, beta) and the eigenvectors are stored in evec. It first calls gsl_eigen_gen to compute the eigenvalues, Schur forms, and Schur vectors. Then it finds eigenvectors of the Schur forms and backtransforms them using the Schur vectors. The Schur vectors are destroyed in the process, but can be saved by using gsl_eigen_genv_QZ. The computed eigenvectors are normalized to have unit magnitude. On output, (A, B) contains the generalized Schur form (S, T). If gsl_eigen_gen fails, no eigenvectors are computed, and an error code is returned.",31,[[["self"],["matrixf64"],["matrixf64"],["vectorcomplexf64"],["vectorf64"],["matrixcomplexf64"]],["value"]]],[11,"genv_QZ","","This function is identical to gsl_eigen_genv except that it also computes the left and right Schur vectors and stores them into `Q` and `Z` respectively.",31,[[["self"],["matrixf64"],["matrixf64"],["vectorcomplexf64"],["vectorf64"],["matrixcomplexf64"],["matrixf64"],["matrixf64"]],["value"]]],[0,"fast_fourier_transforms","rgsl::types","",N,N],[3,"FftComplexWaveTable","rgsl::types::fast_fourier_transforms","",N,N],[3,"FftComplexWorkspace","","",N,N],[11,"new","","This function prepares a trigonometric lookup table for a complex FFT of length n. The function returns a pointer to the newly allocated gsl_fft_complex_wavetable if no errors were detected, and a null pointer in the case of error. The length n is factorized into a product of subtransforms, and the factors and their trigonometric coefficients are stored in the wavetable. The trigonometric coefficients are computed using direct calls to sin and cos, for accuracy. Recursion relations could be used to compute the lookup table faster, but if an application performs many FFTs of the same length then this computation is a one-off overhead which does not affect the final throughput.",32,[[["usize"]],["option",["fftcomplexwavetable"]]]],[11,"factor","","",32,N],[11,"new","","This function allocates a workspace for a complex transform of length n.",33,[[["usize"]],["option",["fftcomplexworkspace"]]]],[0,"histograms","rgsl::types","#Histograms",N,N],[3,"Histogram","rgsl::types::histograms","",N,N],[3,"HistogramPdf","","The probability distribution function for a histogram consists of a set of bins which measure the probability of an event falling into a given range of a continuous variable x. A probability distribution function is defined by the following struct, which actually stores the cumulative probability distribution function. This is the natural quantity for generating samples via the inverse transform method, because there is a one-to-one mapping between the cumulative probability distribution and the range [0,1]. It can be shown that by taking a uniform random number in this range and finding its corresponding coordinate in the cumulative probability distribution we obtain samples with the desired probability distribution.",N,N],[3,"Histogram2D","","A two dimensional histogram consists of a set of bins which count the number of events falling in a given area of the (x,y) plane. The simplest way to use a two dimensional histogram is to record two-dimensional position information, n(x,y). Another possibility is to form a joint distribution by recording related variables. For example a detector might record both the position of an event (x) and the amount of energy it deposited E. These could be histogrammed as the joint distribution n(x,E).",N,N],[3,"Histogram2DPdf","","As in the one-dimensional case, a two-dimensional histogram made by counting events can be regarded as a measurement of a probability distribution. Allowing for statistical error, the height of each bin represents the probability of an event where (x,y) falls in the range of that bin. For a two-dimensional histogram the probability distribution takes the form p(x,y) dx dy where,",N,N],[11,"new","","This function allocates memory for a histogram with n bins, and returns a pointer to a newly created gsl_histogram struct. If insufficient memory is available a null pointer is returned and the error handler is invoked with an error code of Value::NoMem. The bins and ranges are not initialized, and should be prepared using one of the range-setting functions below in order to make the histogram ready for use.",34,[[["usize"]],["option",["histogram"]]]],[11,"set_ranges","","This function sets the ranges of the existing histogram h using the array range of size size. The values of the histogram bins are reset to zero. The range array should contain the desired bin limits. The ranges can be arbitrary, subject to the restriction that they are monotonically increasing.",34,N],[11,"set_ranges_uniform","","This function sets the ranges of the existing histogram h to cover the range xmin to xmax uniformly. The values of the histogram bins are reset to zero. The bin ranges are shown in the table below,",34,[[["self"],["f64"],["f64"]],["value"]]],[11,"copy","","This function copies the self histogram into the pre-existing histogram dest, making dest into an exact copy of self. The two histograms must be of the same size.",34,[[["self"],["histogram"]],["value"]]],[11,"clone","","This function returns a pointer to a newly created histogram which is an exact copy of the self histogram.",34,[[["self"]],["option",["histogram"]]]],[11,"increment","","This function updates the self histogram by adding one (1.0) to the bin whose range contains the coordinate x.",34,[[["self"],["f64"]],["value"]]],[11,"accumulate","","This function is similar to gsl_histogram_increment but increases the value of the appropriate bin in the histogram h by the floating-point number weight.",34,[[["self"],["f64"],["f64"]],["value"]]],[11,"get","","This function returns the contents of the i-th bin of the histogram h. If i lies outside the valid range of indices for the histogram then the error handler is called with an error code of Value::Dom and the function returns 0.",34,[[["self"],["usize"]],["f64"]]],[11,"get_range","","This function finds the upper and lower range limits of the i-th bin of the self histogram. If the index i is valid then the corresponding range limits are stored in lower and upper. The lower limit is inclusive (i.e. events with this coordinate are included in the bin) and the upper limit is exclusive (i.e. events with the coordinate of the upper limit are excluded and fall in the neighboring higher bin, if it exists). The function returns 0 to indicate success. If i lies outside the valid range of indices for the histogram then the error handler is called and the function returns an error code of Value::Dom.",34,[[["self"],["usize"],["f64"],["f64"]],["value"]]],[11,"max","","This function returns the maximum upper and minimum lower range limits and the number of bins of the self histogram. They provide a way of determining these values without accessing the gsl_histogram struct directly.",34,[[["self"]],["f64"]]],[11,"min","","This function returns the maximum upper and minimum lower range limits and the number of bins of the self histogram. They provide a way of determining these values without accessing the gsl_histogram struct directly.",34,[[["self"]],["f64"]]],[11,"bins","","This function returns the maximum upper and minimum lower range limits and the number of bins of the self histogram. They provide a way of determining these values without accessing the gsl_histogram struct directly.",34,[[["self"]],["usize"]]],[11,"reset","","This function resets all the bins in the self histogram to zero.",34,[[["self"]]]],[11,"find","","This function finds and sets the index i to the bin number which covers the coordinate x in the self histogram. The bin is located using a binary search. The search includes an optimization for histograms with uniform range, and will return the correct bin immediately in this case. If x is found in the range of the histogram then the function sets the index i and returns ::Value::Success. If x lies outside the valid range of the histogram then the function returns Value::Dom and the error handler is invoked.",34,[[["self"],["f64"],["usize"]],["value"]]],[11,"max_val","","This function returns the maximum value contained in the histogram bins.",34,[[["self"]],["f64"]]],[11,"max_bin","","This function returns the index of the bin containing the maximum value. In the case where several bins contain the same maximum value the smallest index is returned.",34,[[["self"]],["usize"]]],[11,"min_val","","This function returns the minimum value contained in the histogram bins.",34,[[["self"]],["f64"]]],[11,"min_bin","","This function returns the index of the bin containing the minimum value. In the case where several bins contain the same maximum value the smallest index is returned.",34,[[["self"]],["usize"]]],[11,"mean","","This function returns the mean of the histogrammed variable, where the histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation. The accuracy of the result is limited by the bin width.",34,[[["self"]],["f64"]]],[11,"sigma","","This function returns the standard deviation of the histogrammed variable, where the histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation. The accuracy of the result is limited by the bin width.",34,[[["self"]],["f64"]]],[11,"sum","","This function returns the sum of all bin values. Negative bin values are included in the sum.",34,[[["self"]],["f64"]]],[11,"equal_bins_p","","This function returns true if the all of the individual bin ranges of the two histograms are identical, and false otherwise.",34,[[["self"],["histogram"]],["bool"]]],[11,"add","","This function adds the contents of the bins in histogram other to the corresponding bins of self histogram, i.e. h'_1(i) = h_1(i) + h_2(i). The two histograms must have identical bin ranges.",34,[[["self"],["histogram"]],["value"]]],[11,"sub","","This function subtracts the contents of the bins in histogram other from the corresponding bins of self histogram, i.e. h'_1(i) = h_1(i) - h_2(i). The two histograms must have identical bin ranges.",34,[[["self"],["histogram"]],["value"]]],[11,"mul","","This function multiplies the contents of the bins of self histogram by the contents of the corresponding bins in other histogram, i.e. h'_1(i) = h_1(i) * h_2(i). The two histograms must have identical bin ranges.",34,[[["self"],["histogram"]],["value"]]],[11,"div","","This function divides the contents of the bins of self histogram by the contents of the corresponding bins in other histogram, i.e. h'_1(i) = h_1(i) / h_2(i). The two histograms must have identical bin ranges.",34,[[["self"],["histogram"]],["value"]]],[11,"scale","","This function multiplies the contents of the bins of self histogram by the constant scale, i.e. h'_1(i) = h_1(i) * scale.",34,[[["self"],["f64"]],["value"]]],[11,"shift","","This function shifts the contents of the bins of self histogram by the constant offset, i.e. h'_1(i) = h_1(i) + offset.",34,[[["self"],["f64"]],["value"]]],[11,"print","","",34,[[["self"],["write"]],["value"]]],[11,"new","","This function allocates memory for a probability distribution with n bins and returns a pointer to a newly initialized gsl_histogram_pdf struct. If insufficient memory is available a null pointer is returned and the error handler is invoked with an error code of Value::NoMem.",35,[[["usize"]],["option",["histogrampdf"]]]],[11,"init","","This function initializes the probability distribution self with the contents of the histogram h. If any of the bins of h are negative then the error handler is invoked with an error code of Value::Dom because a probability distribution cannot contain negative values.",35,[[["self"],["histogram"]],["value"]]],[11,"sample","","This function uses r, a uniform random number between zero and one, to compute a single random sample from the probability distribution self. The algorithm used to compute the sample s is given by the following formula,",35,[[["self"],["f64"]],["f64"]]],[11,"new","","This function allocates memory for a two-dimensional histogram with nx bins in the x direction and ny bins in the y direction. The function returns a pointer to a newly created gsl_histogram2d struct. If insufficient memory is available a null pointer is returned and the error handler is invoked with an error code of Value::NoMem. The bins and ranges must be initialized with one of the functions below before the histogram is ready for use.",36,[[["usize"],["usize"]],["option",["histogram2d"]]]],[11,"set_ranges","","This function sets the ranges of the existing histogram h using the arrays xrange and yrange of size xsize and ysize respectively. The values of the histogram bins are reset to zero.",36,N],[11,"set_ranges_uniform","","This function sets the ranges of the existing histogram h to cover the ranges xmin to xmax and ymin to ymax uniformly. The values of the histogram bins are reset to zero.",36,[[["self"],["f64"],["f64"],["f64"],["f64"]],["value"]]],[11,"copy","","This function copies the histogram src into the pre-existing histogram dest, making dest into an exact copy of src. The two histograms must be of the same size.",36,[[["self"],["histogram2d"]],["value"]]],[11,"clone","","his function returns a pointer to a newly created histogram which is an exact copy of the histogram self.",36,[[["self"]],["option",["histogram2d"]]]],[11,"increment","","This function updates the histogram h by adding one (1.0) to the bin whose x and y ranges contain the coordinates (x,y).",36,[[["self"],["f64"],["f64"]],["value"]]],[11,"accumulate","","This function is similar to gsl_histogram2d_increment but increases the value of the appropriate bin in the histogram h by the floating-point number weight.",36,[[["self"],["f64"],["f64"],["f64"]],["value"]]],[11,"get","","This function returns the contents of the (i,j)-th bin of the histogram h. If (i,j) lies outside the valid range of indices for the histogram then the error handler is called with an error code of Value::Dom and the function returns 0.",36,[[["self"],["usize"],["usize"]],["f64"]]],[11,"get_xrange","","This function finds the upper and lower range limits of the i-th and j-th bins in the x and y directions of the histogram h. The range limits are stored in xlower and xupper or ylower and yupper. The lower limits are inclusive (i.e. events with these coordinates are included in the bin) and the upper limits are exclusive (i.e. events with the value of the upper limit are not included and fall in the neighboring higher bin, if it exists). The functions return 0 to indicate success. If i or j lies outside the valid range of indices for the histogram then the error handler is called with an error code of Value::Dom.",36,[[["self"],["usize"],["f64"],["f64"]],["value"]]],[11,"get_yrange","","This function finds the upper and lower range limits of the i-th and j-th bins in the x and y directions of the histogram h. The range limits are stored in xlower and xupper or ylower and yupper. The lower limits are inclusive (i.e. events with these coordinates are included in the bin) and the upper limits are exclusive (i.e. events with the value of the upper limit are not included and fall in the neighboring higher bin, if it exists). The functions return 0 to indicate success. If i or j lies outside the valid range of indices for the histogram then the error handler is called with an error code of Value::Dom.",36,[[["self"],["usize"],["f64"],["f64"]],["value"]]],[11,"xmax","","This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h. They provide a way of determining these values without accessing the gsl_histogram2d struct directly.",36,[[["self"]],["f64"]]],[11,"xmin","","This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h. They provide a way of determining these values without accessing the gsl_histogram2d struct directly.",36,[[["self"]],["f64"]]],[11,"nx","","This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h. They provide a way of determining these values without accessing the gsl_histogram2d struct directly.",36,[[["self"]],["usize"]]],[11,"ymax","","This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h. They provide a way of determining these values without accessing the gsl_histogram2d struct directly.",36,[[["self"]],["f64"]]],[11,"ymin","","This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h. They provide a way of determining these values without accessing the gsl_histogram2d struct directly.",36,[[["self"]],["f64"]]],[11,"ny","","This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h. They provide a way of determining these values without accessing the gsl_histogram2d struct directly.",36,[[["self"]],["usize"]]],[11,"reset","","This function resets all the bins of the histogram h to zero.",36,[[["self"]]]],[11,"find","","This function finds and sets the indices i and j to the bin which covers the coordinates (x,y). The bin is located using a binary search. The search includes an optimization for histograms with uniform ranges, and will return the correct bin immediately in this case. If (x,y) is found then the function sets the indices (i,j) and returns ::Value::Success. If (x,y) lies outside the valid range of the histogram then the function returns Value::Dom and the error handler is invoked.",36,[[["self"],["f64"],["f64"],["usize"],["usize"]],["value"]]],[11,"max_val","","This function returns the maximum value contained in the histogram bins.",36,[[["self"]],["f64"]]],[11,"max_bin","","This function finds the indices of the bin containing the maximum value in the histogram h and stores the result in (i,j). In the case where several bins contain the same maximum value the first bin found is returned.",36,[[["self"],["usize"],["usize"]]]],[11,"min_val","","This function returns the minimum value contained in the histogram bins.",36,[[["self"]],["f64"]]],[11,"min_bin","","This function finds the indices of the bin containing the minimum value in the histogram h and stores the result in (i,j). In the case where several bins contain the same maximum value the first bin found is returned.",36,[[["self"],["usize"],["usize"]]]],[11,"xmean","","This function returns the mean of the histogrammed x variable, where the histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation.",36,[[["self"]],["f64"]]],[11,"ymean","","This function returns the mean of the histogrammed y variable, where the histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation.",36,[[["self"]],["f64"]]],[11,"xsigma","","This function returns the standard deviation of the histogrammed x variable, where the histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation.",36,[[["self"]],["f64"]]],[11,"ysigma","","This function returns the standard deviation of the histogrammed y variable, where the histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation.",36,[[["self"]],["f64"]]],[11,"cov","","This function returns the covariance of the histogrammed x and y variables, where the histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation.",36,[[["self"]],["f64"]]],[11,"sum","","This function returns the sum of all bin values. Negative bin values are included in the sum.",36,[[["self"]],["f64"]]],[11,"equal_bins_p","","This function returns 1 if all the individual bin ranges of the two histograms are identical, and 0 otherwise.",36,[[["self"],["histogram2d"]],["bool"]]],[11,"add","","This function adds the contents of the bins in histogram h2 to the corresponding bins of histogram h1, i.e. h'_1(i,j) = h_1(i,j) + h_2(i,j). The two histograms must have identical bin ranges.",36,[[["self"],["histogram2d"]],["value"]]],[11,"sub","","This function subtracts the contents of the bins in histogram h2 from the corresponding bins of histogram h1, i.e. h'_1(i,j) = h_1(i,j) - h_2(i,j). The two histograms must have identical bin ranges.",36,[[["self"],["histogram2d"]],["value"]]],[11,"mul","","This function multiplies the contents of the bins of histogram h1 by the contents of the corresponding bins in histogram h2, i.e. h'_1(i,j) = h_1(i,j) * h_2(i,j). The two histograms must have identical bin ranges.",36,[[["self"],["histogram2d"]],["value"]]],[11,"div","","This function divides the contents of the bins of histogram h1 by the contents of the corresponding bins in histogram h2, i.e. h'_1(i,j) = h_1(i,j) / h_2(i,j). The two histograms must have identical bin ranges.",36,[[["self"],["histogram2d"]],["value"]]],[11,"scale","","This function multiplies the contents of the bins of histogram h by the constant scale, i.e. h'_1(i,j) = h_1(i,j) scale.",36,[[["self"],["f64"]],["value"]]],[11,"shift","","This function shifts the contents of the bins of histogram h by the constant offset, i.e. h'_1(i,j) = h_1(i,j) + offset.",36,[[["self"],["f64"]],["value"]]],[11,"new","","This function allocates memory for a two-dimensional probability distribution of size nx-by-ny and returns a pointer to a newly initialized gsl_histogram2d_pdf struct. If insufficient memory is available a null pointer is returned and the error handler is invoked with an error code of Value::NoMem.",37,[[["usize"],["usize"]],["option",["histogram2dpdf"]]]],[11,"init","","This function initializes the two-dimensional probability distribution calculated p from the histogram h. If any of the bins of h are negative then the error handler is invoked with an error code of GSL_EDOM because a probability distribution cannot contain negative values.",37,[[["self"],["histogram2d"]],["value"]]],[11,"sample","","This function uses two uniform random numbers between zero and one, r1 and r2, to compute a single random sample from the two-dimensional probability distribution p.",37,[[["self"],["f64"],["f64"],["f64"],["f64"]],["value"]]],[0,"integration","rgsl::types","",N,N],[3,"IntegrationWorkspace","rgsl::types::integration","The QAG algorithm is a simple adaptive integration procedure. The integration region is divided into subintervals, and on each iteration the subinterval with the largest estimated error is bisected. This reduces the overall error rapidly, as the subintervals become concentrated around local difficulties in the integrand. These subintervals are managed by a gsl_integration_workspace struct, which handles the memory for the subinterval ranges, results and error estimates.",N,N],[3,"IntegrationQawsTable","","The QAWS algorithm is designed for integrands with algebraic-logarithmic singularities at the end-points of an integration region. In order to work efficiently the algorithm requires a precomputed table of Chebyshev moments.",N,N],[3,"IntegrationQawoTable","","The QAWO algorithm is designed for integrands with an oscillatory factor, \\sin(\\omega x) or \\cos(\\omega x). In order to work efficiently the algorithm requires a table of Chebyshev moments which must be pre-computed with calls to the functions below.",N,N],[3,"CquadWorkspace","","CQUAD is a new doubly-adaptive general-purpose quadrature routine which can handle most types of singularities, non-numerical function values such as Inf or NaN, as well as some divergent integrals. It generally requires more function evaluations than the integration routines in QUADPACK, yet fails less often for difficult integrands.",N,N],[3,"GLFixedTable","","The fixed-order Gauss-Legendre integration routines are provided for fast integration of smooth functions with known polynomial order. The n-point Gauss-Legendre rule is exact for polynomials of order 2*n-1 or less. For example, these rules are useful when integrating basis functions to form mass matrices for the Galerkin method. Unlike other numerical integration routines within the library, these routines do not accept absolute or relative error bounds.",N,N],[11,"new","","This function allocates a workspace sufficient to hold n double precision intervals, their integration results and error estimates. One workspace may be used multiple times as all necessary reinitialization is performed automatically by the integration routines.",38,[[["usize"]],["option",["integrationworkspace"]]]],[11,"qag","","This function applies an integration rule adaptively until an estimate of the integral of f over (a,b) is achieved within the desired absolute and relative error limits, epsabs and epsrel. The function returns the final approximation, result, and an estimate of the absolute error, abserr. The integration rule is determined by the value of key, which should be chosen from the following symbolic names,",38,[[["self"],["function"],["t"],["f64"],["f64"],["f64"],["f64"],["usize"],["gausskonrodrule"],["f64"],["f64"]],["value"]]],[11,"qags","","This function applies the Gauss-Kronrod 21-point integration rule adaptively until an estimate of the integral of f over (a,b) is achieved within the desired absolute and relative error limits, epsabs and epsrel. The results are extrapolated using the epsilon-algorithm, which accelerates the convergence of the integral in the presence of discontinuities and integrable singularities. The function returns the final approximation from the extrapolation, result, and an estimate of the absolute error, abserr. The subintervals and their results are stored in the memory provided by workspace. The maximum number of subintervals is given by limit, which may not exceed the allocated size of the workspace.",38,[[["self"],["function"],["t"],["f64"],["f64"],["f64"],["f64"],["usize"],["f64"],["f64"]],["value"]]],[11,"qagp","","This function applies the adaptive integration algorithm QAGS taking account of the user-supplied locations of singular points. The array pts of length npts should contain the endpoints of the integration ranges defined by the integration region and locations of the singularities. For example, to integrate over the region (a,b) with break-points at x_1, x_2, x_3 (where a < x_1 < x_2 < x_3 < b) the following pts array should be used",38,N],[11,"qagi","","This function computes the integral of the function f over the infinite interval (-\\infty,+\\infty). The integral is mapped onto the semi-open interval (0,1] using the transformation x = (1-t)/t,",38,[[["self"],["function"],["t"],["f64"],["f64"],["usize"],["f64"],["f64"]],["value"]]],[11,"qagiu","","This function computes the integral of the function f over the semi-infinite interval (a,+\\infty). The integral is mapped onto the semi-open interval (0,1] using the transformation x = a + (1-t)/t,",38,[[["self"],["function"],["t"],["f64"],["f64"],["f64"],["usize"],["f64"],["f64"]],["value"]]],[11,"qagil","","This function computes the integral of the function f over the semi-infinite interval (-\\infty,b). The integral is mapped onto the semi-open interval (0,1] using the transformation x = b - (1-t)/t,",38,[[["self"],["function"],["t"],["f64"],["f64"],["f64"],["usize"],["f64"],["f64"]],["value"]]],[11,"qawc","","This function computes the Cauchy principal value of the integral of f over (a,b), with a singularity at c,",38,[[["self"],["function"],["t"],["f64"],["f64"],["f64"],["f64"],["f64"],["usize"],["f64"],["f64"]],["value"]]],[11,"sort_results","","",38,[[["self"]]]],[11,"qpsrt","","",38,[[["self"]]]],[11,"sum_results","","",38,[[["self"]],["f64"]]],[11,"retrieve","","",38,[[["self"],["f64"],["f64"],["f64"],["f64"]]]],[11,"update","","",38,[[["self"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"]]]],[11,"set_initial_result","","",38,[[["self"],["f64"],["f64"]]]],[11,"initialise","","",38,[[["self"],["f64"],["f64"]]]],[11,"limit","","",38,[[["self"]],["usize"]]],[11,"size","","",38,[[["self"]],["usize"]]],[11,"new","","This function allocates space for a gsl_integration_qaws_table struct describing a singular weight function W(x) with the parameters (\\alpha, \\beta, \\mu, \\nu),",39,[[["f64"],["f64"],["i32"],["i32"]],["option",["integrationqawstable"]]]],[11,"set","","This function modifies the parameters (\\alpha, \\beta, \\mu, \\nu)",39,[[["self"],["f64"],["f64"],["i32"],["i32"]],["value"]]],[11,"qaws","","This function computes the integral of the function f(x) over the interval (a,b) with the singular weight function (x-a)^\\alpha (b-x)^\\beta \\log^\\mu (x-a) \\log^\\nu (b-x). The parameters of the weight function (\\alpha, \\beta, \\mu, \\nu) are taken from the table self. The integral is,",39,[[["self"],["function"],["t"],["f64"],["f64"],["f64"],["f64"],["usize"],["integrationworkspace"],["f64"],["f64"]],["value"]]],[11,"new","","This function allocates space for a gsl_integration_qawo_table struct and its associated workspace describing a sine or cosine weight function W(x) with the parameters (\\omega, L),",40,[[["f64"],["f64"],["integrationqawo"],["usize"]],["option",["integrationqawotable"]]]],[11,"set","","This function changes the parameters omega, L and sine of the existing self workspace.",40,[[["self"],["f64"],["f64"],["integrationqawo"]],["value"]]],[11,"set_length","","This function allows the length parameter l of the self workspace to be changed.",40,[[["self"],["f64"]],["value"]]],[11,"qawo","","This function uses an adaptive algorithm to compute the integral of f over (a,b) with the weight function \\sin(\\omega x) or \\cos(\\omega x) defined by the table wf,",40,[[["self"],["function"],["t"],["f64"],["f64"],["f64"],["usize"],["integrationworkspace"],["f64"],["f64"]],["value"]]],[11,"new","","This function allocates a workspace sufficient to hold the data for n intervals. The number n is not the maximum number of intervals that will be evaluated. If the workspace is full, intervals with smaller error estimates will be discarded. A minimum of 3 intervals is required and for most functions, a workspace of size 100 is sufficient.",41,[[["usize"]],["option",["cquadworkspace"]]]],[11,"cquad","","This function computes the integral of f over (a,b) within the desired absolute and relative error limits, epsabs and epsrel using the CQUAD algorithm. The function returns the final approximation, result, an estimate of the absolute error, abserr, and the number of function evaluations required, nevals.",41,[[["self"],["function"],["t"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"],["usize"]],["value"]]],[11,"new","","This function determines the Gauss-Legendre abscissae and weights necessary for an n-point fixed order integration scheme. If possible, high precision precomputed coefficients are used. If precomputed weights are not available, lower precision coefficients are computed on the fly.",42,[[["usize"]],["option",["glfixedtable"]]]],[11,"point","","For i in [0, , t->n - 1], this function obtains the i-th Gauss-Legendre point xi and weight wi on the interval [a,b]. The points and weights are ordered by increasing point value. A function f may be integrated on [a,b] by summing wi * f(xi) over i.",42,[[["self"],["f64"],["f64"],["usize"],["f64"],["f64"]],["value"]]],[11,"glfixed","","This function applies the Gauss-Legendre integration rule contained in table self and returns the result.",42,[[["self"],["function"],["t"],["f64"],["f64"]],["f64"]]],[0,"interpolation","rgsl::types","#Interpolation",N,N],[3,"InterpAccel","rgsl::types::interpolation","evaluation accelerator",N,N],[12,"cache","","cache of index",43,N],[12,"miss_count","","keep statistics",43,N],[12,"hit_count","","",43,N],[3,"Interp","","",N,N],[3,"InterpType","","",N,N],[3,"Spline","","general interpolation object",N,N],[11,"new","","This function returns a pointer to an accelerator object, which is a kind of iterator for interpolation lookups. It tracks the state of lookups, thus allowing for application of various acceleration strategies.",43,[[],["interpaccel"]]],[11,"reset","","This function reinitializes the accelerator object acc. It should be used when the cached information is no longer applicablefor example, when switching to a new dataset.",43,[[["self"]]]],[11,"find","","This function performs a lookup action on the data array x_array of size size, using the given accelerator a. This is how lookups are performed during evaluation of an interpolation. The function returns an index i such that x_array[i] <= x < x_array[i+1].",43,N],[11,"new","","This function returns a pointer to a newly allocated interpolation object of type T for size data-points.",44,[[["interptype"],["usize"]],["option",["interp"]]]],[11,"init","","This function initializes the interpolation object interp for the data (xa,ya) where xa and ya are arrays of size size. The interpolation object (gsl_interp) does not save the data arrays xa and ya and only stores the static state computed from the data. The xa data array is always assumed to be strictly ordered, with increasing x values; the behavior for other arrangements is not defined.",44,N],[11,"name","","This function returns the name of the interpolation type used by interp. For example,",44,[[["self"]],["string"]]],[11,"min_size","","This function returns the minimum number of points required by the interpolation object interp or interpolation type T. For example, Akima spline interpolation requires a minimum of 5 points.",44,[[["self"]],["u32"]]],[11,"min_size","","This function returns the minimum number of points required by the interpolation object interp or interpolation type T. For example, Akima spline interpolation requires a minimum of 5 points.",45,[[["self"]],["u32"]]],[11,"linear","","Linear interpolation. This interpolation method does not require any additional memory.",45,[[],["interptype"]]],[11,"polynomial","","Polynomial interpolation. This method should only be used for interpolating small numbers of points because polynomial interpolation introduces large oscillations, even for well-behaved datasets. The number of terms in the interpolating polynomial is equal to the number of points.",45,[[],["interptype"]]],[11,"cspline","","Cubic spline with natural boundary conditions. The resulting curve is piecewise cubic on each interval, with matching first and second derivatives at the supplied data-points. The second derivative is chosen to be zero at the first point and last point.",45,[[],["interptype"]]],[11,"cspline_periodic","","Cubic spline with periodic boundary conditions. The resulting curve is piecewise cubic on each interval, with matching first and second derivatives at the supplied data-points. The derivatives at the first and last points are also matched. Note that the last point in the data must have the same y-value as the first point, otherwise the resulting periodic interpolation will have a discontinuity at the boundary.",45,[[],["interptype"]]],[11,"akima","","Non-rounded Akima spline with natural boundary conditions. This method uses the non-rounded corner algorithm of Wodicka.",45,[[],["interptype"]]],[11,"akima_periodic","","Non-rounded Akima spline with periodic boundary conditions. This method uses the non-rounded corner algorithm of Wodicka.",45,[[],["interptype"]]],[11,"new","","",46,[[["interptype"],["usize"]],["option",["spline"]]]],[11,"init","","",46,N],[11,"name","","",46,[[["self"]],["string"]]],[11,"min_size","","",46,[[["self"]],["u32"]]],[11,"eval","","",46,[[["self"],["f64"],["interpaccel"]],["f64"]]],[11,"eval_e","","",46,[[["self"],["f64"],["interpaccel"],["f64"]],["value"]]],[11,"eval_deriv","","",46,[[["self"],["f64"],["interpaccel"]],["f64"]]],[11,"eval_deriv_e","","",46,[[["self"],["f64"],["interpaccel"],["f64"]],["value"]]],[11,"eval_deriv2","","",46,[[["self"],["f64"],["interpaccel"]],["f64"]]],[11,"eval_deriv2_e","","",46,[[["self"],["f64"],["interpaccel"],["f64"]],["value"]]],[11,"eval_integ","","",46,[[["self"],["f64"],["f64"],["interpaccel"]],["f64"]]],[11,"eval_integ_e","","",46,[[["self"],["f64"],["f64"],["interpaccel"],["f64"]],["value"]]],[0,"mathieu","rgsl::types","The routines described in this section compute the angular and radial Mathieu functions, and their characteristic values. Mathieu functions are the solutions of the following two differential equations:",N,N],[3,"MathieuWorkspace","rgsl::types::mathieu","The Mathieu functions can be computed for a single order or for multiple orders, using array-based routines. The array-based routines require a preallocated workspace.",N,N],[11,"new","","This function returns a workspace for the array versions of the Mathieu routines. The arguments n and qmax specify the maximum order and q-value of Mathieu functions which can be computed with this workspace.",47,[[["usize"],["f64"]],["option",["mathieuworkspace"]]]],[11,"mathieu_a","","This routine computes the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.",47,N],[11,"mathieu_b","","This routine computes the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.",47,N],[11,"mathieu_a_array","","This routine computes a series of Mathieu characteristic values a_n(q), b_n(q) for n from order_min to order_max inclusive, storing the results in the array result_array.",47,N],[11,"mathieu_b_array","","This routine computes a series of Mathieu characteristic values a_n(q), b_n(q) for n from order_min to order_max inclusive, storing the results in the array result_array.",47,N],[11,"mathieu_ce","","This routine computes the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.",47,N],[11,"mathieu_se","","This routine computes the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.",47,N],[11,"mathieu_ce_array","","This routine computes a series of the angular Mathieu functions ce_n(q,x) and se_n(q,x) of order n from nmin to nmax inclusive, storing the results in the array result_array.",47,N],[11,"mathieu_se_array","","This routine computes a series of the angular Mathieu functions ce_n(q,x) and se_n(q,x) of order n from nmin to nmax inclusive, storing the results in the array result_array.",47,N],[11,"mathieu_Mc","","This routine computes the radial j-th kind Mathieu functions Mc_n^{(j)}(q,x) and Ms_n^{(j)}(q,x) of order n.",47,N],[11,"mathieu_Ms","","This routine computes the radial j-th kind Mathieu functions Mc_n^{(j)}(q,x) and Ms_n^{(j)}(q,x) of order n.",47,N],[11,"mathieu_Mc_array","","This routine computes a series of the radial Mathieu functions of kind j, with order from nmin to nmax inclusive, storing the results in the array result_array.",47,N],[11,"mathieu_Ms_array","","This routine computes a series of the radial Mathieu functions of kind j, with order from nmin to nmax inclusive, storing the results in the array result_array.",47,N],[0,"matrix","rgsl::types","#Matrices",N,N],[3,"MatrixView","rgsl::types::matrix","",N,N],[3,"MatrixF64","","",N,N],[3,"MatrixF32","","",N,N],[11,"from_matrix","","These functions return a matrix view of a submatrix of the matrix m. The upper-left element of the submatrix is the element (k1,k2) of the original matrix. The submatrix has n1 rows and n2 columns. The physical number of columns in memory given by tda is unchanged. Mathematically, the (i,j)-th element of the new matrix is given by,",48,[[["matrixf64"],["usize"],["usize"],["usize"],["usize"]],["matrixview"]]],[11,"from_array","","These functions return a matrix view of the array base. The matrix has n1 rows and n2 columns. The physical number of columns in memory is also given by n2. Mathematically, the (i,j)-th element of the new matrix is given by,",48,N],[11,"from_array_with_tda","","These functions return a matrix view of the array base with a physical number of columns tda which may differ from the corresponding dimension of the matrix. The matrix has n1 rows and n2 columns, and the physical number of columns in memory is given by tda. Mathematically, the (i,j)-th element of the new matrix is given by,",48,N],[11,"from_vector","","These functions return a matrix view of the vector v. The matrix has n1 rows and n2 columns. The vector must have unit stride. The physical number of columns in memory is also given by n2. Mathematically, the (i,j)-th element of the new matrix is given by,",48,[[["vectorf64"],["usize"],["usize"]],["matrixview"]]],[11,"from_vector_with_tda","","These functions return a matrix view of the vector v with a physical number of columns tda which may differ from the corresponding matrix dimension. The vector must have unit stride. The matrix has n1 rows and n2 columns, and the physical number of columns in memory is given by tda. Mathematically, the (i,j)-th element of the new matrix is given by,",48,[[["vectorf64"],["usize"],["usize"],["usize"]],["matrixview"]]],[11,"matrix","","",48,[[["self"]],["matrixf64"]]],[11,"new","","Creates a new MatrixF64 with all elements set to zero",49,[[["usize"],["usize"]],["option",["matrixf64"]]]],[11,"get","","This function returns the (i,j)-th element of the matrix. If y or x lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked and 0 is returned.",49,[[["self"],["usize"],["usize"]],["f64"]]],[11,"set","","This function sets the value of the (i,j)-th element of the matrix to value. If y or x lies outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked.",49,[[["self"],["usize"],["usize"],["f64"]],["matrixf64"]]],[11,"set_all","","This function sets all the elements of the matrix to the value x.",49,[[["self"],["f64"]],["matrixf64"]]],[11,"set_zero","","This function sets all the elements of the matrix to zero.",49,[[["self"]],["matrixf64"]]],[11,"set_identity","","This function sets the elements of the matrix to the corresponding elements of the identity matrix, m(i,j) = \\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero. This applies to both square and rectangular matrices.",49,[[["self"]],["matrixf64"]]],[11,"copy_from","","This function copies the elements of the other matrix into the self matrix. The two matrices must have the same size.",49,[[["self"],["matrixf64"]],["value"]]],[11,"copy_to","","This function copies the elements of the self matrix into the other matrix. The two matrices must have the same size.",49,[[["self"],["matrixf64"]],["value"]]],[11,"swap","","This function exchanges the elements of the matrices self and other by copying. The two matrices must have the same size.",49,[[["self"],["matrixf64"]],["value"]]],[11,"get_row","","This function copies the elements of the y-th row of the matrix into the returned vector.",49,[[["self"],["usize"]],["option"]]],[11,"get_col","","This function copies the elements of the x-th column of the matrix into the returned vector.",49,[[["self"],["usize"]],["option"]]],[11,"set_row","","This function copies the elements of the vector v into the y-th row of the matrix. The length of the vector must be the same as the length of the row.",49,[[["self"],["usize"],["vectorf64"]],["value"]]],[11,"set_col","","This function copies the elements of the vector v into the x-th column of the matrix. The length of the vector must be the same as the length of the column.",49,[[["self"],["usize"],["vectorf64"]],["value"]]],[11,"swap_rows","","This function exchanges the y1-th and y2-th rows of the matrix in-place.",49,[[["self"],["usize"],["usize"]],["value"]]],[11,"swap_columns","","This function exchanges the x1-th and x2-th columns of the matrix in-place.",49,[[["self"],["usize"],["usize"]],["value"]]],[11,"swap_row_col","","This function exchanges the i-th row and j-th column of the matrix in-place. The matrix must be square for this operation to be possible.",49,[[["self"],["usize"],["usize"]],["value"]]],[11,"transpose_memcpy","","This function returns the transpose of the matrix by copying the elements into it. This function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix.",49,[[["self"]],["option"]]],[11,"transpose","","This function replaces the matrix m by its transpose by copying the elements of the matrix in-place. The matrix must be square for this operation to be possible.",49,[[["self"]],["value"]]],[11,"add","","This function adds the elements of the other matrix to the elements of the self matrix. The result self(i,j) <- self(i,j) + other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",49,[[["self"],["matrixf64"]],["value"]]],[11,"sub","","This function subtracts the elements of the other matrix from the elements of the self matrix. The result self(i,j) <- self(i,j) - other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",49,[[["self"],["matrixf64"]],["value"]]],[11,"mul_elements","","This function multiplies the elements of the self matrix by the elements of the other matrix. The result self(i,j) <- self(i,j) * other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",49,[[["self"],["matrixf64"]],["value"]]],[11,"div_elements","","This function divides the elements of the self matrix by the elements of the other matrix. The result self(i,j) <- self(i,j) / other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",49,[[["self"],["matrixf64"]],["value"]]],[11,"scale","","This function multiplies the elements of the self matrix by the constant factor x. The result self(i,j) <- x self(i,j) is stored in self.",49,[[["self"],["f64"]],["value"]]],[11,"add_constant","","This function adds the constant value x to the elements of the self matrix. The result self(i,j) <- self(i,j) + x is stored in self.",49,[[["self"],["f64"]],["value"]]],[11,"max","","This function returns the maximum value in the self matrix.",49,[[["self"]],["f64"]]],[11,"min","","This function returns the minimum value in the self matrix.",49,[[["self"]],["f64"]]],[11,"minmax","","This function returns the minimum and maximum values in the self matrix, storing them in min_out and max_out.",49,[[["self"],["f64"],["f64"]]]],[11,"max_index","","This function returns the indices of the maximum value in the self matrix, storing them in imax and jmax. When there are several equal maximum elements then the first element found is returned, searching in row-major order.",49,N],[11,"min_index","","This function returns the indices of the minimum value in the self matrix, storing them in imin and jmin. When there are several equal minimum elements then the first element found is returned, searching in row-major order.",49,N],[11,"minmax_index","","This function returns the indices of the minimum and maximum values in the self matrix, storing them in (imin,jmin) and (imax,jmax). When there are several equal minimum or maximum elements then the first elements found are returned, searching in row-major order.",49,N],[11,"is_null","","This function returns true if all the elements of the self matrix are stricly zero.",49,[[["self"]],["bool"]]],[11,"is_pos","","This function returns true if all the elements of the self matrix are stricly positive.",49,[[["self"]],["bool"]]],[11,"is_neg","","This function returns true if all the elements of the self matrix are stricly negative.",49,[[["self"]],["bool"]]],[11,"is_non_neg","","This function returns true if all the elements of the self matrix are stricly non-negative.",49,[[["self"]],["bool"]]],[11,"equal","","This function returns true if all elements of the two matrix are equal.",49,[[["self"],["matrixf64"]],["bool"]]],[11,"size1","","",49,[[["self"]],["usize"]]],[11,"size2","","",49,[[["self"]],["usize"]]],[11,"clone","","",49,[[["self"]],["option",["matrixf64"]]]],[11,"new","","Creates a new MatrixF64 with all elements set to zero",50,[[["usize"],["usize"]],["option",["matrixf32"]]]],[11,"get","","This function returns the (i,j)-th element of the matrix. If y or x lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked and 0 is returned.",50,[[["self"],["usize"],["usize"]],["f32"]]],[11,"set","","This function sets the value of the (i,j)-th element of the matrix to value. If y or x lies outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked.",50,[[["self"],["usize"],["usize"],["f32"]],["matrixf32"]]],[11,"set_all","","This function sets all the elements of the matrix to the value x.",50,[[["self"],["f32"]],["matrixf32"]]],[11,"set_zero","","This function sets all the elements of the matrix to zero.",50,[[["self"]],["matrixf32"]]],[11,"set_identity","","This function sets the elements of the matrix to the corresponding elements of the identity matrix, m(i,j) = \\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero. This applies to both square and rectangular matrices.",50,[[["self"]],["matrixf32"]]],[11,"copy_from","","This function copies the elements of the other matrix into the self matrix. The two matrices must have the same size.",50,[[["self"],["matrixf32"]],["value"]]],[11,"copy_to","","This function copies the elements of the self matrix into the other matrix. The two matrices must have the same size.",50,[[["self"],["matrixf32"]],["value"]]],[11,"swap","","This function exchanges the elements of the matrices self and other by copying. The two matrices must have the same size.",50,[[["self"],["matrixf32"]],["value"]]],[11,"get_row","","This function copies the elements of the y-th row of the matrix into the returned vector.",50,[[["self"],["usize"]],["option"]]],[11,"get_col","","This function copies the elements of the x-th column of the matrix into the returned vector.",50,[[["self"],["usize"]],["option"]]],[11,"set_row","","This function copies the elements of the vector v into the y-th row of the matrix. The length of the vector must be the same as the length of the row.",50,[[["self"],["usize"],["vectorf32"]],["value"]]],[11,"set_col","","This function copies the elements of the vector v into the x-th column of the matrix. The length of the vector must be the same as the length of the column.",50,[[["self"],["usize"],["vectorf32"]],["value"]]],[11,"swap_rows","","This function exchanges the y1-th and y2-th rows of the matrix in-place.",50,[[["self"],["usize"],["usize"]],["value"]]],[11,"swap_columns","","This function exchanges the x1-th and x2-th columns of the matrix in-place.",50,[[["self"],["usize"],["usize"]],["value"]]],[11,"swap_row_col","","This function exchanges the i-th row and j-th column of the matrix in-place. The matrix must be square for this operation to be possible.",50,[[["self"],["usize"],["usize"]],["value"]]],[11,"transpose_memcpy","","This function returns the transpose of the matrix by copying the elements into it. This function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix.",50,[[["self"]],["option"]]],[11,"transpose","","This function replaces the matrix m by its transpose by copying the elements of the matrix in-place. The matrix must be square for this operation to be possible.",50,[[["self"]],["value"]]],[11,"add","","This function adds the elements of the other matrix to the elements of the self matrix. The result self(i,j) <- self(i,j) + other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",50,[[["self"],["matrixf32"]],["value"]]],[11,"sub","","This function subtracts the elements of the other matrix from the elements of the self matrix. The result self(i,j) <- self(i,j) - other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",50,[[["self"],["matrixf32"]],["value"]]],[11,"mul_elements","","This function multiplies the elements of the self matrix by the elements of the other matrix. The result self(i,j) <- self(i,j) * other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",50,[[["self"],["matrixf32"]],["value"]]],[11,"div_elements","","This function divides the elements of the self matrix by the elements of the other matrix. The result self(i,j) <- self(i,j) / other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",50,[[["self"],["matrixf32"]],["value"]]],[11,"scale","","This function multiplies the elements of the self matrix by the constant factor x. The result self(i,j) <- x self(i,j) is stored in self.",50,[[["self"],["f32"]],["value"]]],[11,"add_constant","","This function adds the constant value x to the elements of the self matrix. The result self(i,j) <- self(i,j) + x is stored in self.",50,[[["self"],["f32"]],["value"]]],[11,"max","","This function returns the maximum value in the self matrix.",50,[[["self"]],["f32"]]],[11,"min","","This function returns the minimum value in the self matrix.",50,[[["self"]],["f32"]]],[11,"minmax","","This function returns the minimum and maximum values in the self matrix, storing them in min_out and max_out.",50,[[["self"],["f32"],["f32"]]]],[11,"max_index","","This function returns the indices of the maximum value in the self matrix, storing them in imax and jmax. When there are several equal maximum elements then the first element found is returned, searching in row-major order.",50,N],[11,"min_index","","This function returns the indices of the minimum value in the self matrix, storing them in imin and jmin. When there are several equal minimum elements then the first element found is returned, searching in row-major order.",50,N],[11,"minmax_index","","This function returns the indices of the minimum and maximum values in the self matrix, storing them in (imin,jmin) and (imax,jmax). When there are several equal minimum or maximum elements then the first elements found are returned, searching in row-major order.",50,N],[11,"is_null","","This function returns true if all the elements of the self matrix are stricly zero.",50,[[["self"]],["bool"]]],[11,"is_pos","","This function returns true if all the elements of the self matrix are stricly positive.",50,[[["self"]],["bool"]]],[11,"is_neg","","This function returns true if all the elements of the self matrix are stricly negative.",50,[[["self"]],["bool"]]],[11,"is_non_neg","","This function returns true if all the elements of the self matrix are stricly non-negative.",50,[[["self"]],["bool"]]],[11,"equal","","This function returns true if all elements of the two matrix are equal.",50,[[["self"],["matrixf32"]],["bool"]]],[11,"clone","","",50,[[["self"]],["option",["matrixf32"]]]],[0,"matrix_complex","rgsl::types","",N,N],[3,"MatrixComplexF64","rgsl::types::matrix_complex","",N,N],[3,"MatrixComplexF32","","",N,N],[11,"new","","Creates a new MatrixF64 with all elements set to zero",51,[[["usize"],["usize"]],["option",["matrixcomplexf64"]]]],[11,"get","","This function returns the (i,j)-th element of the matrix. If y or x lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked and 0 is returned.",51,[[["self"],["usize"],["usize"]],["complexf64"]]],[11,"set","","This function sets the value of the (i,j)-th element of the matrix to value. If y or x lies outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked.",51,[[["self"],["usize"],["usize"],["complexf64"]],["matrixcomplexf64"]]],[11,"set_all","","This function sets all the elements of the matrix to the value x.",51,[[["self"],["complexf64"]],["matrixcomplexf64"]]],[11,"set_zero","","This function sets all the elements of the matrix to zero.",51,[[["self"]],["matrixcomplexf64"]]],[11,"set_identity","","This function sets the elements of the matrix to the corresponding elements of the identity matrix, m(i,j) = \\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero. This applies to both square and rectangular matrices.",51,[[["self"]],["matrixcomplexf64"]]],[11,"copy_from","","This function copies the elements of the other matrix into the self matrix. The two matrices must have the same size.",51,[[["self"],["matrixcomplexf64"]],["value"]]],[11,"copy_to","","This function copies the elements of the self matrix into the other matrix. The two matrices must have the same size.",51,[[["self"],["matrixcomplexf64"]],["value"]]],[11,"swap","","This function exchanges the elements of the matrices self and other by copying. The two matrices must have the same size.",51,[[["self"],["matrixcomplexf64"]],["value"]]],[11,"get_row","","This function copies the elements of the y-th row of the matrix into the returned vector.",51,[[["self"],["usize"]],["option"]]],[11,"get_col","","This function copies the elements of the x-th column of the matrix into the returned vector.",51,[[["self"],["usize"]],["option"]]],[11,"set_row","","This function copies the elements of the vector v into the y-th row of the matrix. The length of the vector must be the same as the length of the row.",51,[[["self"],["usize"],["vectorcomplexf64"]],["value"]]],[11,"set_col","","This function copies the elements of the vector v into the x-th column of the matrix. The length of the vector must be the same as the length of the column.",51,[[["self"],["usize"],["vectorcomplexf64"]],["value"]]],[11,"swap_rows","","This function exchanges the y1-th and y2-th rows of the matrix in-place.",51,[[["self"],["usize"],["usize"]],["value"]]],[11,"swap_columns","","This function exchanges the x1-th and x2-th columns of the matrix in-place.",51,[[["self"],["usize"],["usize"]],["value"]]],[11,"swap_row_col","","This function exchanges the i-th row and j-th column of the matrix in-place. The matrix must be square for this operation to be possible.",51,[[["self"],["usize"],["usize"]],["value"]]],[11,"transpose_memcpy","","This function returns the transpose of the matrix by copying the elements into it. This function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix.",51,[[["self"]],["option"]]],[11,"transpose","","This function replaces the matrix m by its transpose by copying the elements of the matrix in-place. The matrix must be square for this operation to be possible.",51,[[["self"]],["value"]]],[11,"add","","This function adds the elements of the other matrix to the elements of the self matrix. The result self(i,j) <- self(i,j) + other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",51,[[["self"],["matrixcomplexf64"]],["value"]]],[11,"sub","","This function subtracts the elements of the other matrix from the elements of the self matrix. The result self(i,j) <- self(i,j) - other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",51,[[["self"],["matrixcomplexf64"]],["value"]]],[11,"mul_elements","","This function multiplies the elements of the self matrix by the elements of the other matrix. The result self(i,j) <- self(i,j) * other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",51,[[["self"],["matrixcomplexf64"]],["value"]]],[11,"div_elements","","This function divides the elements of the self matrix by the elements of the other matrix. The result self(i,j) <- self(i,j) / other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",51,[[["self"],["matrixcomplexf64"]],["value"]]],[11,"scale","","This function multiplies the elements of the self matrix by the constant factor x. The result self(i,j) <- x self(i,j) is stored in self.",51,[[["self"],["complexf64"]],["value"]]],[11,"add_constant","","This function adds the constant value x to the elements of the self matrix. The result self(i,j) <- self(i,j) + x is stored in self.",51,[[["self"],["complexf64"]],["value"]]],[11,"is_null","","This function returns true if all the elements of the self matrix are stricly zero.",51,[[["self"]],["bool"]]],[11,"is_pos","","This function returns true if all the elements of the self matrix are stricly positive.",51,[[["self"]],["bool"]]],[11,"is_neg","","This function returns true if all the elements of the self matrix are stricly negative.",51,[[["self"]],["bool"]]],[11,"is_non_neg","","This function returns true if all the elements of the self matrix are stricly non-negative.",51,[[["self"]],["bool"]]],[11,"equal","","This function returns true if all elements of the two matrix are equal.",51,[[["self"],["matrixcomplexf64"]],["bool"]]],[11,"clone","","",51,[[["self"]],["option",["matrixcomplexf64"]]]],[11,"new","","Creates a new MatrixF64 with all elements set to zero",52,[[["usize"],["usize"]],["option",["matrixcomplexf32"]]]],[11,"get","","This function returns the (i,j)-th element of the matrix. If y or x lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked and 0 is returned.",52,[[["self"],["usize"],["usize"]],["complexf32"]]],[11,"set","","This function sets the value of the (i,j)-th element of the matrix to value. If y or x lies outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked.",52,[[["self"],["usize"],["usize"],["complexf32"]],["matrixcomplexf32"]]],[11,"set_all","","This function sets all the elements of the matrix to the value x.",52,[[["self"],["complexf32"]],["matrixcomplexf32"]]],[11,"set_zero","","This function sets all the elements of the matrix to zero.",52,[[["self"]],["matrixcomplexf32"]]],[11,"set_identity","","This function sets the elements of the matrix to the corresponding elements of the identity matrix, m(i,j) = \\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero. This applies to both square and rectangular matrices.",52,[[["self"]],["matrixcomplexf32"]]],[11,"copy_from","","This function copies the elements of the other matrix into the self matrix. The two matrices must have the same size.",52,[[["self"],["matrixcomplexf32"]],["value"]]],[11,"copy_to","","This function copies the elements of the self matrix into the other matrix. The two matrices must have the same size.",52,[[["self"],["matrixcomplexf32"]],["value"]]],[11,"swap","","This function exchanges the elements of the matrices self and other by copying. The two matrices must have the same size.",52,[[["self"],["matrixcomplexf32"]],["value"]]],[11,"get_row","","This function copies the elements of the y-th row of the matrix into the returned vector.",52,[[["self"],["usize"]],["option"]]],[11,"get_col","","This function copies the elements of the x-th column of the matrix into the returned vector.",52,[[["self"],["usize"]],["option"]]],[11,"set_row","","This function copies the elements of the vector v into the y-th row of the matrix. The length of the vector must be the same as the length of the row.",52,[[["self"],["usize"],["vectorcomplexf32"]],["value"]]],[11,"set_col","","This function copies the elements of the vector v into the x-th column of the matrix. The length of the vector must be the same as the length of the column.",52,[[["self"],["usize"],["vectorcomplexf32"]],["value"]]],[11,"swap_rows","","This function exchanges the y1-th and y2-th rows of the matrix in-place.",52,[[["self"],["usize"],["usize"]],["value"]]],[11,"swap_columns","","This function exchanges the x1-th and x2-th columns of the matrix in-place.",52,[[["self"],["usize"],["usize"]],["value"]]],[11,"swap_row_col","","This function exchanges the i-th row and j-th column of the matrix in-place. The matrix must be square for this operation to be possible.",52,[[["self"],["usize"],["usize"]],["value"]]],[11,"transpose_memcpy","","This function returns the transpose of the matrix by copying the elements into it. This function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix.",52,[[["self"]],["option"]]],[11,"transpose","","This function replaces the matrix m by its transpose by copying the elements of the matrix in-place. The matrix must be square for this operation to be possible.",52,[[["self"]],["value"]]],[11,"add","","This function adds the elements of the other matrix to the elements of the self matrix. The result self(i,j) <- self(i,j) + other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",52,[[["self"],["matrixcomplexf32"]],["value"]]],[11,"sub","","This function subtracts the elements of the other matrix from the elements of the self matrix. The result self(i,j) <- self(i,j) - other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",52,[[["self"],["matrixcomplexf32"]],["value"]]],[11,"mul_elements","","This function multiplies the elements of the self matrix by the elements of the other matrix. The result self(i,j) <- self(i,j) * other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",52,[[["self"],["matrixcomplexf32"]],["value"]]],[11,"div_elements","","This function divides the elements of the self matrix by the elements of the other matrix. The result self(i,j) <- self(i,j) / other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",52,[[["self"],["matrixcomplexf32"]],["value"]]],[11,"scale","","This function multiplies the elements of the self matrix by the constant factor x. The result self(i,j) <- x self(i,j) is stored in self.",52,[[["self"],["complexf32"]],["value"]]],[11,"add_constant","","This function adds the constant value x to the elements of the self matrix. The result self(i,j) <- self(i,j) + x is stored in self.",52,[[["self"],["complexf32"]],["value"]]],[11,"is_null","","This function returns true if all the elements of the self matrix are stricly zero.",52,[[["self"]],["bool"]]],[11,"is_pos","","This function returns true if all the elements of the self matrix are stricly positive.",52,[[["self"]],["bool"]]],[11,"is_neg","","This function returns true if all the elements of the self matrix are stricly negative.",52,[[["self"]],["bool"]]],[11,"is_non_neg","","This function returns true if all the elements of the self matrix are stricly non-negative.",52,[[["self"]],["bool"]]],[11,"equal","","This function returns true if all elements of the two matrix are equal.",52,[[["self"],["matrixcomplexf32"]],["bool"]]],[11,"clone","","",52,[[["self"]],["option",["matrixcomplexf32"]]]],[0,"minimizer","rgsl::types","#One dimensional Minimization",N,N],[3,"Minimizer","rgsl::types::minimizer","",N,N],[3,"MinimizerType","","",N,N],[12,"name","","",53,N],[11,"new","","This function returns a pointer to a newly allocated instance of a minimizer of type T. For example, the following code creates an instance of a golden section minimizer,",54,[[["minimizertype"]],["option",["minimizer"]]]],[11,"set","","This function sets, or resets, an existing minimizer s to use the function f and the initial search interval [x_lower, x_upper], with a guess for the location of the minimum x_minimum.",54,[[["self"],["function"],["t"],["f64"],["f64"],["f64"]],["value"]]],[11,"set_with_values","","This function is equivalent to gsl_min_fminimizer_set but uses the values f_minimum, f_lower and f_upper instead of computing f(x_minimum), f(x_lower) and f(x_upper).",54,[[["self"],["function"],["t"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"]],["value"]]],[11,"name","","This function returns a pointer to the name of the minimizer. For example,",54,[[["self"]],["string"]]],[11,"x_minimum","","This function returns the current estimate of the position of the minimum for the minimizer s.",54,[[["self"]],["f64"]]],[11,"x_lower","","This function returns the current upper and lower bound of the interval for the minimizer s.",54,[[["self"]],["f64"]]],[11,"x_upper","","/// This function returns the current upper and lower bound of the interval for the minimizer s.",54,[[["self"]],["f64"]]],[11,"f_minimum","","This function returns the value of the function at the current estimate of the minimum and at the upper and lower bounds of the interval for the minimizer s.",54,[[["self"]],["f64"]]],[11,"f_lower","","This function returns the value of the function at the current estimate of the minimum and at the upper and lower bounds of the interval for the minimizer s.",54,[[["self"]],["f64"]]],[11,"f_upper","","This function returns the value of the function at the current estimate of the minimum and at the upper and lower bounds of the interval for the minimizer s.",54,[[["self"]],["f64"]]],[11,"iterate","","This function performs a single iteration of the minimizer s. If the iteration encounters an unexpected problem then an error code will be returned,",54,[[["self"]],["value"]]],[11,"golden_section","","The golden section algorithm is the simplest method of bracketing the minimum of a function. It is the slowest algorithm provided by the library, with linear convergence.",53,[[],["minimizertype"]]],[11,"brent","","The Brent minimization algorithm combines a parabolic interpolation with the golden section algorithm. This produces a fast algorithm which is still robust.",53,[[],["minimizertype"]]],[11,"quad_golden","","This is a variant of Brents algorithm which uses the safeguarded step-length algorithm of Gill and Murray.",53,[[],["minimizertype"]]],[0,"monte_carlo","rgsl::types","#Monte Carlo Integration",N,N],[3,"PlainMonteCarlo","rgsl::types::monte_carlo","The plain Monte Carlo algorithm samples points randomly from the integration region to estimate the integral and its error. Using this algorithm the estimate of the integral E(f; N) for N randomly distributed points x_i is given by,",N,N],[3,"MiserMonteCarlo","","The MISER algorithm of Press and Farrar is based on recursive stratified sampling. This technique aims to reduce the overall integration error by concentrating integration points in the regions of highest variance.",N,N],[3,"MiserParams","","",N,N],[12,"estimate_frac","","This parameter specifies the fraction of the currently available number of function calls which are allocated to estimating the variance at each recursive step. The default value is 0.1.",55,N],[12,"min_calls","","This parameter specifies the minimum number of function calls required for each estimate of the variance. If the number of function calls allocated to the estimate using estimate_frac falls below min_calls then min_calls are used instead. This ensures that each estimate maintains a reasonable level of accuracy. The default value of min_calls is 16 * dim.",55,N],[12,"min_calls_per_bisection","","This parameter specifies the minimum number of function calls required to proceed with a bisection step. When a recursive step has fewer calls available than min_calls_per_bisection it performs a plain Monte Carlo estimate of the current sub-region and terminates its branch of the recursion. The default value of this parameter is 32 * min_calls.",55,N],[12,"alpha","","This parameter controls how the estimated variances for the two sub-regions of a bisection are combined when allocating points. With recursive sampling the overall variance should scale better than 1/N, since the values from the sub-regions will be obtained using a procedure which explicitly minimizes their variance. To accommodate this behavior the MISER algorithm allows the total variance to depend on a scaling parameter \\alpha,",55,N],[12,"dither","","This parameter introduces a random fractional variation of size dither into each bisection, which can be used to break the symmetry of integrands which are concentrated near the exact center of the hypercubic integration region. The default value of dither is zero, so no variation is introduced. If needed, a typical value of dither is 0.1.",55,N],[3,"VegasMonteCarlo","","The VEGAS algorithm of Lepage is based on importance sampling. It samples points from the probability distribution described by the function |f|, so that the points are concentrated in the regions that make the largest contribution to the integral.",N,N],[3,"VegasParams","","",N,N],[4,"VegasVerbosity","","The default setting of verbose is `Off`, which turns off all output. A verbose value of `Summary` prints summary information about the weighted average and final result, while a value of `Grid` also displays the grid coordinates. A value of 'Rebinning' prints information from the rebinning procedure for each iteration.",N,N],[13,"Off","","",56,N],[13,"Summary","","",56,N],[13,"Grid","","",56,N],[13,"Rebinning","","",56,N],[11,"new","","This function allocates and initializes a workspace for Monte Carlo integration in dim dimensions.",57,[[["usize"]],["option",["plainmontecarlo"]]]],[11,"init","","This function initializes a previously allocated integration state. This allows an existing workspace to be reused for different integrations.",57,[[["self"]],["value"]]],[11,"integrate","","This routines uses the plain Monte Carlo algorithm to integrate the function f over the dim-dimensional hypercubic region defined by the lower and upper limits in the arrays xl and xu, each of the same size. The integration uses a fixed number of function calls calls, and obtains random sampling points using the random number generator r. A previously allocated workspace s must be supplied. The result of the integration is returned in result, with an estimated absolute error abserr.",57,N],[11,"new","","This function allocates and initializes a workspace for Monte Carlo integration in dim dimensions. The workspace is used to maintain the state of the integration.",58,[[["usize"]],["option",["misermontecarlo"]]]],[11,"init","","This function initializes a previously allocated integration state. This allows an existing workspace to be reused for different integrations.",58,[[["self"]],["value"]]],[11,"integrate","","This routines uses the MISER Monte Carlo algorithm to integrate the function f over the dim-dimensional hypercubic region defined by the lower and upper limits in the arrays xl and xu, each of size dim. The integration uses a fixed number of function calls calls, and obtains random sampling points using the random number generator r. A previously allocated workspace s must be supplied. The result of the integration is returned in result, with an estimated absolute error abserr.",58,N],[11,"get_params","","This function copies the parameters of the integrator state into the user-supplied params structure.",58,[[["self"]],["miserparams"]]],[11,"set_params","","This function sets the integrator parameters based on values provided in the params structure.",58,[[["self"],["miserparams"]]]],[11,"new","","This function allocates and initializes a workspace for Monte Carlo integration in dim dimensions. The workspace is used to maintain the state of the integration.",59,[[["usize"]],["option",["vegasmontecarlo"]]]],[11,"init","","This function initializes a previously allocated integration state. This allows an existing workspace to be reused for different integrations.",59,[[["self"]],["value"]]],[11,"integrate","","This routines uses the VEGAS Monte Carlo algorithm to integrate the function f over the dim-dimensional hypercubic region defined by the lower and upper limits in the arrays xl and xu, each of size dim. The integration uses a fixed number of function calls calls, and obtains random sampling points using the random number generator r. A previously allocated workspace s must be supplied. The result of the integration is returned in result, with an estimated absolute error abserr. The result and its error estimate are based on a weighted average of independent samples. The chi-squared per degree of freedom for the weighted average is returned via the state struct component, s->chisq, and must be consistent with 1 for the weighted average to be reliable.",59,N],[11,"chisq","","This function returns the chi-squared per degree of freedom for the weighted estimate of the integral. The returned value should be close to 1. A value which differs significantly from 1 indicates that the values from different iterations are inconsistent. In this case the weighted error will be under-estimated, and further iterations of the algorithm are needed to obtain reliable results.",59,[[["self"]],["f64"]]],[11,"runval","","This function returns the raw (unaveraged) values of the integral result and its error sigma from the most recent iteration of the algorithm.",59,[[["self"],["f64"],["f64"]]]],[11,"get_params","","",59,[[["self"]],["vegasparams"]]],[11,"set_params","","",59,[[["self"],["vegasparams"]]]],[11,"new","","alpha: The parameter alpha controls the stiffness of the rebinning algorithm. It is typically set between one and two. A value of zero prevents rebinning of the grid. The default value is 1.5.",60,[[["f64"],["usize"],["i32"],["vegasmode"],["vegasverbosity"],["option",["iostream"]]],["result",["vegasparams","string"]]]],[0,"multifit_solver","rgsl::types","#Nonlinear Least-Squares Fitting",N,N],[3,"MultiFitFSolverType","rgsl::types::multifit_solver","",N,N],[3,"MultiFitFSolver","","",N,N],[3,"MultiFitFunction","","",N,N],[12,"f","","",61,N],[12,"n","","number of functions",61,N],[12,"p","","number of independent variables",61,N],[12,"params","","",61,N],[3,"MultiFitFdfSolver","","",N,N],[3,"MultiFitFdfSolverType","","",N,N],[3,"MultiFitFunctionFdf","","",N,N],[12,"f","","",62,N],[12,"df","","",62,N],[12,"fdf","","",62,N],[12,"n","","",62,N],[12,"p","","",62,N],[11,"new","","This function returns a pointer to a newly allocated instance of a solver of type T for n observations and p parameters. The number of observations n must be greater than or equal to parameters p.",63,[[["multifitfsolvertype"],["usize"],["usize"]],["option",["multifitfsolver"]]]],[11,"set","","",63,[[["self"],["multifitfunction"],["vectorf64"]],["value"]]],[11,"iterate","","",63,[[["self"]],["value"]]],[11,"name","","",63,[[["self"]],["string"]]],[11,"position","","",63,[[["self"]],["vectorf64"]]],[11,"new","","This function returns a pointer to a newly allocated instance of a solver of type T for n observations and p parameters. The number of observations n must be greater than or equal to parameters p.",64,[[["multifitfdfsolvertype"],["usize"],["usize"]],["option",["multifitfdfsolver"]]]],[11,"set","","This function initializes, or reinitializes, an existing solver s to use the function f and the initial guess x.",64,[[["self"],["multifitfunctionfdf"],["vectorf64"]],["value"]]],[11,"x","","",64,[[["self"]],["vectorf64"]]],[11,"f","","",64,[[["self"]],["vectorf64"]]],[11,"J","","",64,[[["self"]],["matrixf64"]]],[11,"dx","","",64,[[["self"]],["vectorf64"]]],[11,"name","","",64,[[["self"]],["string"]]],[11,"iterate","","This function performs a single iteration of the solver s. If the iteration encounters an unexpected problem then an error code will be returned. The solver maintains a current estimate of the best-fit parameters at all times.",64,[[["self"]],["value"]]],[11,"position","","This function returns the current position (i.e. best-fit parameters) s->x of the solver s.",64,[[["self"]],["vectorf64"]]],[11,"driver","","These functions iterate the solver s for a maximum of maxiter iterations. After each iteration, the system is tested for convergence using gsl_multifit_test_delta with the error tolerances epsabs and epsrel.",64,[[["self"],["usize"],["f64"],["f64"]],["value"]]],[11,"lmder","","",65,[[],["multifitfdfsolvertype"]]],[11,"lmsder","","",65,[[],["multifitfdfsolvertype"]]],[11,"new","","",62,[[["usize"],["usize"]],["multifitfunctionfdf"]]],[0,"multiset","rgsl::types","#Multisets",N,N],[3,"MultiSet","rgsl::types::multiset","",N,N],[11,"new","","This function allocates memory for a new multiset with parameters n, k. The multiset is not initialized and its elements are  undefined. Use the function gsl_multiset_calloc if you want to create a multiset which is initialized to the lexicographically  first multiset element. A null pointer is returned if insufficient memory is available to create the multiset.",66,[[["usize"],["usize"]],["option",["multiset"]]]],[11,"new_init","","This function allocates memory for a new multiset with parameters n, k and initializes it to the lexicographically first multiset element. A null pointer is returned if insufficient memory is available to create the multiset.",66,[[["usize"],["usize"]],["option",["multiset"]]]],[11,"init_first","","This function initializes the multiset c to the lexicographically first multiset element, i.e. 0 repeated k times.",66,[[["self"]]]],[11,"init_last","","This function initializes the multiset c to the lexicographically last multiset element, i.e. n-1 repeated k times.",66,[[["self"]]]],[11,"copy","","This function copies the elements of the multiset self into the multiset dest. The two multisets must have the same size.",66,[[["self"],["multiset"]],["value"]]],[11,"get","","This function returns the value of the i-th element of the multiset c. If i lies outside the allowed range of 0 to k-1 then the error handler is invoked and 0 is returned.",66,[[["self"],["usize"]],["usize"]]],[11,"n","","This function returns the range (n) of the multiset self.",66,[[["self"]],["usize"]]],[11,"k","","This function returns the number of elements (k) in the multiset self.",66,[[["self"]],["usize"]]],[11,"data","","This function returns a pointer to the array of elements in the multiset self.",66,N],[11,"valid","","This function checks that the multiset self is valid. The k elements should lie in the range 0 to n-1, with each value occurring in nondecreasing order.",66,[[["self"]],["value"]]],[11,"next","","This function advances the multiset self to the next multiset element in lexicographic order and returns ::Value::Success. If no further multisets elements are available it returns enums::value::Failure and leaves self unmodified. Starting with the first multiset and repeatedly applying this function will iterate through all possible multisets of a given order.",66,[[["self"]],["value"]]],[11,"prev","","This function steps backwards from the multiset self to the previous multiset element in lexicographic order, returning ::Value::Success. If no previous multiset is available it returns enums::value::Failure and leaves self unmodified.",66,[[["self"]],["value"]]],[11,"print","","",66,[[["self"],["write"]],["ioresult"]]],[0,"n_tuples","rgsl::types","#N-tuples",N,N],[3,"NTuples","rgsl::types::n_tuples","",N,N],[11,"create","","This function creates a new write-only ntuple file filename for ntuples of size size and returns a pointer to the newly created ntuple struct. Any existing file with the same name is truncated to zero length and overwritten. A pointer to memory for the current ntuple row ntuple_data must be suppliedthis is used to copy ntuples in and out of the file.",67,[[["str"],["t"]],["option",["ntuples"]]]],[11,"open","","This function opens an existing ntuple file filename for reading and returns a pointer to a corresponding ntuple struct. The ntuples in the file must have size size. A pointer to memory for the current ntuple row ntuple_data must be suppliedthis is used to copy ntuples in and out of the file.",67,[[["str"],["t"]],["option",["ntuples"]]]],[11,"write","","This function writes the current ntuple ntuple->ntuple_data of size ntuple->size to the corresponding file.",67,[[["self"]],["value"]]],[11,"bookdata","","This function is a synonym for NTuples::write.",67,[[["self"]],["value"]]],[11,"read","","This function reads the current row of the ntuple file for ntuple and stores the values in ntuple->data.",67,[[["self"]],["value"]]],[11,"project","","",67,[[["self"],["histogram"],["value_function"],["u"],["select_function"],["v"]],["value"]]],[0,"ordinary_differential_equations","rgsl::types","Numerical ODE solvers.",N,N],[3,"ODEiv2System","rgsl::types::ordinary_differential_equations","Description of a system of ODEs.",N,N],[3,"ODEiv2Step","","",N,N],[3,"ODEiv2StepType","","",N,N],[3,"ODEiv2Control","","",N,N],[3,"ODEiv2ControlType","","",N,N],[3,"ODEiv2Evolve","","",N,N],[3,"ODEiv2Driver","","",N,N],[11,"new","","Returns a new ODEiv2System with a given dimension and right-hand side.",68,[[["usize"],["fnmut"]],["odeiv2system"]]],[11,"with_jacobian","","Returns a new ODEiv2System with a jacobian function provided.",68,[[["usize"],["fnmut"],["fnmut"]],["odeiv2system"]]],[11,"new","","This function returns a pointer to a newly allocated instance of a stepping function of type T for a system of dim dimensions. Please note that if you use a stepper method that requires access to a driver object, it is advisable to use a driver allocation method, which automatically allocates a stepper, too.",69,[[["odeiv2steptype"],["usize"]],["option",["odeiv2step"]]]],[11,"reset","","This function resets the stepping function s. It should be used whenever the next use of s will not be a continuation of a previous step.",69,[[["self"]],["gslresult"]]],[11,"name","","This function returns a pointer to the name of the stepping function. For example,",69,[[["self"]],["option",["string"]]]],[11,"order","","This function returns the order of the stepping function on the previous step. The order can vary if the stepping function itself is adaptive.",69,[[["self"]],["u32"]]],[11,"set_driver","","This function sets a pointer of the driver object d for stepper s, to allow the stepper to access control (and evolve) object through the driver object. This is a requirement for some steppers, to get the desired error level for internal iteration of stepper. Allocation of a driver object calls this function automatically.",69,[[["self"],["odeiv2driver"]],["gslresult"]]],[11,"apply","","This function applies the stepping function s to the system of equations defined by sys, using the step-size h to advance the system from time t and state y to time t+h. The new state of the system is stored in y on output, with an estimate of the absolute error in each component stored in yerr. If the argument dydt_in is not null it should point an array containing the derivatives for the system at time t on input. This is optional as the derivatives will be computed internally if they are not provided, but allows the reuse of existing derivative information. On output the new derivatives of the system at time t+h will be stored in dydt_out if it is not null.",69,N],[11,"rk2","","Explicit embedded Runge-Kutta (2, 3) method.",70,[[],["odeiv2steptype"]]],[11,"rk4","","Explicit 4th order (classical) Runge-Kutta. Error estimation is carried out by the step doubling method. For more efficient estimate of the error, use the embedded methods described below.",70,[[],["odeiv2steptype"]]],[11,"rk45","","Explicit embedded Runge-Kutta-Fehlberg (4, 5) method. This method is a good general-purpose integrator.",70,[[],["odeiv2steptype"]]],[11,"rkck","","Explicit embedded Runge-Kutta Cash-Karp (4, 5) method.",70,[[],["odeiv2steptype"]]],[11,"rk8pd","","Explicit embedded Runge-Kutta Prince-Dormand (8, 9) method.",70,[[],["odeiv2steptype"]]],[11,"rk1imp","","Implicit Gaussian first order Runge-Kutta. Also known as implicit Euler or backward Euler method. Error estimation is carried out by the step doubling method. This algorithm requires the Jacobian and access to the driver object via gsl_odeiv2_step_set_driver.",70,[[],["odeiv2steptype"]]],[11,"rk2imp","","Implicit Gaussian second order Runge-Kutta. Also known as implicit mid-point rule. Error estimation is carried out by the step doubling method. This stepper requires the Jacobian and access to the driver object via gsl_odeiv2_step_set_driver.",70,[[],["odeiv2steptype"]]],[11,"rk4imp","","Implicit Gaussian 4th order Runge-Kutta. Error estimation is carried out by the step doubling method. This algorithm requires the Jacobian and access to the driver object via gsl_odeiv2_step_set_driver.",70,[[],["odeiv2steptype"]]],[11,"bsimp","","Implicit Bulirsch-Stoer method of Bader and Deuflhard. The method is generally suitable for stiff problems. This stepper requires the Jacobian.",70,[[],["odeiv2steptype"]]],[11,"msadams","","A variable-coefficient linear multistep Adams method in Nordsieck form. This stepper uses explicit Adams-Bashforth (predictor) and implicit Adams-Moulton (corrector) methods in P(EC)^m functional iteration mode. Method order varies dynamically between 1 and 12. This stepper requires the access to the driver object via gsl_odeiv2_step_set_driver.",70,[[],["odeiv2steptype"]]],[11,"msbdf","","A variable-coefficient linear multistep backward differentiation formula (BDF) method in Nordsieck form. This stepper uses the explicit BDF formula as predictor and implicit BDF formula as corrector. A modified Newton iteration method is used to solve the system of non-linear equations. Method order varies dynamically between 1 and 5. The method is generally suitable for stiff problems. This stepper requires the Jacobian and the access to the driver object via gsl_odeiv2_step_set_driver.",70,[[],["odeiv2steptype"]]],[11,"standard_new","","The standard control object is a four parameter heuristic based on absolute and relative errors eps_abs and eps_rel, and scaling factors a_y and a_dydt for the system state y(t) and derivatives y'(t) respectively.",71,[[["f64"],["f64"],["f64"],["f64"]],["option",["odeiv2control"]]]],[11,"y_new","","This function creates a new control object which will keep the local error on each step within an absolute error of eps_abs and relative error of eps_rel with respect to the solution y_i(t). This is equivalent to the standard control object with a_y=1 and a_dydt=0.",71,[[["f64"],["f64"]],["option",["odeiv2control"]]]],[11,"yp_new","","This function creates a new control object which will keep the local error on each step within an absolute error of eps_abs and relative error of eps_rel with respect to the derivatives of the solution y'_i(t). This is equivalent to the standard control object with a_y=0 and a_dydt=1.",71,[[["f64"],["f64"]],["option",["odeiv2control"]]]],[11,"scaled_new","","This function creates a new control object which uses the same algorithm as gsl_odeiv2_control_standard_new but with an absolute error which is scaled for each component by the array scale_abs. The formula for D_i for this control object is,",71,N],[11,"alloc","","This function returns a pointer to a newly allocated instance of a control function of type T. This function is only needed for defining new types of control functions. For most purposes the standard control functions described above should be sufficient.",71,[[["odeiv2controltype"]],["option",["odeiv2control"]]]],[11,"init","","This function initializes the control function c with the parameters eps_abs (absolute error), eps_rel (relative error), a_y (scaling factor for y) and a_dydt (scaling factor for derivatives).",71,[[["self"],["f64"],["f64"],["f64"],["f64"]],["gslresult"]]],[11,"hadjust","","This function adjusts the step-size h using the control function c, and the current values of y, yerr and dydt. The stepping function step is also needed to determine the order of the method. If the error in the y-values yerr is found to be too large then the step-size h is reduced and the function returns ODEiv::Dec. If the error is sufficiently small then h may be increased and ODEiv::Inc is returned. The function returns ODEiv::Nil if the step-size is unchanged. The goal of the function is to estimate the largest step-size which satisfies the user-specified accuracy requirements for the current point.",71,N],[11,"name","","This function returns a pointer to the name of the control function. For example,",71,[[["self"]],["option",["string"]]]],[11,"errlevel","","This function calculates the desired error level of the ind-th component to errlev. It requires the value (y) and value of the derivative (dydt) of the component, and the current step size h.",71,[[["self"],["f64"],["f64"],["f64"],["usize"],["f64"]],["gslresult"]]],[11,"set_driver","","This function sets a pointer of the driver object d for control object c.",71,[[["self"],["odeiv2driver"]],["gslresult"]]],[11,"scaled","","",72,[[],["odeiv2controltype"]]],[11,"standard","","",72,[[],["odeiv2controltype"]]],[11,"new","","This function returns a pointer to a newly allocated instance of an evolution function for a system of dim dimensions.",73,[[["usize"]],["option",["odeiv2evolve"]]]],[11,"apply","","This function advances the system (e, sys) from time t and position y using the stepping function step. The new time and position are stored in t and y on output.",73,N],[11,"apply_fixed_step","","This function advances the ODE-system (e, sys, con) from time t and position y using the stepping function step by a specified step size h. If the local error estimated by the stepping function exceeds the desired error level, the step is not taken and the function returns enums::value::Failure. Otherwise the value returned by user function is returned.",73,N],[11,"reset","","This function resets the evolution function e. It should be used whenever the next use of e will not be a continuation of a previous step.",73,[[["self"]],["gslresult"]]],[11,"set_driver","","This function sets a pointer of the driver object d for evolve object e.",73,[[["self"],["odeiv2driver"]],["gslresult"]]],[11,"alloc_y_new","","These functions return a pointer to a newly allocated instance of a driver object. The functions automatically allocate and initialise the evolve, control and stepper objects for ODE system sys using stepper type T. The initial step size is given in hstart. The rest of the arguments follow the syntax and semantics of the control functions with same name (gsl_odeiv2_control_*_new).",74,[[["odeiv2system"],["odeiv2steptype"],["f64"],["f64"],["f64"]],["option",["odeiv2driver"]]]],[11,"alloc_yp_new","","These functions return a pointer to a newly allocated instance of a driver object. The functions automatically allocate and initialise the evolve, control and stepper objects for ODE system sys using stepper type T. The initial step size is given in hstart. The rest of the arguments follow the syntax and semantics of the control functions with same name (gsl_odeiv2_control_*_new).",74,[[["odeiv2system"],["odeiv2steptype"],["f64"],["f64"],["f64"]],["option",["odeiv2driver"]]]],[11,"alloc_standard_new","","These functions return a pointer to a newly allocated instance of a driver object. The functions automatically allocate and initialise the evolve, control and stepper objects for ODE system sys using stepper type T. The initial step size is given in hstart. The rest of the arguments follow the syntax and semantics of the control functions with same name (gsl_odeiv2_control_*_new).",74,[[["odeiv2system"],["odeiv2steptype"],["f64"],["f64"],["f64"],["f64"],["f64"]],["option",["odeiv2driver"]]]],[11,"alloc_scaled_new","","These functions return a pointer to a newly allocated instance of a driver object. The functions automatically allocate and initialise the evolve, control and stepper objects for ODE system sys using stepper type T. The initial step size is given in hstart. The rest of the arguments follow the syntax and semantics of the control functions with same name (gsl_odeiv2_control_*_new).",74,N],[11,"set_hmin","","The function sets a minimum for allowed step size hmin for driver self. Default value is 0.",74,[[["self"],["f64"]],["gslresult"]]],[11,"set_hmax","","The function sets a maximum for allowed step size hmax for driver self. Default value is ::DBL_MAX.",74,[[["self"],["f64"]],["gslresult"]]],[11,"set_nmax","","The function sets a maximum for allowed number of steps nmax for driver self. Default value of 0 sets no limit for steps.",74,[[["self"],["usize"]],["gslresult"]]],[11,"apply","","This function evolves the driver system d from t to t1. Initially vector y should contain the values of dependent variables at point t. If the function is unable to complete the calculation, an error code from gsl_odeiv2_evolve_apply is returned, and t and y contain the values from last successful step.",74,N],[11,"apply_fixed_step","","This function evolves the driver system d from t with n steps of size h. If the function is unable to complete the calculation, an error code from gsl_odeiv2_evolve_apply_fixed_step is returned, and t and y contain the values from last successful step.",74,N],[11,"reset","","This function resets the evolution and stepper objects.",74,[[["self"]],["gslresult"]]],[11,"reset_hstart","","The routine resets the evolution and stepper objects and sets new initial step size to hstart. This function can be used e.g. to change the direction of integration.",74,[[["self"],["f64"]],["gslresult"]]],[0,"permutation","rgsl::types","",N,N],[3,"Permutation","rgsl::types::permutation","",N,N],[11,"new","","This function allocates memory for a new permutation of size n. The permutation is not initialized and its elements are undefined. Use the function gsl_permutation_calloc if you want to create a permutation which is initialized to the identity. A null pointer is returned if insufficient memory is available to create the permutation.",75,[[["usize"]],["option",["permutation"]]]],[11,"new_with_init","","This function allocates memory for a new permutation of size n and initializes it to the identity. A null pointer is returned if insufficient memory is available to create the permutation.",75,[[["usize"]],["option",["permutation"]]]],[11,"init","","This function initializes the permutation p to the identity, i.e. (0,1,2,,n-1).",75,[[["self"]]]],[11,"copy","","This function copies the elements of the permutation src into the permutation dest. The two permutations must have the same size.",75,[[["self"],["permutation"]],["value"]]],[11,"get","","This function returns the value of the i-th element of the permutation p. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.",75,[[["self"],["usize"]],["usize"]]],[11,"swap","","This function exchanges the i-th and j-th elements of the permutation p.",75,[[["self"],["usize"],["usize"]],["value"]]],[11,"size","","This function returns the size of the permutation p.",75,[[["self"]],["usize"]]],[11,"data","","This function returns a pointer to the array of elements in the permutation p.",75,N],[11,"is_valid","","This function checks that the permutation p is valid. The n elements should contain each of the numbers 0 to n-1 once and only once.",75,[[["self"]],["bool"]]],[11,"reverse","","This function reverses the elements of the permutation p.",75,[[["self"]]]],[11,"inverse","","This function computes the inverse of the permutation p, storing the result in inv.",75,[[["self"],["permutation"]],["value"]]],[11,"next","","This function advances the permutation p to the next permutation in lexicographic order and returns GSL_SUCCESS. If no further permutations are available it returns GSL_FAILURE and leaves p unmodified. Starting with the identity permutation and repeatedly applying this function will iterate through all possible permutations of a given order.",75,[[["self"]],["value"]]],[11,"prev","","This function steps backwards from the permutation p to the previous permutation in lexicographic order, returning GSL_SUCCESS. If no previous permutation is available it returns GSL_FAILURE and leaves p unmodified.",75,[[["self"]],["value"]]],[11,"permute","","This function applies the permutation to the array data of size n with stride stride.",75,N],[11,"permute_inverse","","This function applies the inverse of the permutation p to the array data of size n with stride stride.",75,N],[11,"permute_vector","","This function applies the permutation p to the elements of the vector v, considered as a row-vector acted on by a permutation matrix from the right, v' = v P. The j-th column of the permutation matrix P is given by the p_j-th column of the identity matrix. The permutation p and the vector v must have the same length.",75,[[["self"],["vectorf64"]],["value"]]],[11,"permute_vector_inverse","","This function applies the inverse of the permutation p to the elements of the vector v, considered as a row-vector acted on by an inverse permutation matrix from the right, v' = v P^T. Note that for permutation matrices the inverse is the same as the transpose. The j-th column of the permutation matrix P is given by the p_j-th column of the identity matrix. The permutation p and the vector v must have the same length.",75,[[["self"],["vectorf64"]],["value"]]],[11,"mul","","This function combines the two permutations pa and pb into a single permutation p, where p = pa * pb. The permutation p is equivalent to applying pb first and then pa.",75,[[["self"],["permutation"],["permutation"]],["value"]]],[11,"linear_to_canonical","","This function computes the canonical form of the permutation self and stores it in the output argument q.",75,[[["self"],["permutation"]],["value"]]],[11,"canonical_to_linear","","This function converts the self permutation in canonical form back into linear form storing it in the output argument p.",75,[[["self"],["permutation"]],["value"]]],[11,"inversions","","This function counts the number of inversions in the self permutation. An inversion is any pair of elements that are not in order. For example, the permutation 2031 has three inversions, corresponding to the pairs (2,0) (2,1) and (3,1). The identity permutation has no inversions.",75,[[["self"]],["usize"]]],[11,"linear_cycles","","This function counts the number of cycles in the self permutation, given in linear form.",75,[[["self"]],["usize"]]],[11,"canonical_cycles","","This function counts the number of cycles in the self permutation, given in canonical form.",75,[[["self"]],["usize"]]],[0,"polynomial","rgsl::types","#General Polynomial Equations",N,N],[3,"PolyComplex","rgsl::types::polynomial","",N,N],[11,"new","","This function allocates space for a gsl_poly_complex_workspace struct and a workspace suitable for solving a polynomial with n coefficients using the routine gsl_poly_complex_solve.",76,[[["usize"]],["option",["polycomplex"]]]],[11,"solve","","This function computes the roots of the general polynomial P(x) = a_0 + a_1 x + a_2 x^2 + ... + a_{n-1} x^{n-1} using balanced-QR reduction of the companion matrix. The parameter n specifies the length of the coefficient array. The coefficient of the highest order term must be non-zero. The function requires a workspace w of the appropriate size. The n-1 roots are returned in the packed complex array z of length 2(n-1), alternating real and imaginary parts.",76,N],[0,"qrng","rgsl::types","#Quasi-Random Sequences",N,N],[3,"QRng","rgsl::types::qrng","",N,N],[3,"QRngType","","",N,N],[11,"new","","This function returns a pointer to a newly-created instance of a quasi-random sequence generator of type T and dimension d. If there is insufficient memory to create the generator then the function returns a null pointer and the error handler is invoked with an error code of ::NoMem.",77,[[["qrngtype"],["u32"]],["option",["qrng"]]]],[11,"init","","This function reinitializes the generator self to its starting point. Note that quasi-random sequences do not use a seed and always produce the same set of values.",77,[[["self"]]]],[11,"get","","This function stores the next point from the sequence generator self in the array x. The space available for x must match the dimension of the generator. The point x will lie in the range 0 < x_i < 1 for each x_i.",77,N],[11,"name","","This function returns a pointer to the name of the generator.",77,[[["self"]],["option",["string"]]]],[11,"size","","These functions return a pointer to the state of generator r and its size.",77,[[["self"]],["usize"]]],[11,"state","","These functions return a pointer to the state of generator r and its size.",77,N],[11,"copy","","This function copies the quasi-random sequence generator src into the pre-existing generator dest, making dest into an exact copy of src. The two generators must be of the same type.",77,[[["self"],["qrng"]],["value"]]],[11,"niederreiter_2","","This generator uses the algorithm described in Bratley, Fox, Niederreiter, ACM Trans. Model. Comp. Sim. 2, 195 (1992). It is valid up to 12 dimensions.",78,[[],["qrngtype"]]],[11,"sobol","","This generator uses the Sobol sequence described in Antonov, Saleev, USSR Comput. Maths. Math. Phys. 19, 252 (1980). It is valid up to 40 dimensions.",78,[[],["qrngtype"]]],[11,"halton","","These generators use the Halton and reverse Halton sequences described in J.H. Halton, Numerische Mathematik 2, 84-90 (1960) and B. Vandewoestyne and R. Cools Computational and Applied Mathematics 189, 1&2, 341-361 (2006). They are valid up to 1229 dimensions.",78,[[],["qrngtype"]]],[11,"reversehalton","","",78,[[],["qrngtype"]]],[0,"ran_discrete","rgsl::types","Given K discrete events with different probabilities P[k], produce a random value k consistent with its probability.",N,N],[3,"RanDiscrete","rgsl::types::ran_discrete","",N,N],[11,"new","","This function returns a pointer to a structure that contains the lookup table for the discrete random number generator. The array P[] contains the probabilities of the discrete events; these array elements must all be positive, but they neednt add up to one (so you can think of them more generally as weights)the preprocessor will normalize appropriately. This return value is used as an argument for the gsl_ran_discrete function below.",79,N],[11,"discrete","","After the new, above, has been called, you use this function to get the discrete random numbers.",79,[[["self"],["rng"]],["usize"]]],[11,"discrete_pdf","","Returns the probability P[k] of observing the variable k. Since P[k] is not stored as part of the lookup table, it must be recomputed; this computation takes O(K), so if K is large and you care about the original array P[k] used to create the lookup table, then you should just keep this original array P[k] around.",79,[[["self"],["usize"]],["f64"]]],[0,"result","rgsl::types","",N,N],[3,"Result","rgsl::types::result","The error handling form of the special functions always calculate an error estimate along with the value of the result. Therefore, structures are provided for amalgamating a value and error estimate.",N,N],[12,"val","","Contains the value.",80,N],[12,"err","","Contains an estimate of the absolute error in the value.",80,N],[3,"ResultE10","","In some cases, an overflow or underflow can be detected and handled by a function. In this case, it may be possible to return a scaling exponent as well as an error/value pair in order to save the result from exceeding the dynamic range of the built-in types.",N,N],[12,"val","","Contains the value.",81,N],[12,"err","","Contains an estimate of the absolute error in the value.",81,N],[12,"e10","","Exponent field such that the actual result is obtained as result * 10^(e10).",81,N],[11,"new","","",80,[[],["result"]]],[11,"new","","",81,[[],["resulte10"]]],[0,"rng","rgsl::types","#Random Number Generation",N,N],[3,"Rng","rgsl::types::rng","",N,N],[3,"RngType","","",N,N],[5,"default","","",N,[[],["rngtype"]]],[0,"algorithms","","The functions described above make no reference to the actual algorithm used. This is deliberate so that you can switch algorithms without having to change any of your application source code. The library provides a large number of generators of different types, including simulation quality generators, generators provided for compatibility with other libraries and historical generators from the past.",N,N],[5,"mt19937","rgsl::types::rng::algorithms","The MT19937 generator of Makoto Matsumoto and Takuji Nishimura is a variant of the twisted generalized feedback shift-register algorithm, and is known as the Mersenne Twister generator. It has a Mersenne prime period of 2^19937 - 1 (about 10^6000) and is equi-distributed in 623 dimensions. It has passed the DIEHARD statistical tests. It uses 624 words of state per generator and is comparable in speed to the other generators. The original generator used a default seed of 4357 and choosing s equal to zero in gsl_rng_set reproduces this. Later versions switched to 5489 as the default seed, you can choose this explicitly via gsl_rng_set instead if you require it.",N,[[],["rngtype"]]],[5,"ranlxs0","","The generator ranlxs0 is a second-generation version of the RANLUX algorithm of Lscher, which produces luxury random numbers. This generator provides single precision output (24 bits) at three luxury levels ranlxs0, ranlxs1 and ranlxs2, in increasing order of strength. It uses double-precision floating point arithmetic internally and can be significantly faster than the integer version of ranlux, particularly on 64-bit architectures. The period of the generator is about 10^171. The algorithm has mathematically proven properties and can provide truly decorrelated numbers at a known level of randomness. The higher luxury levels provide increased decorrelation between samples as an additional safety margin.",N,[[],["rngtype"]]],[5,"ranlxs1","","The generator ranlxs0 is a second-generation version of the RANLUX algorithm of Lscher, which produces luxury random numbers. This generator provides single precision output (24 bits) at three luxury levels ranlxs0, ranlxs1 and ranlxs2, in increasing order of strength. It uses double-precision floating point arithmetic internally and can be significantly faster than the integer version of ranlux, particularly on 64-bit architectures. The period of the generator is about 10^171. The algorithm has mathematically proven properties and can provide truly decorrelated numbers at a known level of randomness. The higher luxury levels provide increased decorrelation between samples as an additional safety margin.",N,[[],["rngtype"]]],[5,"ranlxs2","","The generator ranlxs0 is a second-generation version of the RANLUX algorithm of Lscher, which produces luxury random numbers. This generator provides single precision output (24 bits) at three luxury levels ranlxs0, ranlxs1 and ranlxs2, in increasing order of strength. It uses double-precision floating point arithmetic internally and can be significantly faster than the integer version of ranlux, particularly on 64-bit architectures. The period of the generator is about 10^171. The algorithm has mathematically proven properties and can provide truly decorrelated numbers at a known level of randomness. The higher luxury levels provide increased decorrelation between samples as an additional safety margin.",N,[[],["rngtype"]]],[5,"ranlxd1","","This generator produces double precision output (48 bits) from the RANLXS generator. The library provides two luxury levels ranlxd1 and ranlxd2, in increasing order of strength.",N,[[],["rngtype"]]],[5,"ranlxd2","","This generator produces double precision output (48 bits) from the RANLXS generator. The library provides two luxury levels ranlxd1 and ranlxd2, in increasing order of strength.",N,[[],["rngtype"]]],[5,"ranlux","","The ranlux generator is an implementation of the original algorithm developed by Lscher. It uses a lagged-fibonacci-with-skipping algorithm to produce luxury random numbers. It is a 24-bit generator, originally designed for single-precision IEEE floating point numbers. This implementation is based on integer arithmetic, while the second-generation versions RANLXS and RANLXD described above provide floating-point implementations which will be faster on many platforms. The period of the generator is about 10^171. The algorithm has mathematically proven properties and it can provide truly decorrelated numbers at a known level of randomness. The default level of decorrelation recommended by Lscher is provided by gsl_rng_ranlux, while gsl_rng_ranlux389 gives the highest level of randomness, with all 24 bits decorrelated. Both types of generator use 24 words of state per generator.",N,[[],["rngtype"]]],[5,"ranlux389","","The ranlux generator is an implementation of the original algorithm developed by Lscher. It uses a lagged-fibonacci-with-skipping algorithm to produce luxury random numbers. It is a 24-bit generator, originally designed for single-precision IEEE floating point numbers. This implementation is based on integer arithmetic, while the second-generation versions RANLXS and RANLXD described above provide floating-point implementations which will be faster on many platforms. The period of the generator is about 10^171. The algorithm has mathematically proven properties and it can provide truly decorrelated numbers at a known level of randomness. The default level of decorrelation recommended by Lscher is provided by gsl_rng_ranlux, while gsl_rng_ranlux389 gives the highest level of randomness, with all 24 bits decorrelated. Both types of generator use 24 words of state per generator.",N,[[],["rngtype"]]],[5,"cmrg","","This is a combined multiple recursive generator by LEcuyer. Its sequence is,",N,[[],["rngtype"]]],[5,"mrg","","This is a fifth-order multiple recursive generator by LEcuyer, Blouin and Coutre. Its sequence is,",N,[[],["rngtype"]]],[5,"taus","","This is a maximally equidistributed combined Tausworthe generator by LEcuyer. The sequence is,",N,[[],["rngtype"]]],[5,"taus2","","This is a maximally equidistributed combined Tausworthe generator by LEcuyer. The sequence is,",N,[[],["rngtype"]]],[5,"gfsr4","","The gfsr4 generator is like a lagged-fibonacci generator, and produces each number as an xord sum of four previous values.",N,[[],["rngtype"]]],[0,"unix","rgsl::types::rng","The standard Unix random number generators rand, random and rand48 are provided as part of GSL. Although these generators are widely available individually often they arent all available on the same platform. This makes it difficult to write portable code using them and so we have included the complete set of Unix generators in GSL for convenience. Note that these generators dont produce high-quality randomness and arent suitable for work requiring accurate statistics. However, if you wont be measuring statistical quantities and just want to introduce some variation into your program then these generators are quite acceptable.",N,N],[5,"rand","rgsl::types::rng::unix","This is the BSD rand generator. Its sequence is",N,[[],["rngtype"]]],[5,"random_bsd","","These generators implement the random family of functions, a set of linear feedback shift register generators originally used in BSD Unix. There are several versions of random in use today: the original BSD version (e.g. on SunOS4), a libc5 version (found on older GNU/Linux systems) and a glibc2 version. Each version uses a different seeding procedure, and thus produces different sequences.",N,[[],["rngtype"]]],[5,"random_libc5","","These generators implement the random family of functions, a set of linear feedback shift register generators originally used in BSD Unix. There are several versions of random in use today: the original BSD version (e.g. on SunOS4), a libc5 version (found on older GNU/Linux systems) and a glibc2 version. Each version uses a different seeding procedure, and thus produces different sequences.",N,[[],["rngtype"]]],[5,"random_glic2","","These generators implement the random family of functions, a set of linear feedback shift register generators originally used in BSD Unix. There are several versions of random in use today: the original BSD version (e.g. on SunOS4), a libc5 version (found on older GNU/Linux systems) and a glibc2 version. Each version uses a different seeding procedure, and thus produces different sequences.",N,[[],["rngtype"]]],[5,"rand48","","This is the Unix rand48 generator. Its sequence is",N,[[],["rngtype"]]],[0,"other","rgsl::types::rng","##Other random number generators",N,N],[5,"ranf","rgsl::types::rng::other","This is the CRAY random number generator RANF. Its sequence is",N,[[],["rngtype"]]],[5,"ranmar","","This is the RANMAR lagged-fibonacci generator of Marsaglia, Zaman and Tsang. It is a 24-bit generator, originally designed for single-precision IEEE floating point numbers.  It was included in the CERNLIB high-energy physics library.",N,[[],["rngtype"]]],[5,"r250","","This is the shift-register generator of Kirkpatrick and Stoll. The sequence is based on the recurrence",N,[[],["rngtype"]]],[5,"tt800","","This is an earlier version of the twisted generalized feedback shift-register generator, and has been superseded by the development of MT19937. However, it is still an acceptable generator in its own right. It has a period of 2^800 and uses 33 words of storage per generator.",N,[[],["rngtype"]]],[5,"vax","","This is the VAX generator MTH$RANDOM. Its sequence is,",N,[[],["rngtype"]]],[5,"transputer","","This is the random number generator from the INMOS Transputer Development system. Its sequence is,",N,[[],["rngtype"]]],[5,"randu","","This is the IBM RANDU generator. Its sequence is",N,[[],["rngtype"]]],[5,"minstd","","This is Park and Millers minimal standard MINSTD generator, a simple linear congruence which takes care to avoid the major pitfalls of such algorithms. Its sequence is,",N,[[],["rngtype"]]],[5,"uni","","This is a reimplementation of the 16-bit SLATEC random number generator RUNIF. A generalization of the generator to 32 bits is provided by gsl_rng_uni32. The original source code is available from NETLIB.",N,[[],["rngtype"]]],[5,"uni32","","This is a reimplementation of the 16-bit SLATEC random number generator RUNIF. A generalization of the generator to 32 bits is provided by gsl_rng_uni32. The original source code is available from NETLIB.",N,[[],["rngtype"]]],[5,"slatec","","This is the SLATEC random number generator RAND. It is ancient. The original source code is available from NETLIB.",N,[[],["rngtype"]]],[5,"zuf","","This is the ZUFALL lagged Fibonacci series generator of Peterson. Its sequence is,",N,[[],["rngtype"]]],[5,"knuthran2","","This is a second-order multiple recursive generator described by Knuth in Seminumerical Algorithms, 3rd Ed., page 108. Its sequence is,",N,[[],["rngtype"]]],[5,"knuthran2002","","This is a second-order multiple recursive generator described by Knuth in Seminumerical Algorithms, 3rd Ed., Section 3.6. Knuth provides its C code. The updated routine gsl_rng_knuthran2002 is from the revised 9th printing and corrects some weaknesses in the earlier version, which is implemented as gsl_rng_knuthran.",N,[[],["rngtype"]]],[5,"knuthran","","This is a second-order multiple recursive generator described by Knuth in Seminumerical Algorithms, 3rd Ed., Section 3.6. Knuth provides its C code. The updated routine gsl_rng_knuthran2002 is from the revised 9th printing and corrects some weaknesses in the earlier version, which is implemented as gsl_rng_knuthran.",N,[[],["rngtype"]]],[5,"borosh13","","This multiplicative generator is taken from Knuths Seminumerical Algorithms, 3rd Ed., pages 106108. Their sequence is,",N,[[],["rngtype"]]],[5,"fishman18","","This multiplicative generator is taken from Knuths Seminumerical Algorithms, 3rd Ed., pages 106108. Their sequence is,",N,[[],["rngtype"]]],[5,"fishman20","","This multiplicative generator is taken from Knuths Seminumerical Algorithms, 3rd Ed., pages 106108. Their sequence is,",N,[[],["rngtype"]]],[5,"lecuyer21","","This multiplicative generator is taken from Knuths Seminumerical Algorithms, 3rd Ed., pages 106108. Their sequence is,",N,[[],["rngtype"]]],[5,"waterman14","","This multiplicative generator is taken from Knuths Seminumerical Algorithms, 3rd Ed., pages 106108. Their sequence is,",N,[[],["rngtype"]]],[5,"fishman2x","","This is the LEcuyerFishman random number generator. It is taken from Knuths Seminumerical Algorithms, 3rd Ed., page 108. Its sequence is,",N,[[],["rngtype"]]],[5,"coveyou","","This is the Coveyou random number generator. It is taken from Knuths Seminumerical Algorithms, 3rd Ed., Section 3.2.2. Its sequence is,",N,[[],["rngtype"]]],[11,"new","rgsl::types::rng","This function returns a pointer to a newly-created instance of a random number generator of type T. For example, the following code creates an instance of the Tausworthe generator,",82,[[["rngtype"]],["option",["rng"]]]],[11,"set","","This function initializes (or seeds) the random number generator. If the generator is seeded with the same value of s on two different runs, the same stream of random numbers will be generated by successive calls to the routines below. If different values of s >= 1 are supplied, then the generated streams of random numbers should be completely different. If the seed s is zero then the standard seed from the original implementation is used instead. For example, the original Fortran source code for the ranlux generator used a seed of 314159265, and so choosing s equal to zero reproduces this when using gsl_rng_ranlux.",82,[[["self"],["usize"]]]],[11,"get","","This function returns a random integer from the generator r. The minimum and maximum values depend on the algorithm used, but all integers in the range [min,max] are equally likely. The values of min and max can be determined using the auxiliary functions gsl_rng_max (r) and gsl_rng_min (r).",82,[[["self"]],["usize"]]],[11,"uniform","","This function returns a double precision floating point number uniformly distributed in the range [0,1). The range includes 0.0 but excludes 1.0. The value is typically obtained by dividing the result of gsl_rng_get(r) by gsl_rng_max(r) + 1.0 in double precision. Some generators compute this ratio internally so that they can provide floating point numbers with more than 32 bits of randomness (the maximum number of bits that can be portably represented in a single unsigned long int).",82,[[["self"]],["f64"]]],[11,"uniform_pos","","This function returns a positive double precision floating point number uniformly distributed in the range (0,1), excluding both 0.0 and 1.0. The number is obtained by sampling the generator with the algorithm of gsl_rng_uniform until a non-zero value is obtained. You can use this function if you need to avoid a singularity at 0.0.",82,[[["self"]],["f64"]]],[11,"uniform_int","","This function returns a random integer from 0 to n-1 inclusive by scaling down and/or discarding samples from the generator r. All integers in the range [0,n-1] are produced with equal probability. For generators with a non-zero minimum value an offset is applied so that zero is returned with the correct probability.",82,[[["self"],["usize"]],["usize"]]],[11,"get_name","","This function returns a pointer to the name of the generator. For example,",82,[[["self"]],["string"]]],[11,"max","","This function returns the largest value that the get function can return.",82,[[["self"]],["usize"]]],[11,"min","","This function returns the smallest value that gsl_rng_get can return. Usually this value is zero. There are some generators with algorithms that cannot return zero, and for these generators the minimum value is 1.",82,[[["self"]],["usize"]]],[11,"state","","This function returns a pointer to the state of generator r. You can use this information to access the state directly. For example, the following code will write the state of a generator to a stream,",82,[[["self"]],["t"]]],[11,"copy","","This function copies the random number generator src into the pre-existing generator dest, making dest into an exact copy of src. The two generators must be of the same type.",82,[[["self"],["rng"]],["value"]]],[11,"size","","This function returns the size of the state of generator r. You can use this information to access the state directly. For example, the following code will write the state of a generator to a stream,",82,[[["self"]],["usize"]]],[11,"default_seed","","Equivalent to DefaultRngSeed",82,[[],["usize"]]],[11,"name","","wrapper for name element",83,[[["self"]],["string"]]],[11,"max","","wrapper for max element",83,[[["self"]],["usize"]]],[11,"min","","wrapper for min element",83,[[["self"]],["usize"]]],[11,"size","","wrapper for size element",83,[[["self"]],["usize"]]],[11,"types_setup","","This function returns a pointer to an array of all the available generator types, terminated by a null pointer. The function should be called once at the start of the program, if needed. The following code fragment shows how to iterate over the array of generator types to print the names of the available algorithms,",83,[[],["vec",["rngtype"]]]],[11,"env_setup","","This function reads the environment variables GSL_RNG_TYPE and GSL_RNG_SEED and uses their values to set the corresponding library variables gsl_rng_default and gsl_rng_default_seed. These global variables are defined as follows,",83,[[],["option",["rngtype"]]]],[0,"roots","rgsl::types","One dimensional Root-Finding",N,N],[3,"RootFSolverType","rgsl::types::roots","The root bracketing algorithms described in this section require an initial interval which is guaranteed to contain a rootif a and b are the endpoints of the interval then f (a) must differ in sign from f (b). This ensures that the function crosses zero at least once in the interval. If a valid initial interval is used then these algorithm cannot fail, provided the function is well-behaved.",N,N],[3,"RootFunction","","",N,N],[12,"function","","",0,N],[12,"params","","",0,N],[3,"RootFSolver","","",N,N],[3,"RootFdfSolverType","","The root polishing algorithms described in this section require an initial guess for the location of the root. There is no absolute guarantee of convergencethe function must be suitable for this technique and the initial guess must be sufficiently close to the root for it to work. When these conditions are satisfied then convergence is quadratic.",N,N],[3,"RootFunctionFdf","","",N,N],[12,"f","","",1,N],[12,"df","","",1,N],[12,"fdf","","",1,N],[12,"params","","",1,N],[3,"RootFdfSolver","","",N,N],[11,"bisection","","The bisection algorithm is the simplest method of bracketing the roots of a function. It is the slowest algorithm provided by the library, with linear convergence. On each iteration, the interval is bisected and the value of the function at the midpoint is calculated. The sign of this value is used to determine which half of the interval does not contain a root. That half is discarded to give a new, smaller interval containing the root. This procedure can be continued indefinitely until the interval is sufficiently small.",84,[[],["rootfsolvertype"]]],[11,"brent","","The false position algorithm is a method of finding roots based on linear interpolation. Its convergence is linear, but it is usually faster than bisection.",84,[[],["rootfsolvertype"]]],[11,"falsepos","","The Brent-Dekker method (referred to here as Brents method) combines an interpo- lation strategy with the bisection algorithm. This produces a fast algorithm which is still robust. On each iteration Brents method approximates the function using an interpolating curve. On the first iteration this is a linear interpolation of the two endpoints. For subsequent iterations the algorithm uses an inverse quadratic fit to the last three points, for higher accuracy. The intercept of the interpolating curve with the x-axis is taken as a guess for the root. If it lies within the bounds of the current interval then the interpolating point is accepted, and used to generate a smaller interval. If the interpolating point is not accepted then the algorithm falls back to an ordinary bisection step.",84,[[],["rootfsolvertype"]]],[11,"new","","This function returns a pointer to a newly allocated instance of a solver of type T.",85,[[["rootfsolvertype"]],["option",["rootfsolver"]]]],[11,"set","","This function initializes, or reinitializes, an existing solver s to use the function f and the initial search interval [x lower, x upper].",85,[[["self"],["rootfunction"],["f64"],["f64"]],["value"]]],[11,"iterate","","The following function drives the iteration of each algorithm. Each function performs one iteration to update the state of any solver of the corresponding type. The same func- tion works for all solvers so that different methods can be substituted at runtime without modifications to the code.",85,[[["self"]],["value"]]],[11,"name","","Returns the solver type name.",85,[[["self"]],["string"]]],[11,"root","","This function returns the current estimate of the root for the solver s.",85,[[["self"]],["f64"]]],[11,"x_lower","","These functions return the current bracketing interval for the solver s.",85,[[["self"]],["f64"]]],[11,"x_upper","","These functions return the current bracketing interval for the solver s.",85,[[["self"]],["f64"]]],[11,"newton","","Newtons Method is the standard root-polishing algorithm. The algorithm begins with an initial guess for the location of the root. On each iteration, a line tangent to the function f is drawn at that position. The point where this line crosses the x-axis becomes the new guess.",86,[[],["rootfdfsolvertype"]]],[11,"secant","","The secant method is a simplified version of Newtons method which does not require the computation of the derivative on every step.",86,[[],["rootfdfsolvertype"]]],[11,"steffenson","","The Steffenson Method 1 provides the fastest convergence of all the routines. It com- bines the basic Newton algorithm with an Aitken delta-squared acceleration.",86,[[],["rootfdfsolvertype"]]],[11,"new","","This function returns a pointer to a newly allocated instance of a derivative-based solver of type T.",87,[[["rootfdfsolvertype"]],["option",["rootfdfsolver"]]]],[11,"set","","This function initializes, or reinitializes, an existing solver s to use the function and derivative fdf and the initial guess root.",87,[[["self"],["rootfunctionfdf"],["f64"]],["value"]]],[11,"iterate","","The following function drives the iteration of each algorithm. Each function performs one iteration to update the state of any solver of the corresponding type. The same func- tion works for all solvers so that different methods can be substituted at runtime without modifications to the code.",87,[[["self"]],["value"]]],[11,"name","","Returns the solver type name.",87,[[["self"]],["string"]]],[11,"root","","This function returns the current estimate of the root for the solver s.",87,[[["self"]],["f64"]]],[0,"series_acceleration","rgsl::types","#Series Acceleration",N,N],[3,"LevinUWorkspace","rgsl::types::series_acceleration","Workspace for Levin U Transform with error estimation",N,N],[3,"LevinUTruncWorkspace","","The following functions perform the same calculation without estimating the errors. They require O(N) storage instead of O(N^2). This may be useful for summing many similar series where the size of the error has already been estimated reliably and is not expected to change.",N,N],[11,"new","","This function allocates a workspace for a Levin u-transform of n terms. The size of the workspace is O(2n^2 + 3n).",88,[[["usize"]],["option",["levinuworkspace"]]]],[11,"accel","","This function takes the terms of a series in array of size array_size and computes the extrapolated limit of the series using a Levin u-transform. Additional working space must be provided in w. The extrapolated sum is stored in sum_accel, with an estimate of the absolute error stored in abserr. The actual term-by-term sum is returned in w->sum_plain. The algorithm calculates the truncation error (the difference between two successive extrapolations) and round-off error (propagated from the individual terms) to choose an optimal number of terms for the extrapolation. All the terms of the series passed in through array should be non-zero.",88,N],[11,"sum_plain","","",88,[[["self"]],["f64"]]],[11,"terms_used","","",88,[[["self"]],["usize"]]],[11,"size","","",88,[[["self"]],["usize"]]],[11,"new","","This function allocates a workspace for a Levin u-transform of n terms, without error estimation. The size of the workspace is O(3n).",89,[[["usize"]],["option",["levinutruncworkspace"]]]],[11,"accel","","This function takes the terms of a series in array of size array_size and computes the extrapolated limit of the series using a Levin u-transform. Additional working space must be provided in w. The extrapolated sum is stored in sum_accel. The actual term-by-term sum is returned in w->sum_plain. The algorithm terminates when the difference between two successive extrapolations reaches a minimum or is sufficiently small. The difference between these two values is used as estimate of the error and is stored in abserr_trunc. To improve the reliability of the algorithm the extrapolated values are replaced by moving averages when calculating the truncation error, smoothing out any fluctuations.",89,N],[11,"sum_plain","","",89,[[["self"]],["f64"]]],[11,"terms_used","","",89,[[["self"]],["usize"]]],[11,"size","","",89,[[["self"]],["usize"]]],[0,"siman","rgsl::types","25 Simulated Annealing",N,N],[3,"SimAnnealing","rgsl::types::siman","",N,N],[3,"SimAnnealingParams","","",N,N],[11,"new","","",90,N],[11,"solve","","This function performs a simulated annealing search through a given space. The space is specified by providing the functions Ef and distance. The simulated annealing steps are generated using the random number generator `rng` and the function `take_step`.",90,[[["self"],["rng"]],["t"]]],[11,"solve_many","","Like the function solve, but performs multiple runs and returns the best result.",90,[[["self"],["rng"]],["t"]]],[11,"new","","These are the parameters that control a run of the simulated annealing algorithm. This structure contains all the information needed to control the search, beyond the energy function, the step function and the initial guess.",91,[[["usize"],["usize"],["f64"],["f64"],["f64"],["f64"],["f64"]],["simannealingparams"]]],[0,"vector","rgsl::types","#Vectors",N,N],[3,"VectorView","rgsl::types::vector","",N,N],[3,"VectorF32","","",N,N],[3,"VectorF64","","",N,N],[11,"from_vector","","These functions return a vector view of a subvector of another vector v. The start of the new vector is offset by offset elements from the start of the original vector. The new vector has n elements. Mathematically, the i-th element of the new vector v is given by,",92,[[["vectorf64"],["usize"],["usize"]],["vectorview"]]],[11,"from_vector_with_stride","","These functions return a vector view of a subvector of another vector v with an additional stride argument. The subvector is formed in the same way as for gsl_vector_subvector but the new vector has n elements with a step-size of stride from one element to the next in the original vector. Mathematically, the i-th element of the new vector v is given by,",92,[[["vectorf64"],["usize"],["usize"],["usize"]],["vectorview"]]],[11,"from_array","","These functions return a vector view of an array. The start of the new vector is given by base and has n elements. Mathematically, the i-th element of the new vector v is given by,",92,N],[11,"from_array_with_stride","","These functions return a vector view of an array base with an additional stride argument. The subvector is formed in the same way as for gsl_vector_view_array but the new vector has n elements with a step-size of stride from one element to the next in the original array. Mathematically, the i-th element of the new vector v is given by,",92,N],[11,"vector","","",92,[[["self"]],["vectorf64"]]],[11,"new","","create a new VectorF32 with all elements set to zero",93,[[["usize"]],["option",["vectorf32"]]]],[11,"from_slice","","",93,N],[11,"len","","",93,[[["self"]],["usize"]]],[11,"get","","This function returns the i-th element of a vector v. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.",93,[[["self"],["usize"]],["f32"]]],[11,"set","","This function sets the value of the i-th element of a vector v to x. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked.",93,[[["self"],["usize"],["f32"]],["vectorf32"]]],[11,"set_all","","This function sets all the elements of the vector v to the value x.",93,[[["self"],["f32"]],["vectorf32"]]],[11,"set_zero","","This function sets all the elements of the vector v to zero.",93,[[["self"]],["vectorf32"]]],[11,"set_basis","","This function makes a basis vector by setting all the elements of the vector v to zero except for the i-th element which is set to one.",93,[[["self"],["usize"]],["vectorf32"]]],[11,"copy_from","","This function copies the elements of the other vector into the self vector. The two vectors must have the same length.",93,[[["self"],["vectorf32"]],["value"]]],[11,"copy_to","","This function copies the elements of the self vector into the other vector. The two vectors must have the same length.",93,[[["self"],["vectorf32"]],["value"]]],[11,"swap","","This function exchanges the elements of the vectors by copying. The two vectors must have the same length.",93,[[["self"],["vectorf32"]],["value"]]],[11,"swap_elements","","This function exchanges the i-th and j-th elements of the vector v in-place.",93,[[["self"],["usize"],["usize"]],["value"]]],[11,"reverse","","This function reverses the order of the elements of the vector v.",93,[[["self"]],["value"]]],[11,"add","","This function adds the elements of the other vector to the elements of the self vector. The result a_i <- a_i + b_i is stored in self and other remains unchanged. The two vectors must have the same length.",93,[[["self"],["vectorf32"]],["value"]]],[11,"sub","","This function subtracts the elements of the self vector from the elements of the other vector. The result a_i <- a_i - b_i is stored in self and other remains unchanged. The two vectors must have the same length.",93,[[["self"],["vectorf32"]],["value"]]],[11,"mul","","This function multiplies the elements of the self vector a by the elements of the other vector. The result a_i <- a_i * b_i is stored in self and other remains unchanged. The two vectors must have the same length.",93,[[["self"],["vectorf32"]],["value"]]],[11,"div","","This function divides the elements of the self vector by the elements of the other vector. The result a_i <- a_i / b_i is stored in self and other remains unchanged. The two vectors must have the same length.",93,[[["self"],["vectorf32"]],["value"]]],[11,"scale","","This function multiplies the elements of the self vector by the constant factor x. The result a_i <- a_i is stored in self.",93,[[["self"],["f32"]],["value"]]],[11,"add_constant","","This function adds the constant value x to the elements of the self vector. The result a_i <- a_i + x is stored in self.",93,[[["self"],["f32"]],["value"]]],[11,"max","","This function returns the maximum value in the self vector.",93,[[["self"]],["f32"]]],[11,"min","","This function returns the minimum value in the self vector.",93,[[["self"]],["f32"]]],[11,"minmax","","This function returns the minimum and maximum values in the self vector, storing them in min_out and max_out.",93,N],[11,"max_index","","This function returns the index of the maximum value in the self vector. When there are several equal maximum elements then the lowest index is returned.",93,[[["self"]],["usize"]]],[11,"min_index","","This function returns the index of the minimum value in the self vector. When there are several equal minimum elements then the lowest index is returned.",93,[[["self"]],["usize"]]],[11,"minmax_index","","This function returns the indices of the minimum and maximum values in the self vector, storing them in imin and imax. When there are several equal minimum or maximum elements then the lowest indices are returned.",93,N],[11,"is_null","","This function returns true if all the elements of the self vector are equal to 0.",93,[[["self"]],["bool"]]],[11,"is_pos","","This function returns true if all the elements of the self vector are stricly positive.",93,[[["self"]],["bool"]]],[11,"is_neg","","This function returns true if all the elements of the self vector are stricly negative.",93,[[["self"]],["bool"]]],[11,"is_non_neg","","This function returns true if all the elements of the self vector are stricly non-negative.",93,[[["self"]],["bool"]]],[11,"equal","","",93,[[["self"],["vectorf32"]],["bool"]]],[11,"clone","","",93,[[["self"]],["option",["vectorf32"]]]],[11,"new","","create a new VectorF64 with all elements set to zero",94,[[["usize"]],["option",["vectorf64"]]]],[11,"from_slice","","",94,N],[11,"len","","",94,[[["self"]],["usize"]]],[11,"get","","This function returns the i-th element of a vector v. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.",94,[[["self"],["usize"]],["f64"]]],[11,"set","","This function sets the value of the i-th element of a vector v to x. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked.",94,[[["self"],["usize"],["f64"]],["vectorf64"]]],[11,"set_all","","This function sets all the elements of the vector v to the value x.",94,[[["self"],["f64"]],["vectorf64"]]],[11,"set_zero","","This function sets all the elements of the vector v to zero.",94,[[["self"]],["vectorf64"]]],[11,"set_basis","","This function makes a basis vector by setting all the elements of the vector v to zero except for the i-th element which is set to one.",94,[[["self"],["usize"]],["vectorf64"]]],[11,"copy_from","","This function copies the elements of the other vector into the self vector. The two vectors must have the same length.",94,[[["self"],["vectorf64"]],["value"]]],[11,"copy_to","","This function copies the elements of the self vector into the other vector. The two vectors must have the same length.",94,[[["self"],["vectorf64"]],["value"]]],[11,"swap","","This function exchanges the elements of the vectors by copying. The two vectors must have the same length.",94,[[["self"],["vectorf64"]],["value"]]],[11,"swap_elements","","This function exchanges the i-th and j-th elements of the vector v in-place.",94,[[["self"],["usize"],["usize"]],["value"]]],[11,"reverse","","This function reverses the order of the elements of the vector v.",94,[[["self"]],["value"]]],[11,"add","","This function adds the elements of the other vector to the elements of the self vector. The result a_i <- a_i + b_i is stored in self and other remains unchanged. The two vectors must have the same length.",94,[[["self"],["vectorf64"]],["value"]]],[11,"sub","","This function subtracts the elements of the self vector from the elements of the other vector. The result a_i <- a_i - b_i is stored in self and other remains unchanged. The two vectors must have the same length.",94,[[["self"],["vectorf64"]],["value"]]],[11,"mul","","This function multiplies the elements of the self vector a by the elements of the other vector. The result a_i <- a_i * b_i is stored in self and other remains unchanged. The two vectors must have the same length.",94,[[["self"],["vectorf64"]],["value"]]],[11,"div","","This function divides the elements of the self vector by the elements of the other vector. The result a_i <- a_i / b_i is stored in self and other remains unchanged. The two vectors must have the same length.",94,[[["self"],["vectorf64"]],["value"]]],[11,"scale","","This function multiplies the elements of the self vector by the constant factor x. The result a_i <- a_i is stored in self.",94,[[["self"],["f64"]],["value"]]],[11,"add_constant","","This function adds the constant value x to the elements of the self vector. The result a_i <- a_i + x is stored in self.",94,[[["self"],["f64"]],["value"]]],[11,"max","","This function returns the maximum value in the self vector.",94,[[["self"]],["f64"]]],[11,"min","","This function returns the minimum value in the self vector.",94,[[["self"]],["f64"]]],[11,"minmax","","This function returns the minimum and maximum values in the self vector, storing them in min_out and max_out.",94,N],[11,"max_index","","This function returns the index of the maximum value in the self vector. When there are several equal maximum elements then the lowest index is returned.",94,[[["self"]],["usize"]]],[11,"min_index","","This function returns the index of the minimum value in the self vector. When there are several equal minimum elements then the lowest index is returned.",94,[[["self"]],["usize"]]],[11,"minmax_index","","This function returns the indices of the minimum and maximum values in the self vector, storing them in imin and imax. When there are several equal minimum or maximum elements then the lowest indices are returned.",94,N],[11,"is_null","","This function returns true if all the elements of the self vector are equal to 0.",94,[[["self"]],["bool"]]],[11,"is_pos","","This function returns true if all the elements of the self vector are stricly positive.",94,[[["self"]],["bool"]]],[11,"is_neg","","This function returns true if all the elements of the self vector are stricly negative.",94,[[["self"]],["bool"]]],[11,"is_non_neg","","This function returns true if all the elements of the self vector are stricly non-negative.",94,[[["self"]],["bool"]]],[11,"equal","","",94,[[["self"],["vectorf64"]],["bool"]]],[11,"clone","","",94,[[["self"]],["option",["vectorf64"]]]],[0,"vector_complex","rgsl::types","",N,N],[3,"VectorComplexF64","rgsl::types::vector_complex","",N,N],[3,"VectorComplexF32","","",N,N],[11,"new","","create a new VectorComplexF64 with all elements set to zero",95,[[["usize"]],["option",["vectorcomplexf64"]]]],[11,"from_slice","","",95,N],[11,"len","","",95,[[["self"]],["usize"]]],[11,"get","","This function returns the i-th element of a vector v. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.",95,[[["self"],["usize"]],["complexf64"]]],[11,"set","","This function sets the value of the i-th element of a vector v to x. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked.",95,[[["self"],["usize"],["complexf64"]],["vectorcomplexf64"]]],[11,"set_all","","This function sets all the elements of the vector v to the value x.",95,[[["self"],["complexf64"]],["vectorcomplexf64"]]],[11,"set_zero","","This function sets all the elements of the vector v to zero.",95,[[["self"]],["vectorcomplexf64"]]],[11,"set_basis","","This function makes a basis vector by setting all the elements of the vector v to zero except for the i-th element which is set to one.",95,[[["self"],["usize"]],["vectorcomplexf64"]]],[11,"copy_from","","This function copies the elements of the other vector into the self vector. The two vectors must have the same length.",95,[[["self"],["vectorcomplexf64"]],["value"]]],[11,"copy_to","","This function copies the elements of the self vector into the other vector. The two vectors must have the same length.",95,[[["self"],["vectorcomplexf64"]],["value"]]],[11,"swap","","This function exchanges the elements of the vectors by copying. The two vectors must have the same length.",95,[[["self"],["vectorcomplexf64"]],["value"]]],[11,"swap_elements","","This function exchanges the i-th and j-th elements of the vector v in-place.",95,[[["self"],["usize"],["usize"]],["value"]]],[11,"reverse","","This function reverses the order of the elements of the vector v.",95,[[["self"]],["value"]]],[11,"add","","This function adds the elements of the other vector to the elements of the self vector. The result a_i <- a_i + b_i is stored in self and other remains unchanged. The two vectors must have the same length.",95,[[["self"],["vectorcomplexf64"]],["value"]]],[11,"sub","","This function subtracts the elements of the self vector from the elements of the other vector. The result a_i <- a_i - b_i is stored in self and other remains unchanged. The two vectors must have the same length.",95,[[["self"],["vectorcomplexf64"]],["value"]]],[11,"mul","","This function multiplies the elements of the self vector a by the elements of the other vector. The result a_i <- a_i * b_i is stored in self and other remains unchanged. The two vectors must have the same length.",95,[[["self"],["vectorcomplexf64"]],["value"]]],[11,"div","","This function divides the elements of the self vector by the elements of the other vector. The result a_i <- a_i / b_i is stored in self and other remains unchanged. The two vectors must have the same length.",95,[[["self"],["vectorcomplexf64"]],["value"]]],[11,"scale","","This function multiplies the elements of the self vector by the constant factor x. The result a_i <- a_i is stored in self.",95,[[["self"],["complexf64"]],["value"]]],[11,"add_constant","","This function adds the constant value x to the elements of the self vector. The result a_i <- a_i + x is stored in self.",95,[[["self"],["complexf64"]],["value"]]],[11,"is_null","","This function returns true if all the elements of the self vector are equal to 0.",95,[[["self"]],["bool"]]],[11,"is_pos","","This function returns true if all the elements of the self vector are stricly positive.",95,[[["self"]],["bool"]]],[11,"is_neg","","This function returns true if all the elements of the self vector are stricly negative.",95,[[["self"]],["bool"]]],[11,"is_non_neg","","This function returns true if all the elements of the self vector are stricly non-negative.",95,[[["self"]],["bool"]]],[11,"equal","","",95,[[["self"],["vectorcomplexf64"]],["bool"]]],[11,"clone","","",95,[[["self"]],["option",["vectorcomplexf64"]]]],[11,"new","","create a new VectorComplexF32 with all elements set to zero",96,[[["usize"]],["option",["vectorcomplexf32"]]]],[11,"from_slice","","",96,N],[11,"len","","",96,[[["self"]],["usize"]]],[11,"get","","This function returns the i-th element of a vector v. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.",96,[[["self"],["usize"]],["complexf32"]]],[11,"set","","This function sets the value of the i-th element of a vector v to x. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked.",96,[[["self"],["usize"],["complexf32"]],["vectorcomplexf32"]]],[11,"set_all","","This function sets all the elements of the vector v to the value x.",96,[[["self"],["complexf32"]],["vectorcomplexf32"]]],[11,"set_zero","","This function sets all the elements of the vector v to zero.",96,[[["self"]],["vectorcomplexf32"]]],[11,"set_basis","","This function makes a basis vector by setting all the elements of the vector v to zero except for the i-th element which is set to one.",96,[[["self"],["usize"]],["vectorcomplexf32"]]],[11,"copy_from","","This function copies the elements of the other vector into the self vector. The two vectors must have the same length.",96,[[["self"],["vectorcomplexf32"]],["value"]]],[11,"copy_to","","This function copies the elements of the self vector into the other vector. The two vectors must have the same length.",96,[[["self"],["vectorcomplexf32"]],["value"]]],[11,"swap","","This function exchanges the elements of the vectors by copying. The two vectors must have the same length.",96,[[["self"],["vectorcomplexf32"]],["value"]]],[11,"swap_elements","","This function exchanges the i-th and j-th elements of the vector v in-place.",96,[[["self"],["usize"],["usize"]],["value"]]],[11,"reverse","","This function reverses the order of the elements of the vector v.",96,[[["self"]],["value"]]],[11,"add","","This function adds the elements of the other vector to the elements of the self vector. The result a_i <- a_i + b_i is stored in self and other remains unchanged. The two vectors must have the same length.",96,[[["self"],["vectorcomplexf32"]],["value"]]],[11,"sub","","This function subtracts the elements of the self vector from the elements of the other vector. The result a_i <- a_i - b_i is stored in self and other remains unchanged. The two vectors must have the same length.",96,[[["self"],["vectorcomplexf32"]],["value"]]],[11,"mul","","This function multiplies the elements of the self vector a by the elements of the other vector. The result a_i <- a_i * b_i is stored in self and other remains unchanged. The two vectors must have the same length.",96,[[["self"],["vectorcomplexf32"]],["value"]]],[11,"div","","This function divides the elements of the self vector by the elements of the other vector. The result a_i <- a_i / b_i is stored in self and other remains unchanged. The two vectors must have the same length.",96,[[["self"],["vectorcomplexf32"]],["value"]]],[11,"scale","","This function multiplies the elements of the self vector by the constant factor x. The result a_i <- a_i is stored in self.",96,[[["self"],["complexf32"]],["value"]]],[11,"add_constant","","This function adds the constant value x to the elements of the self vector. The result a_i <- a_i + x is stored in self.",96,[[["self"],["complexf32"]],["value"]]],[11,"is_null","","This function returns true if all the elements of the self vector are equal to 0.",96,[[["self"]],["bool"]]],[11,"is_pos","","This function returns true if all the elements of the self vector are stricly positive.",96,[[["self"]],["bool"]]],[11,"is_neg","","This function returns true if all the elements of the self vector are stricly negative.",96,[[["self"]],["bool"]]],[11,"is_non_neg","","This function returns true if all the elements of the self vector are stricly non-negative.",96,[[["self"]],["bool"]]],[11,"equal","","",96,[[["self"],["vectorcomplexf32"]],["bool"]]],[11,"clone","","",96,[[["self"]],["option",["vectorcomplexf32"]]]],[0,"wavelet_transforms","rgsl::types","#Wavelet Transforms",N,N],[3,"Wavelet","rgsl::types::wavelet_transforms","The Wavelet structure contains the filter coefficients defining the wavelet and any associated offset parameters.",N,N],[3,"WaveletType","","The centered forms of the wavelets align the coefficients of the various sub-bands on edges. Thus the resulting visualization of the coefficients of the wavelet transform in the phase plane is easier to understand.",N,N],[3,"WaveletWorkspace","","The WaveletWorkspace structure contains scratch space of the same size as the input data and is used to hold intermediate results during the transform.",N,N],[11,"new","","This function allocates and initializes a wavelet object of type T. The parameter k selects the specific member of the wavelet family. A null pointer is returned if insufficient memory is available or if a unsupported member is selected.",97,[[["wavelettype"],["usize"]],["option",["wavelet"]]]],[11,"name","","This function returns a pointer to the name of the wavelet family for w.",97,[[["self"]],["option",["string"]]]],[11,"daubechies","","This is the Daubechies wavelet family of maximum phase with k/2 vanishing moments. The implemented wavelets are k=4, 6, , 20, with k even.",98,[[],["wavelettype"]]],[11,"daubechies_centered","","This is the Daubechies wavelet family of maximum phase with k/2 vanishing moments. The implemented wavelets are k=4, 6, , 20, with k even.",98,[[],["wavelettype"]]],[11,"haar","","This is the Haar wavelet. The only valid choice of k for the Haar wavelet is k=2.",98,[[],["wavelettype"]]],[11,"haar_centered","","This is the Haar wavelet. The only valid choice of k for the Haar wavelet is k=2.",98,[[],["wavelettype"]]],[11,"bspline","","This is the biorthogonal B-spline wavelet family of order (i,j). The implemented values of k = 100*i + j are 103, 105, 202, 204, 206, 208, 301, 303, 305 307, 309.",98,[[],["wavelettype"]]],[11,"bspline_centered","","This is the biorthogonal B-spline wavelet family of order (i,j). The implemented values of k = 100*i + j are 103, 105, 202, 204, 206, 208, 301, 303, 305 307, 309.",98,[[],["wavelettype"]]],[11,"new","","This function allocates a workspace for the discrete wavelet transform. To perform a one-dimensional transform on n elements, a workspace of size n must be provided. For two-dimensional transforms of n-by-n matrices it is sufficient to allocate a workspace of size n, since the transform operates on individual rows and columns. A null pointer is returned if insufficient memory is available.",99,[[["usize"]],["option",["waveletworkspace"]]]],[0,"airy","rgsl","",N,N],[5,"Ai","rgsl::airy","This routine computes the Airy function Ai(x) with an accuracy specified by mode.",N,[[["f64"],["mode"]],["f64"]]],[5,"Ai_e","","This routine computes the Airy function Ai(x) with an accuracy specified by mode.",N,N],[5,"Bi","","This routine computes the Airy function Bi(x) with an accuracy specified by mode.",N,[[["f64"],["mode"]],["f64"]]],[5,"Bi_e","","This routine computes the Airy function Bi(x) with an accuracy specified by mode.",N,N],[5,"Ai_scaled","","This routine computes a scaled version of the Airy function S_A(x) Ai(x). For x>0 the scaling factor S_A(x) is \\exp(+(2/3) x^(3/2)), and is 1 for x<0.",N,[[["f64"],["mode"]],["f64"]]],[5,"Ai_scaled_e","","This routine computes a scaled version of the Airy function S_A(x) Ai(x). For x>0 the scaling factor S_A(x) is \\exp(+(2/3) x^(3/2)), and is 1 for x<0.",N,N],[5,"Bi_scaled","","This routine computes a scaled version of the Airy function S_B(x) Bi(x). For x>0 the scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x<0.",N,[[["f64"],["mode"]],["f64"]]],[5,"Bi_scaled_e","","This routine computes a scaled version of the Airy function S_B(x) Bi(x). For x>0 the scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x<0.",N,N],[5,"Ai_deriv","","This routine computes the Airy function derivative Ai'(x) with an accuracy specified by mode.",N,[[["f64"],["mode"]],["f64"]]],[5,"Ai_deriv_e","","This routine computes the Airy function derivative Ai'(x) with an accuracy specified by mode.",N,N],[5,"Bi_deriv","","This routine computes the Airy function derivative Bi'(x) with an accuracy specified by mode.",N,[[["f64"],["mode"]],["f64"]]],[5,"Bi_deriv_e","","This routine computes the Airy function derivative Bi'(x) with an accuracy specified by mode.",N,N],[5,"Ai_deriv_scaled","","This routine computes the scaled Airy function derivative S_A(x) Ai'(x). For x>0 the scaling factor S_A(x) is \\exp(+(2/3) x^(3/2)), and is 1 for x<0.",N,[[["f64"],["mode"]],["f64"]]],[5,"Ai_deriv_scaled_e","","This routine computes the scaled Airy function derivative S_A(x) Ai'(x). For x>0 the scaling factor S_A(x) is \\exp(+(2/3) x^(3/2)), and is 1 for x<0.",N,N],[5,"Bi_deriv_scaled","","This routine computes the scaled Airy function derivative S_B(x) Bi'(x). For x>0 the scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x<0.",N,[[["f64"],["mode"]],["f64"]]],[5,"Bi_deriv_scaled_e","","This routine computes the scaled Airy function derivative S_B(x) Bi'(x). For x>0 the scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x<0.",N,N],[5,"zero_Ai","","This routine computes the location of the s-th zero of the Airy function Ai(x).",N,[[["u32"]],["f64"]]],[5,"zero_Ai_e","","This routine computes the location of the s-th zero of the Airy function Ai(x).",N,N],[5,"zero_Bi","","This routine computes the location of the s-th zero of the Airy function Bi(x).",N,[[["u32"]],["f64"]]],[5,"zero_Bi_e","","This routine computes the location of the s-th zero of the Airy function Bi(x).",N,N],[5,"zero_Ai_deriv","","This routine computes the location of the s-th zero of the Airy function derivative Ai'(x).",N,[[["u32"]],["f64"]]],[5,"zero_Ai_deriv_e","","This routine computes the location of the s-th zero of the Airy function derivative Ai'(x).",N,N],[5,"zero_Bi_deriv","","This routine computes the location of the s-th zero of the Airy function derivative Bi'(x).",N,[[["u32"]],["f64"]]],[5,"zero_Bi_deriv_e","","This routine computes the location of the s-th zero of the Airy function derivative Bi'(x).",N,N],[0,"bessel","rgsl","",N,N],[5,"I0","rgsl::bessel","This routine computes the regular modified cylindrical Bessel function of zeroth order, I_0(x)",N,[[["f64"]],["f64"]]],[5,"I0_e","","This routine computes the regular modified cylindrical Bessel function of zeroth order, I_0(x)",N,N],[5,"I1","","This routine computes the regular modified cylindrical Bessel function of first order, I_1(x).",N,[[["f64"]],["f64"]]],[5,"I1_e","","This routine computes the regular modified cylindrical Bessel function of first order, I_1(x).",N,N],[5,"In","","This routine computes the regular modified cylindrical Bessel function of order n, I_n(x).",N,[[["i32"],["f64"]],["f64"]]],[5,"In_e","","This routine computes the regular modified cylindrical Bessel function of order n, I_n(x).",N,N],[5,"In_array","","This routine computes the values of the regular modified cylindrical Bessel functions I_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array. The start of the range nmin must be positive or zero. The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",N,N],[5,"I0_scaled","","This routine computes the scaled regular modified cylindrical Bessel function of zeroth order \\exp(-|x|) I_0(x).",N,[[["f64"]],["f64"]]],[5,"I0_scaled_e","","This routine computes the scaled regular modified cylindrical Bessel function of zeroth order \\exp(-|x|) I_0(x).",N,N],[5,"I1_scaled","","This routine computes the scaled regular modified cylindrical Bessel function of first order \\exp(-|x|) I_1(x).",N,[[["f64"]],["f64"]]],[5,"I1_scaled_e","","This routine computes the scaled regular modified cylindrical Bessel function of first order \\exp(-|x|) I_1(x).",N,N],[5,"In_scaled","","This routine computes the scaled regular modified cylindrical Bessel function of order n, \\exp(-|x|) I_n(x)",N,[[["i32"],["f64"]],["f64"]]],[5,"In_scaled_e","","This routine computes the scaled regular modified cylindrical Bessel function of order n, \\exp(-|x|) I_n(x)",N,N],[5,"In_scaled_array","","This routine computes the values of the scaled regular cylindrical Bessel functions \\exp(-|x|) I_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array. The start of the range nmin must be positive or zero. The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",N,N],[5,"i0_scaled","","This routine computes the scaled regular modified spherical Bessel function of zeroth order, \\exp(-|x|) i_0(x).",N,[[["f64"]],["f64"]]],[5,"i0_scaled_e","","This routine computes the scaled regular modified spherical Bessel function of zeroth order, \\exp(-|x|) i_0(x).",N,N],[5,"i1_scaled","","This routine computes the scaled regular modified spherical Bessel function of first order, \\exp(-|x|) i_1(x).",N,[[["f64"]],["f64"]]],[5,"i1_scaled_e","","This routine computes the scaled regular modified spherical Bessel function of first order, \\exp(-|x|) i_1(x).",N,N],[5,"i2_scaled","","This routine computes the scaled regular modified spherical Bessel function of second order, \\exp(-|x|) i_2(x)",N,[[["f64"]],["f64"]]],[5,"i2_scaled_e","","This routine computes the scaled regular modified spherical Bessel function of second order, \\exp(-|x|) i_2(x)",N,N],[5,"il_scaled","","This routine computes the scaled regular modified spherical Bessel function of order l, \\exp(-|x|) i_l(x)",N,[[["i32"],["f64"]],["f64"]]],[5,"il_scaled_e","","This routine computes the scaled regular modified spherical Bessel function of order l, \\exp(-|x|) i_l(x)",N,N],[5,"il_scaled_array","","This routine computes the values of the scaled regular modified cylindrical Bessel functions \\exp(-|x|) i_l(x) for l from 0 to lmax inclusive for lmax >= 0, storing the results in the array result_array. The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",N,N],[5,"Inu","","This routine computes the regular modified Bessel function of fractional order \\nu, I_\\nu(x) for x>0, \\nu>0.",N,[[["f64"],["f64"]],["f64"]]],[5,"Inu_e","","This routine computes the regular modified Bessel function of fractional order \\nu, I_\\nu(x) for x>0, \\nu>0.",N,N],[5,"Inu_scaled","","This routine computes the scaled regular modified Bessel function of fractional order \\nu, \\exp(-|x|)I_\\nu(x) for x>0, \\nu>0.",N,[[["f64"],["f64"]],["f64"]]],[5,"Inu_scaled_e","","This routine computes the scaled regular modified Bessel function of fractional order \\nu, \\exp(-|x|)I_\\nu(x) for x>0, \\nu>0.",N,N],[5,"J0","","This routine computes the regular cylindrical Bessel function of zeroth order, J_0(x).",N,[[["f64"]],["f64"]]],[5,"J0_e","","This routine computes the regular cylindrical Bessel function of zeroth order, J_0(x).",N,N],[5,"J1","","This routine computes the regular cylindrical Bessel function of first order, J_1(x).",N,[[["f64"]],["f64"]]],[5,"J1_e","","This routine computes the regular cylindrical Bessel function of first order, J_1(x).",N,N],[5,"Jn","","This routine computes the regular cylindrical Bessel function of order n, J_n(x).",N,[[["i32"],["f64"]],["f64"]]],[5,"Jn_e","","This routine computes the regular cylindrical Bessel function of order n, J_n(x).",N,N],[5,"Jn_array","","This routine computes the values of the regular cylindrical Bessel functions J_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array. The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",N,N],[5,"j0","","This routine computes the regular spherical Bessel function of zeroth order, j_0(x) = \\sin(x)/x.",N,[[["f64"]],["f64"]]],[5,"j0_e","","This routine computes the regular spherical Bessel function of zeroth order, j_0(x) = \\sin(x)/x.",N,N],[5,"j1","","This routine computes the regular spherical Bessel function of first order, j_1(x) = (\\sin(x)/x - \\cos(x))/x.",N,[[["f64"]],["f64"]]],[5,"j1_e","","This routine computes the regular spherical Bessel function of first order, j_1(x) = (\\sin(x)/x - \\cos(x))/x.",N,N],[5,"j2","","This routine computes the regular spherical Bessel function of second order, j_2(x) = ((3/x^2 - 1)\\sin(x) - 3\\cos(x)/x)/x.",N,[[["f64"]],["f64"]]],[5,"j2_e","","This routine computes the regular spherical Bessel function of second order, j_2(x) = ((3/x^2 - 1)\\sin(x) - 3\\cos(x)/x)/x.",N,N],[5,"jl","","This routine computes the regular spherical Bessel function of order l, j_l(x), for l >= 0 and x >= 0.",N,[[["i32"],["f64"]],["f64"]]],[5,"jl_e","","This routine computes the regular spherical Bessel function of order l, j_l(x), for l >= 0 and x >= 0.",N,N],[5,"jl_array","","This routine computes the values of the regular spherical Bessel functions j_l(x) for l from 0 to lmax inclusive for lmax >= 0 and x >= 0, storing the results in the array result_array. The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",N,N],[5,"jl_steed_array","","This routine uses Steeds method to compute the values of the regular spherical Bessel functions j_l(x) for l from 0 to lmax inclusive for lmax >= 0 and x >= 0, storing the results in the array result_array. The Steed/Barnett algorithm is described in Comp. Phys. Comm. 21, 297 (1981). Steeds method is more stable than the recurrence used in the other functions but is also slower.",N,N],[5,"Jnu","","This routine computes the regular cylindrical Bessel function of fractional order \\nu, J_\\nu(x).",N,[[["f64"],["f64"]],["f64"]]],[5,"Jnu_e","","This routine computes the regular cylindrical Bessel function of fractional order \\nu, J_\\nu(x).",N,N],[5,"sequence_Jnu","","This function computes the regular cylindrical Bessel function of fractional order \\nu, J_\\nu(x), evaluated at a series of x values. The array v of length size contains the x values. They are assumed to be strictly ordered and positive. The array is over-written with the values of J_\\nu(x_i).",N,N],[5,"K0","","This routine computes the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x > 0.",N,[[["f64"]],["f64"]]],[5,"K0_e","","This routine computes the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x > 0.",N,N],[5,"K1","","This routine computes the irregular modified cylindrical Bessel function of first order, K_1(x), for x > 0.",N,[[["f64"]],["f64"]]],[5,"K1_e","","This routine computes the irregular modified cylindrical Bessel function of first order, K_1(x), for x > 0.",N,N],[5,"Kn","","This routine computes the irregular modified cylindrical Bessel function of order n, K_n(x), for x > 0.",N,[[["i32"],["f64"]],["f64"]]],[5,"Kn_e","","This routine computes the irregular modified cylindrical Bessel function of order n, K_n(x), for x > 0.",N,N],[5,"Kn_array","","This routine computes the values of the irregular modified cylindrical Bessel functions K_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array. The start of the range nmin must be positive or zero. The domain of the function is x>0. The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",N,N],[5,"K0_scaled","","This routine computes the scaled irregular modified cylindrical Bessel function of zeroth order \\exp(x) K_0(x) for x>0.",N,[[["f64"]],["f64"]]],[5,"K0_scaled_e","","This routine computes the scaled irregular modified cylindrical Bessel function of zeroth order \\exp(x) K_0(x) for x>0.",N,N],[5,"K1_scaled","","This routine computes the scaled irregular modified cylindrical Bessel function of first order \\exp(x) K_1(x) for x>0.",N,[[["f64"]],["f64"]]],[5,"K1_scaled_e","","This routine computes the scaled irregular modified cylindrical Bessel function of first order \\exp(x) K_1(x) for x>0.",N,N],[5,"Kn_scaled","","This routine computes the scaled irregular modified cylindrical Bessel function of order n, \\exp(x) K_n(x), for x>0.",N,[[["i32"],["f64"]],["f64"]]],[5,"Kn_scaled_e","","This routine computes the scaled irregular modified cylindrical Bessel function of order n, \\exp(x) K_n(x), for x>0.",N,N],[5,"Kn_scaled_array","","This routine computes the values of the scaled irregular cylindrical Bessel functions \\exp(x) K_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array. The start of the range nmin must be positive or zero. The domain of the function is x>0. The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",N,N],[5,"k0_scaled","","The irregular modified spherical Bessel functions k_l(x) are related to the irregular modified Bessel functions of fractional order, k_l(x) = \\sqrt{\\pi/(2x)} K_{l+1/2}(x). This routine computes the scaled irregular modified spherical Bessel function of zeroth order, \\exp(x) k_0(x), for x>0.",N,[[["f64"]],["f64"]]],[5,"k0_scaled_e","","The irregular modified spherical Bessel functions k_l(x) are related to the irregular modified Bessel functions of fractional order, k_l(x) = \\sqrt{\\pi/(2x)} K_{l+1/2}(x). This routine computes the scaled irregular modified spherical Bessel function of zeroth order, \\exp(x) k_0(x), for x>0.",N,N],[5,"k1_scaled","","This routine computes the scaled irregular modified spherical Bessel function of first order, \\exp(x) k_1(x), for x>0.",N,[[["f64"]],["f64"]]],[5,"k1_scaled_e","","This routine computes the scaled irregular modified spherical Bessel function of first order, \\exp(x) k_1(x), for x>0.",N,N],[5,"k2_scaled","","This routine computes the scaled irregular modified spherical Bessel function of second order, \\exp(x) k_2(x), for x>0.",N,[[["f64"]],["f64"]]],[5,"k2_scaled_e","","This routine computes the scaled irregular modified spherical Bessel function of second order, \\exp(x) k_2(x), for x>0.",N,N],[5,"kl_scaled","","This routine computes the scaled irregular modified spherical Bessel function of order l, \\exp(x) k_l(x), for x>0.",N,[[["i32"],["f64"]],["f64"]]],[5,"kl_scaled_e","","This routine computes the scaled irregular modified spherical Bessel function of order l, \\exp(x) k_l(x), for x>0.",N,N],[5,"kl_scaled_array","","This routine computes the values of the scaled irregular modified spherical Bessel functions \\exp(x) k_l(x) for l from 0 to lmax inclusive for lmax >= 0 and x>0, storing the results in the array result_array. The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",N,N],[5,"Knu","","This routine computes the irregular modified Bessel function of fractional order \\nu, K_\\nu(x) for x>0, \\nu>0.",N,[[["f64"],["f64"]],["f64"]]],[5,"Knu_e","","This routine computes the irregular modified Bessel function of fractional order \\nu, K_\\nu(x) for x>0, \\nu>0.",N,N],[5,"lnKnu","","This routine computes the logarithm of the irregular modified Bessel function of fractional order \\nu, \\ln(K_\\nu(x)) for x>0, \\nu>0.",N,[[["f64"],["f64"]],["f64"]]],[5,"lnKnu_e","","This routine computes the logarithm of the irregular modified Bessel function of fractional order \\nu, \\ln(K_\\nu(x)) for x>0, \\nu>0.",N,N],[5,"Knu_scaled","","This routine computes the scaled irregular modified Bessel function of fractional order \\nu, \\exp(+|x|) K_\\nu(x) for x>0, \\nu>0.",N,[[["f64"],["f64"]],["f64"]]],[5,"Knu_scaled_e","","This routine computes the scaled irregular modified Bessel function of fractional order \\nu, \\exp(+|x|) K_\\nu(x) for x>0, \\nu>0.",N,N],[5,"Y0","","This routine computes the irregular cylindrical Bessel function of zeroth order, Y_0(x), for x>0.",N,[[["f64"]],["f64"]]],[5,"Y0_e","","This routine computes the irregular cylindrical Bessel function of zeroth order, Y_0(x), for x>0.",N,N],[5,"Y1","","This routine computes the irregular cylindrical Bessel function of first order, Y_1(x), for x>0.",N,[[["f64"]],["f64"]]],[5,"Y1_e","","This routine computes the irregular cylindrical Bessel function of first order, Y_1(x), for x>0.",N,N],[5,"Yn","","This routine computes the irregular cylindrical Bessel function of order n, Y_n(x), for x>0.",N,[[["i32"],["f64"]],["f64"]]],[5,"Yn_e","","This routine computes the irregular cylindrical Bessel function of order n, Y_n(x), for x>0.",N,N],[5,"Yn_array","","This routine computes the values of the irregular cylindrical Bessel functions Y_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array. The domain of the function is x>0. The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",N,N],[5,"y0","","This routine computes the irregular spherical Bessel function of zeroth order, y_0(x) = -\\cos(x)/x.",N,[[["f64"]],["f64"]]],[5,"y0_e","","This routine computes the irregular spherical Bessel function of zeroth order, y_0(x) = -\\cos(x)/x.",N,N],[5,"y1","","This routine computes the irregular spherical Bessel function of first order, y_1(x) = -(\\cos(x)/x + \\sin(x))/x.",N,[[["f64"]],["f64"]]],[5,"y1_e","","This routine computes the irregular spherical Bessel function of first order, y_1(x) = -(\\cos(x)/x + \\sin(x))/x.",N,N],[5,"y2","","This routine computes the irregular spherical Bessel function of second order, y_2(x) = (-3/x^3 + 1/x)\\cos(x) - (3/x^2)\\sin(x).",N,[[["f64"]],["f64"]]],[5,"y2_e","","This routine computes the irregular spherical Bessel function of second order, y_2(x) = (-3/x^3 + 1/x)\\cos(x) - (3/x^2)\\sin(x).",N,N],[5,"yl","","This routine computes the irregular spherical Bessel function of order l, y_l(x), for l >= 0.",N,[[["i32"],["f64"]],["f64"]]],[5,"yl_e","","This routine computes the irregular spherical Bessel function of order l, y_l(x), for l >= 0.",N,N],[5,"yl_array","","This routine computes the values of the irregular spherical Bessel functions y_l(x) for l from 0 to lmax inclusive for lmax >= 0, storing the results in the array result_array. The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",N,N],[5,"Ynu","","This routine computes the irregular cylindrical Bessel function of fractional order \\nu, Y_\\nu(x).",N,[[["f64"],["f64"]],["f64"]]],[5,"Ynu_e","","This routine computes the irregular cylindrical Bessel function of fractional order \\nu, Y_\\nu(x).",N,N],[5,"zero_J0","","This routine computes the location of the s-th positive zero of the Bessel function J_0(x).",N,[[["u32"]],["f64"]]],[5,"zero_J0_e","","This routine computes the location of the s-th positive zero of the Bessel function J_0(x).",N,N],[5,"zero_J1","","This routine computes the location of the s-th positive zero of the Bessel function J_1(x).",N,[[["u32"]],["f64"]]],[5,"zero_J1_e","","This routine computes the location of the s-th positive zero of the Bessel function J_1(x).",N,N],[5,"zero_Jnu","","This routine computes the location of the s-th positive zero of the Bessel function J_\\nu(x). The current implementation does not support negative values of nu.",N,[[["f64"],["u32"]],["f64"]]],[5,"zero_Jnu_e","","This routine computes the location of the s-th positive zero of the Bessel function J_\\nu(x). The current implementation does not support negative values of nu.",N,N],[0,"blas","rgsl","",N,N],[0,"level1","rgsl::blas","",N,N],[5,"sdsdot","rgsl::blas::level1","This function computes the sum \\alpha + x^T y for the vectors x and y, returning the result in result.",N,[[["f32"],["vectorf32"],["vectorf32"],["f32"]],["value"]]],[5,"sdot","","This function computes the scalar product x^T y for the vectors x and y, returning the result in result.",N,[[["vectorf32"],["vectorf32"],["f32"]],["value"]]],[5,"dsdot","","This function computes the scalar product x^T y for the vectors x and y, returning the result in result.",N,[[["vectorf32"],["vectorf32"],["f64"]],["value"]]],[5,"ddot","","This function computes the scalar product x^T y for the vectors x and y, returning the result in result.",N,[[["vectorf64"],["vectorf64"],["f64"]],["value"]]],[5,"cdotu","","This function computes the complex scalar product x^T y for the vectors x and y, returning the result in dotu.",N,[[["vectorcomplexf32"],["vectorcomplexf32"],["complexf32"]],["value"]]],[5,"zdotu","","This function computes the complex scalar product x^T y for the vectors x and y, returning the result in dotu.",N,[[["vectorcomplexf64"],["vectorcomplexf64"],["complexf64"]],["value"]]],[5,"cdotc","","This function computes the complex conjugate scalar product x^H y for the vectors x and y, returning the result in dotc.",N,[[["vectorcomplexf32"],["vectorcomplexf32"],["complexf32"]],["value"]]],[5,"zdotc","","This function computes the complex conjugate scalar product x^H y for the vectors x and y, returning the result in dotc.",N,[[["vectorcomplexf64"],["vectorcomplexf64"],["complexf64"]],["value"]]],[5,"snrm2","","This function computes the Euclidean norm ||x||_2 = \\sqrt {\\sum x_i^2} of the vector x.",N,[[["vectorf32"]],["f32"]]],[5,"dnrm2","","This function computes the Euclidean norm ||x||_2 = \\sqrt {\\sum x_i^2} of the vector x.",N,[[["vectorf64"]],["f64"]]],[5,"scnrm2","","This function computes the Euclidean norm of the complex vector x,",N,[[["vectorcomplexf32"]],["f32"]]],[5,"dznrm2","","This function computes the Euclidean norm of the complex vector x,",N,[[["vectorcomplexf64"]],["f64"]]],[5,"sasum","","This function computes the absolute sum \\sum |x_i| of the elements of the vector x.",N,[[["vectorf32"]],["f32"]]],[5,"dasum","","This function computes the absolute sum \\sum |x_i| of the elements of the vector x.",N,[[["vectorf64"]],["f64"]]],[5,"scasum","","This function computes the sum of the magnitudes of the real and imaginary parts of the complex vector x, \\sum |\\Re(x_i)| + |\\Im(x_i)|.",N,[[["vectorcomplexf32"]],["f32"]]],[5,"dzasum","","This function computes the sum of the magnitudes of the real and imaginary parts of the complex vector x, \\sum |\\Re(x_i)| + |\\Im(x_i)|.",N,[[["vectorcomplexf64"]],["f64"]]],[5,"isamax","","This function returns the index of the largest element of the vector x. The largest element is determined by its absolute magnitude for real vectors and by the sum of the magnitudes of the real and imaginary parts |\\Re(x_i)| + |\\Im(x_i)| for complex vectors. If the largest value occurs several times then the index of the first occurrence is returned.",N,[[["vectorf32"]],["u32"]]],[5,"idamax","","This function returns the index of the largest element of the vector x. The largest element is determined by its absolute magnitude for real vectors and by the sum of the magnitudes of the real and imaginary parts |\\Re(x_i)| + |\\Im(x_i)| for complex vectors. If the largest value occurs several times then the index of the first occurrence is returned.",N,[[["vectorf64"]],["u32"]]],[5,"icamax","","This function returns the index of the largest element of the vector x. The largest element is determined by its absolute magnitude for real vectors and by the sum of the magnitudes of the real and imaginary parts |\\Re(x_i)| + |\\Im(x_i)| for complex vectors. If the largest value occurs several times then the index of the first occurrence is returned.",N,[[["vectorcomplexf32"]],["u32"]]],[5,"izamax","","This function returns the index of the largest element of the vector x. The largest element is determined by its absolute magnitude for real vectors and by the sum of the magnitudes of the real and imaginary parts |\\Re(x_i)| + |\\Im(x_i)| for complex vectors. If the largest value occurs several times then the index of the first occurrence is returned.",N,[[["vectorcomplexf64"]],["u32"]]],[5,"sswap","","This function exchanges the elements of the vectors x and y.",N,[[["vectorf32"],["vectorf32"]],["value"]]],[5,"dswap","","This function exchanges the elements of the vectors x and y.",N,[[["vectorf64"],["vectorf64"]],["value"]]],[5,"cswap","","This function exchanges the elements of the vectors x and y.",N,[[["vectorcomplexf32"],["vectorcomplexf32"]],["value"]]],[5,"zswap","","This function exchanges the elements of the vectors x and y.",N,[[["vectorcomplexf64"],["vectorcomplexf64"]],["value"]]],[5,"scopy","","This function copy the elements of the vector x into the vector y.",N,[[["vectorf32"],["vectorf32"]],["value"]]],[5,"dcopy","","This function copy the elements of the vector x into the vector y.",N,[[["vectorf64"],["vectorf64"]],["value"]]],[5,"ccopy","","This function copy the elements of the vector x into the vector y.",N,[[["vectorcomplexf32"],["vectorcomplexf32"]],["value"]]],[5,"zcopy","","This function copy the elements of the vector x into the vector y.",N,[[["vectorcomplexf64"],["vectorcomplexf64"]],["value"]]],[5,"saxpy","","This function computes the sum y = \\alpha x + y for the vectors x and y.",N,[[["f32"],["vectorf32"],["vectorf32"]],["value"]]],[5,"daxpy","","This function computes the sum y = \\alpha x + y for the vectors x and y.",N,[[["f64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"caxpy","","This function computes the sum y = \\alpha x + y for the vectors x and y.",N,[[["complexf32"],["vectorcomplexf32"],["vectorcomplexf32"]],["value"]]],[5,"zaxpy","","This function computes the sum y = \\alpha x + y for the vectors x and y.",N,[[["complexf64"],["vectorcomplexf64"],["vectorcomplexf64"]],["value"]]],[5,"sscal","","This function rescales the vector x by the multiplicative factor alpha.",N,[[["f32"],["vectorf32"]]]],[5,"dscal","","This function rescales the vector x by the multiplicative factor alpha.",N,[[["f64"],["vectorf64"]]]],[5,"cscal","","This function rescales the vector x by the multiplicative factor alpha.",N,[[["complexf32"],["vectorcomplexf32"]]]],[5,"zscal","","This function rescales the vector x by the multiplicative factor alpha.",N,[[["complexf64"],["vectorcomplexf64"]]]],[5,"csscal","","This function rescales the vector x by the multiplicative factor alpha.",N,[[["f32"],["vectorcomplexf32"]]]],[5,"zdscal","","This function rescales the vector x by the multiplicative factor alpha.",N,[[["f64"],["vectorcomplexf64"]]]],[5,"srotg","","This function computes a Givens rotation (c,s) which zeroes the vector (a,b),",N,N],[5,"drotg","","This function computes a Givens rotation (c,s) which zeroes the vector (a,b),",N,N],[5,"srot","","This function applies a Givens rotation (x', y') = (c x + s y, -s x + c y) to the vectors x, y.",N,[[["vectorf32"],["vectorf32"],["f32"],["f32"]],["value"]]],[5,"drot","","This function applies a Givens rotation (x', y') = (c x + s y, -s x + c y) to the vectors x, y.",N,[[["vectorf64"],["vectorf64"],["f64"],["f64"]],["value"]]],[5,"srotmg","","This function computes a modified Givens transformation. The modified Givens transformation is defined in the original Level-1 BLAS specification, given in the references.",N,N],[5,"drotmg","","This function computes a modified Givens transformation. The modified Givens transformation is defined in the original Level-1 BLAS specification, given in the references.",N,N],[5,"srotm","","This function applies a modified Givens transformation.",N,N],[5,"drotm","","This function applies a modified Givens transformation.",N,N],[0,"level2","rgsl::blas","",N,N],[5,"sgemv","rgsl::blas::level2","This function computes the matrix-vector product and sum y = \\alpha op(A) x + \\beta y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.",N,[[["transpose"],["f32"],["matrixf32"],["vectorf32"],["f32"],["vectorf32"]],["value"]]],[5,"dgemv","","This function computes the matrix-vector product and sum y = \\alpha op(A) x + \\beta y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.",N,[[["transpose"],["f64"],["matrixf64"],["vectorf64"],["f64"],["vectorf64"]],["value"]]],[5,"cgemv","","This function computes the matrix-vector product and sum y = \\alpha op(A) x + \\beta y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.",N,[[["transpose"],["complexf32"],["matrixcomplexf32"],["vectorcomplexf32"],["complexf32"],["vectorcomplexf32"]],["value"]]],[5,"zgemv","","This function computes the matrix-vector product and sum y = \\alpha op(A) x + \\beta y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.",N,[[["transpose"],["complexf64"],["matrixcomplexf64"],["vectorcomplexf64"],["complexf64"],["vectorcomplexf64"]],["value"]]],[5,"strmv","","This function computes the matrix-vector product x = op(A) x for the triangular matrix A, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans. When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used. If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["uplo"],["transpose"],["diag"],["matrixf32"],["vectorf32"]],["value"]]],[5,"dtrmv","","This function computes the matrix-vector product x = op(A) x for the triangular matrix A, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans. When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used. If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["uplo"],["transpose"],["diag"],["matrixf64"],["vectorf64"]],["value"]]],[5,"ctrmv","","This function computes the matrix-vector product x = op(A) x for the triangular matrix A, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans. When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used. If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["uplo"],["transpose"],["diag"],["matrixcomplexf32"],["vectorcomplexf32"]],["value"]]],[5,"ztrmv","","This function computes the matrix-vector product x = op(A) x for the triangular matrix A, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans. When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used. If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["uplo"],["transpose"],["diag"],["matrixcomplexf64"],["vectorcomplexf64"]],["value"]]],[5,"strsv","","This function computes inv(op(A)) x for x, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans. When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used. If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["uplo"],["transpose"],["diag"],["matrixf32"],["vectorf32"]],["value"]]],[5,"dtrsv","","This function computes inv(op(A)) x for x, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans. When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used. If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["uplo"],["transpose"],["diag"],["matrixf64"],["vectorf64"]],["value"]]],[5,"ctrsv","","This function computes inv(op(A)) x for x, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans. When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used. If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["uplo"],["transpose"],["diag"],["matrixcomplexf32"],["vectorcomplexf32"]],["value"]]],[5,"ztrsv","","This function computes inv(op(A)) x for x, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans. When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used. If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["uplo"],["transpose"],["diag"],["matrixcomplexf64"],["vectorcomplexf64"]],["value"]]],[5,"ssymv","","These functions compute the matrix-vector product and sum y = \\alpha A x + \\beta y for the symmetric matrix A. Since the matrix A is symmetric only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",N,[[["uplo"],["f32"],["matrixf32"],["vectorf32"],["f32"],["vectorf32"]],["value"]]],[5,"dsymv","","These functions compute the matrix-vector product and sum y = \\alpha A x + \\beta y for the symmetric matrix A. Since the matrix A is symmetric only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",N,[[["uplo"],["f64"],["matrixf64"],["vectorf64"],["f64"],["vectorf64"]],["value"]]],[5,"chemv","","These functions compute the matrix-vector product and sum y = \\alpha A x + \\beta y for the hermitian matrix A. Since the matrix A is hermitian only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used. The imaginary elements of the diagonal are automatically assumed to be zero and are not referenced.",N,[[["uplo"],["complexf32"],["matrixcomplexf32"],["vectorcomplexf32"],["complexf32"],["vectorcomplexf32"]],["value"]]],[5,"zhemv","","These functions compute the matrix-vector product and sum y = \\alpha A x + \\beta y for the hermitian matrix A. Since the matrix A is hermitian only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used. The imaginary elements of the diagonal are automatically assumed to be zero and are not referenced.",N,[[["uplo"],["complexf64"],["matrixcomplexf64"],["vectorcomplexf64"],["complexf64"],["vectorcomplexf64"]],["value"]]],[5,"sger","","This function computes the rank-1 update A = \\alpha x y^T + A of the matrix A.",N,[[["f32"],["vectorf32"],["vectorf32"],["matrixf32"]],["value"]]],[5,"dger","","This function computes the rank-1 update A = \\alpha x y^T + A of the matrix A.",N,[[["f64"],["vectorf64"],["vectorf64"],["matrixf64"]],["value"]]],[5,"cgeru","","This function computes the rank-1 update A = \\alpha x y^T + A of the matrix A.",N,[[["complexf32"],["vectorcomplexf32"],["vectorcomplexf32"],["matrixcomplexf32"]],["value"]]],[5,"zgeru","","This function computes the rank-1 update A = \\alpha x y^T + A of the matrix A.",N,[[["complexf64"],["vectorcomplexf64"],["vectorcomplexf64"],["matrixcomplexf64"]],["value"]]],[5,"cgerc","","This function computes the conjugate rank-1 update A = \\alpha x y^H + A of the matrix A.",N,[[["complexf32"],["vectorcomplexf32"],["vectorcomplexf32"],["matrixcomplexf32"]],["value"]]],[5,"zgerc","","This function computes the conjugate rank-1 update A = \\alpha x y^H + A of the matrix A.",N,[[["complexf64"],["vectorcomplexf64"],["vectorcomplexf64"],["matrixcomplexf64"]],["value"]]],[5,"ssyr","","This function computes the symmetric rank-1 update A = \\alpha x x^T + A of the symmetric matrix A. Since the matrix A is symmetric only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",N,[[["uplo"],["f32"],["vectorf32"],["matrixf32"]],["value"]]],[5,"dsyr","","This function computes the symmetric rank-1 update A = \\alpha x x^T + A of the symmetric matrix A. Since the matrix A is symmetric only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",N,[[["uplo"],["f64"],["vectorf64"],["matrixf64"]],["value"]]],[5,"cher","","These functions compute the hermitian rank-1 update A = \\alpha x x^H + A of the hermitian matrix A. Since the matrix A is hermitian only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used. The imaginary elements of the diagonal are automatically set to zero.",N,[[["uplo"],["f32"],["vectorcomplexf32"],["matrixcomplexf32"]],["value"]]],[5,"zher","","These functions compute the hermitian rank-1 update A = \\alpha x x^H + A of the hermitian matrix A. Since the matrix A is hermitian only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used. The imaginary elements of the diagonal are automatically set to zero.",N,[[["uplo"],["f64"],["vectorcomplexf64"],["matrixcomplexf64"]],["value"]]],[5,"ssyr2","","These functions compute the symmetric rank-2 update A = \\alpha x y^T + \\alpha y x^T + A of the symmetric matrix A. Since the matrix A is symmetric only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",N,[[["uplo"],["f32"],["vectorf32"],["vectorf32"],["matrixf32"]],["value"]]],[5,"dsyr2","","These functions compute the symmetric rank-2 update A = \\alpha x y^T + \\alpha y x^T + A of the symmetric matrix A. Since the matrix A is symmetric only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",N,[[["uplo"],["f64"],["vectorf64"],["vectorf64"],["matrixf64"]],["value"]]],[5,"cher2","","These functions compute the hermitian rank-2 update A = \\alpha x y^H + \\alpha^* y x^H + A of the hermitian matrix A. Since the matrix A is hermitian only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used. The imaginary elements of the diagonal are automatically set to zero.",N,[[["uplo"],["complexf32"],["vectorcomplexf32"],["vectorcomplexf32"],["matrixcomplexf32"]],["value"]]],[5,"zher2","","These functions compute the hermitian rank-2 update A = \\alpha x y^H + \\alpha^* y x^H + A of the hermitian matrix A. Since the matrix A is hermitian only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used. The imaginary elements of the diagonal are automatically set to zero.",N,[[["uplo"],["complexf64"],["vectorcomplexf64"],["vectorcomplexf64"],["matrixcomplexf64"]],["value"]]],[0,"level3","rgsl::blas","",N,N],[5,"sgemm","rgsl::blas::level3","This function computes the matrix-matrix product and sum C = \\alpha op(A) op(B) + \\beta C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.",N,[[["transpose"],["transpose"],["f32"],["matrixf32"],["matrixf32"],["f32"],["matrixf32"]],["value"]]],[5,"dgemm","","This function computes the matrix-matrix product and sum C = \\alpha op(A) op(B) + \\beta C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.",N,[[["transpose"],["transpose"],["f64"],["matrixf64"],["matrixf64"],["f64"],["matrixf64"]],["value"]]],[5,"cgemm","","This function computes the matrix-matrix product and sum C = \\alpha op(A) op(B) + \\beta C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.",N,[[["transpose"],["transpose"],["complexf32"],["matrixcomplexf32"],["matrixcomplexf32"],["complexf32"],["matrixcomplexf32"]],["value"]]],[5,"zgemm","","This function computes the matrix-matrix product and sum C = \\alpha op(A) op(B) + \\beta C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.",N,[[["transpose"],["transpose"],["complexf64"],["matrixcomplexf64"],["matrixcomplexf64"],["complexf64"],["matrixcomplexf64"]],["value"]]],[5,"ssymm","","This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is symmetric. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",N,[[["side"],["uplo"],["f32"],["matrixf32"],["matrixf32"],["f32"],["matrixf32"]],["value"]]],[5,"dsymm","","This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is symmetric. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",N,[[["side"],["uplo"],["f64"],["matrixf64"],["matrixf64"],["f64"],["matrixf64"]],["value"]]],[5,"csymm","","This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is symmetric. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",N,[[["side"],["uplo"],["complexf32"],["matrixcomplexf32"],["matrixcomplexf32"],["complexf32"],["matrixcomplexf32"]],["value"]]],[5,"zsymm","","This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is symmetric. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",N,[[["side"],["uplo"],["complexf64"],["matrixcomplexf64"],["matrixcomplexf64"],["complexf64"],["matrixcomplexf64"]],["value"]]],[5,"chemm","","This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is Left and C = \\alpha B A + \\beta C for Side is Right, where the matrix A is hermitian. When Uplo is Upper then the upper triangle and diagonal of A are used, and when Uplo is Lower then the lower triangle and diagonal of A are used. The imaginary elements of the diagonal are automatically set to zero.",N,[[["side"],["uplo"],["complexf32"],["matrixcomplexf32"],["matrixcomplexf32"],["complexf32"],["matrixcomplexf32"]],["value"]]],[5,"zhemm","","This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is hermitian. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used. The imaginary elements of the diagonal are automatically set to zero.",N,[[["side"],["uplo"],["complexf64"],["matrixcomplexf64"],["matrixcomplexf64"],["complexf64"],["matrixcomplexf64"]],["value"]]],[5,"strmm","","This function computes the matrix-matrix product B = \\alpha op(A) B for Side is Left and B = \\alpha B op(A) for Side is CblasRight. The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans. When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used. If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["side"],["uplo"],["transpose"],["diag"],["f32"],["matrixf32"],["matrixf32"]],["value"]]],[5,"dtrmm","","This function computes the matrix-matrix product B = \\alpha op(A) B for Side is Left and B = \\alpha B op(A) for Side is CblasRight. The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans. When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used. If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["side"],["uplo"],["transpose"],["diag"],["f64"],["matrixf64"],["matrixf64"]],["value"]]],[5,"ctrmm","","This function computes the matrix-matrix product B = \\alpha op(A) B for Side is Left and B = \\alpha B op(A) for Side is CblasRight. The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans. When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used. If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["side"],["uplo"],["transpose"],["diag"],["complexf32"],["matrixcomplexf32"],["matrixcomplexf32"]],["value"]]],[5,"ztrmm","","This function computes the matrix-matrix product B = \\alpha op(A) B for Side is Left and B = \\alpha B op(A) for Side is CblasRight. The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans. When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used. If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["side"],["uplo"],["transpose"],["diag"],["complexf64"],["matrixcomplexf64"],["matrixcomplexf64"]],["value"]]],[5,"strsm","","This function computes the inverse-matrix matrix product B = \\alpha op(inv(A))B for Side is Left and B = \\alpha B op(inv(A)) for Side is Right. The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans. When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used. If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["side"],["uplo"],["transpose"],["diag"],["f32"],["matrixf32"],["matrixf32"]],["value"]]],[5,"dtrsm","","This function computes the inverse-matrix matrix product B = \\alpha op(inv(A))B for Side is Left and B = \\alpha B op(inv(A)) for Side is Right. The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans. When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used. If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["side"],["uplo"],["transpose"],["diag"],["f64"],["matrixf64"],["matrixf64"]],["value"]]],[5,"ctrsm","","This function computes the inverse-matrix matrix product B = \\alpha op(inv(A))B for Side is Left and B = \\alpha B op(inv(A)) for Side is Right. The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans. When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used. If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["side"],["uplo"],["transpose"],["diag"],["complexf32"],["matrixcomplexf32"],["matrixcomplexf32"]],["value"]]],[5,"ztrsm","","This function computes the inverse-matrix matrix product B = \\alpha op(inv(A))B for Side is Left and B = \\alpha B op(inv(A)) for Side is Right. The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans. When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used. If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",N,[[["side"],["uplo"],["transpose"],["diag"],["complexf64"],["matrixcomplexf64"],["matrixcomplexf64"]],["value"]]],[5,"ssyrk","","This function computes a rank-k update of the symmetric matrix C, C = \\alpha A A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T A + \\beta C when Trans is Trans. Since the matrix C is symmetric only its upper half or lower half need to be stored. When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",N,[[["uplo"],["transpose"],["f32"],["matrixf32"],["f32"],["matrixf32"]],["value"]]],[5,"dsyrk","","This function computes a rank-k update of the symmetric matrix C, C = \\alpha A A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T A + \\beta C when Trans is Trans. Since the matrix C is symmetric only its upper half or lower half need to be stored. When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",N,[[["uplo"],["transpose"],["f64"],["matrixf64"],["f64"],["matrixf64"]],["value"]]],[5,"csyrk","","This function computes a rank-k update of the symmetric matrix C, C = \\alpha A A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T A + \\beta C when Trans is Trans. Since the matrix C is symmetric only its upper half or lower half need to be stored. When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",N,[[["uplo"],["transpose"],["complexf32"],["matrixcomplexf32"],["complexf32"],["matrixcomplexf32"]],["value"]]],[5,"zsyrk","","This function computes a rank-k update of the symmetric matrix C, C = \\alpha A A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T A + \\beta C when Trans is Trans. Since the matrix C is symmetric only its upper half or lower half need to be stored. When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",N,[[["uplo"],["transpose"],["complexf64"],["matrixcomplexf64"],["complexf64"],["matrixcomplexf64"]],["value"]]],[5,"cherk","","These functions compute a rank-k update of the hermitian matrix C, C = \\alpha A A^H + \\beta C when Trans is NoTrans and C = \\alpha A^H A + \\beta C when Trans is ConjTrans. Since the matrix C is hermitian only its upper half or lower half need to be stored. When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used. The imaginary elements of the diagonal are automatically set to zero.",N,[[["uplo"],["transpose"],["f32"],["matrixcomplexf32"],["f32"],["matrixcomplexf32"]],["value"]]],[5,"zherk","","These functions compute a rank-k update of the hermitian matrix C, C = \\alpha A A^H + \\beta C when Trans is NoTrans and C = \\alpha A^H A + \\beta C when Trans is ConjTrans. Since the matrix C is hermitian only its upper half or lower half need to be stored. When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used. The imaginary elements of the diagonal are automatically set to zero.",N,[[["uplo"],["transpose"],["f64"],["matrixcomplexf64"],["f64"],["matrixcomplexf64"]],["value"]]],[5,"ssyr2k","","This function computes a rank-2k update of the symmetric matrix C, C = \\alpha A B^T + \\alpha B A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T B + \\alpha B^T A + \\beta C when Trans is Trans. Since the matrix C is symmetric only its upper half or lower half need to be stored. When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",N,[[["uplo"],["transpose"],["f32"],["matrixf32"],["matrixf32"],["f32"],["matrixf32"]],["value"]]],[5,"dsyr2k","","This function computes a rank-2k update of the symmetric matrix C, C = \\alpha A B^T + \\alpha B A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T B + \\alpha B^T A + \\beta C when Trans is Trans. Since the matrix C is symmetric only its upper half or lower half need to be stored. When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",N,[[["uplo"],["transpose"],["f64"],["matrixf64"],["matrixf64"],["f64"],["matrixf64"]],["value"]]],[5,"csyr2k","","This function computes a rank-2k update of the symmetric matrix C, C = \\alpha A B^T + \\alpha B A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T B + \\alpha B^T A + \\beta C when Trans is Trans. Since the matrix C is symmetric only its upper half or lower half need to be stored. When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",N,[[["uplo"],["transpose"],["complexf32"],["matrixcomplexf32"],["matrixcomplexf32"],["complexf32"],["matrixcomplexf32"]],["value"]]],[5,"zsyr2k","","This function computes a rank-2k update of the symmetric matrix C, C = \\alpha A B^T + \\alpha B A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T B + \\alpha B^T A + \\beta C when Trans is Trans. Since the matrix C is symmetric only its upper half or lower half need to be stored. When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",N,[[["uplo"],["transpose"],["complexf64"],["matrixcomplexf64"],["matrixcomplexf64"],["complexf64"],["matrixcomplexf64"]],["value"]]],[5,"cher2k","","This function computes a rank-2k update of the hermitian matrix C, C = \\alpha A B^H + \\alpha^* B A^H + \\beta C when Trans is NoTrans and C = \\alpha A^H B + \\alpha^* B^H A + \\beta C when Trans is ConjTrans. Since the matrix C is hermitian only its upper half or lower half need to be stored. When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used. The imaginary elements of the diagonal are automatically set to zero.",N,[[["uplo"],["transpose"],["complexf32"],["matrixcomplexf32"],["matrixcomplexf32"],["f32"],["matrixcomplexf32"]],["value"]]],[5,"zher2k","","This function computes a rank-2k update of the hermitian matrix C, C = \\alpha A B^H + \\alpha^* B A^H + \\beta C when Trans is NoTrans and C = \\alpha A^H B + \\alpha^* B^H A + \\beta C when Trans is ConjTrans. Since the matrix C is hermitian only its upper half or lower half need to be stored. When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used. The imaginary elements of the diagonal are automatically set to zero.",N,[[["uplo"],["transpose"],["complexf64"],["matrixcomplexf64"],["matrixcomplexf64"],["f64"],["matrixcomplexf64"]],["value"]]],[0,"cblas","rgsl","",N,N],[3,"Index","rgsl::cblas","",N,N],[12,"0","","",100,N],[4,"Order","","Indicates whether a matrix is in Row Major or Column Major order. Row major order is the native order for C programs, while Column major order is native for Fortran.",N,N],[13,"RowMajor","","",101,N],[13,"ColMajoyr","","",101,N],[4,"Side","","Used to indicate the order of a matrix-matrix multiply.",N,N],[13,"Left","","Means A B",102,N],[13,"Right","","Means B A",102,N],[4,"Transpose","","Used to represent transpose operations on a matrix.",N,N],[13,"NoTrans","","Represents X",103,N],[13,"Trans","","Represents X^T",103,N],[13,"ConjTrans","","Represents X^H",103,N],[4,"Uplo","","Used to indicate which part of a symmetric matrix to use.",N,N],[13,"Upper","","Means user the upper triagle of the matrix.",104,N],[13,"Lower","","Means use the lower triange of the matrix.",104,N],[4,"Diag","","",N,N],[13,"NonUnit","","",105,N],[13,"Unit","","",105,N],[0,"level1","","",N,N],[5,"sdsdot","rgsl::cblas::level1","",N,N],[5,"dsdot","","",N,N],[5,"sdot","","",N,N],[5,"ddot","","",N,N],[5,"cdotu_sub","","",N,N],[5,"cdotc_sub","","",N,N],[5,"zdotu_sub","","",N,N],[5,"zdotc_sub","","",N,N],[5,"snrm2","","",N,N],[5,"sasum","","",N,N],[5,"dnrm2","","",N,N],[5,"dasum","","",N,N],[5,"scnrm2","","",N,N],[5,"scasum","","",N,N],[5,"dznrm2","","",N,N],[5,"dzasum","","",N,N],[5,"isamax","","",N,N],[5,"idamax","","",N,N],[5,"icamax","","",N,N],[5,"izamax","","",N,N],[5,"sswap","","",N,N],[5,"scopy","","",N,N],[5,"saxpy","","",N,N],[5,"dswap","","",N,N],[5,"dcopy","","",N,N],[5,"daxpy","","",N,N],[5,"cswap","","",N,N],[5,"ccopy","","",N,N],[5,"caxpy","","",N,N],[5,"zswap","","",N,N],[5,"zcopy","","",N,N],[5,"zaxpy","","",N,N],[5,"srotg","","",N,N],[5,"srotmg","","",N,N],[5,"srot","","",N,N],[5,"srotm","","",N,N],[5,"drotg","","",N,N],[5,"drotmg","","",N,N],[5,"drot","","",N,N],[5,"drotm","","",N,N],[5,"sscal","","Multiple each element of a matrix/vector by a constant.",N,N],[5,"dscal","","Multiple each element of a matrix/vector by a constant.",N,N],[5,"cscal","","Multiple each element of a matrix/vector by a constant.",N,N],[5,"zscal","","Multiple each element of a matrix/vector by a constant.",N,N],[5,"csscal","","Multiple each element of a matrix/vector by a constant.",N,N],[5,"zdscal","","Multiple each element of a matrix/vector by a constant.",N,N],[0,"level2","rgsl::cblas","",N,N],[5,"sgemv","rgsl::cblas::level2","Multiplies a matrix and a vector.",N,N],[5,"sgbmv","","",N,N],[5,"strmv","","",N,N],[5,"stbmv","","",N,N],[5,"stpmv","","",N,N],[5,"strsv","","",N,N],[5,"stbsv","","",N,N],[5,"stpsv","","",N,N],[5,"dgemv","","",N,N],[5,"dgbmv","","",N,N],[5,"dtrmv","","",N,N],[5,"dtbmv","","",N,N],[5,"dtpmv","","",N,N],[5,"dtrsv","","",N,N],[5,"dtbsv","","",N,N],[5,"dtpsv","","",N,N],[5,"cgemv","","",N,N],[5,"cgbmv","","",N,N],[5,"ctrmv","","",N,N],[5,"ctbmv","","",N,N],[5,"ctpmv","","",N,N],[5,"ctrsv","","",N,N],[5,"ctbsv","","",N,N],[5,"ctpsv","","",N,N],[5,"zgemv","","",N,N],[5,"zgbmv","","",N,N],[5,"ztrmv","","",N,N],[5,"ztbmv","","",N,N],[5,"ztpmv","","",N,N],[5,"ztrsv","","",N,N],[5,"ztbsv","","",N,N],[5,"ztpsv","","",N,N],[5,"ssymv","","",N,N],[5,"ssbmv","","",N,N],[5,"sspmv","","",N,N],[5,"sger","","",N,N],[5,"ssyr","","",N,N],[5,"sspr","","",N,N],[5,"ssyr2","","",N,N],[5,"sspr2","","",N,N],[5,"dsymv","","",N,N],[5,"dsbmv","","",N,N],[5,"dspmv","","",N,N],[5,"dger","","",N,N],[5,"dsyr","","",N,N],[5,"dspr","","",N,N],[5,"dsyr2","","",N,N],[5,"dspr2","","",N,N],[5,"chemv","","",N,N],[5,"chbmv","","",N,N],[5,"chpmv","","",N,N],[5,"csymv","","",N,N],[5,"csbmv","","",N,N],[5,"cspmv","","",N,N],[5,"cgeru","","",N,N],[5,"cgerc","","",N,N],[5,"cher","","",N,N],[5,"chpr","","",N,N],[5,"cher2","","",N,N],[5,"chpr2","","",N,N],[5,"zhemv","","",N,N],[5,"zhbmv","","",N,N],[5,"zhpmv","","",N,N],[5,"zsymv","","",N,N],[5,"zsbmv","","",N,N],[5,"zspmv","","",N,N],[5,"zgeru","","",N,N],[5,"zgerc","","",N,N],[5,"zher","","",N,N],[5,"zhpr","","",N,N],[5,"zher2","","",N,N],[5,"zhpr2","","",N,N],[0,"level3","rgsl::cblas","",N,N],[5,"sgemm","rgsl::cblas::level3","General ::types::Matrix-MatrixF64 multiplication for single precision float.",N,N],[5,"ssymm","","Symmetric ::types::Matrix-MatrixF64 multiplication for single precision float.",N,N],[5,"ssyrk","","",N,N],[5,"ssyr2k","","",N,N],[5,"strmm","","",N,N],[5,"strsm","","",N,N],[5,"dgemm","","",N,N],[5,"dsymm","","",N,N],[5,"dsyrk","","",N,N],[5,"dsyr2k","","",N,N],[5,"dtrmm","","",N,N],[5,"dtrsm","","",N,N],[5,"cgemm","","",N,N],[5,"csymm","","",N,N],[5,"csyrk","","",N,N],[5,"csyr2k","","",N,N],[5,"ctrmm","","",N,N],[5,"ctrsm","","",N,N],[5,"zgemm","","",N,N],[5,"zsymm","","",N,N],[5,"zsyrk","","",N,N],[5,"zsyr2k","","",N,N],[5,"ztrmm","","",N,N],[5,"ztrsm","","",N,N],[5,"chemm","","",N,N],[5,"cherk","","",N,N],[5,"cher2k","","",N,N],[5,"zhemm","","",N,N],[5,"zherk","","",N,N],[5,"zher2k","","",N,N],[0,"clausen","rgsl","The Clausen function is defined by the following integral,",N,N],[5,"clausen","rgsl::clausen","This routine computes the Clausen integral Cl_2(x).",N,[[["f64"]],["f64"]]],[5,"clausen_e","","This routine computes the Clausen integral Cl_2(x).",N,N],[0,"coulomb","rgsl","",N,N],[5,"hydrogenicR_1","rgsl::coulomb","This routine computes the lowest-order normalized hydrogenic bound state radial wavefunction R_1 := 2Z \\sqrt{Z} \\exp(-Z r).",N,[[["f64"],["f64"]],["f64"]]],[5,"hydrogenicR_1_e","","This routine computes the lowest-order normalized hydrogenic bound state radial wavefunction R_1 := 2Z \\sqrt{Z} \\exp(-Z r).",N,N],[5,"hydrogenicR","","This routine computes the n-th normalized hydrogenic bound state radial wavefunction,",N,[[["i32"],["i32"],["f64"],["f64"]],["f64"]]],[5,"hydrogenicR_e","","This routine computes the n-th normalized hydrogenic bound state radial wavefunction,",N,N],[5,"wave_FG_e","","This function computes the Coulomb wave functions F_L(\\eta,x), G_{L-k}(\\eta,x) and their derivatives F'L(\\eta,x), G'{L-k}(\\eta,x) with respect to x. The parameters are restricted to L, L-k > -1/2, x > 0 and integer k. Note that L itself is not restricted to being an integer. The results are stored in the parameters F, G for the function values and Fp, Gp for the derivative values. If an overflow occurs, GSL_EOVRFLW is returned and scaling exponents are stored in the modifiable parameters exp_F, exp_G.",N,N],[5,"wave_F_array","","This function computes the Coulomb wave function F_L(\\eta,x) for L = Lmin \\dots Lmin + kmax, storing the results in fc_array. In the case of overflow the exponent is stored in F_exponent.",N,N],[5,"wave_FG_array","","This function computes the functions F_L(\\eta,x), G_L(\\eta,x) for L = Lmin \\dots Lmin + kmax storing the results in fc_array and gc_array. In the case of overflow the exponents are stored in F_exponent and G_exponent.",N,N],[5,"wave_FGp_array","","This function computes the functions F_L(\\eta,x), G_L(\\eta,x) and their derivatives F'_L(\\eta,x), G'_L(\\eta,x) for L = Lmin \\dots Lmin + kmax storing the results in fc_array, gc_array, fcp_array and gcp_array. In the case of overflow the exponents are stored in F_exponent and G_exponent.",N,N],[5,"wave_sphF_array","","This function computes the Coulomb wave function divided by the argument F_L(\\eta, x)/x for L = Lmin \\dots Lmin + kmax, storing the results in fc_array. In the case of overflow the exponent is stored in F_exponent. This function reduces to spherical Bessel functions in the limit \\eta \\to 0.",N,N],[5,"CL_e","","This function computes the Coulomb wave function normalization constant C_L(\\eta) for L > -1.",N,N],[5,"CL_array","","This function computes the Coulomb wave function normalization constant C_L(\\eta) for L = Lmin \\dots Lmin + kmax, Lmin > -1.",N,N],[0,"coupling_coefficients","rgsl","The Wigner 3-j, 6-j and 9-j symbols give the coupling coefficients for combined angular momentum vectors. Since the arguments of the standard coupling coefficient functions are integer or half-integer, the arguments of the following functions are, by convention, integers equal to twice the actual spin value.",N,N],[5,"_3j","rgsl::coupling_coefficients","This routine computes the Wigner 3-j coefficient,",N,[[["i32"],["i32"],["i32"],["i32"],["i32"],["i32"]],["f64"]]],[5,"_3j_e","","This routine computes the Wigner 3-j coefficient,",N,N],[5,"_6j","","This routine computes the Wigner 6-j coefficient,",N,[[["i32"],["i32"],["i32"],["i32"],["i32"],["i32"]],["f64"]]],[5,"_6j_e","","This routine computes the Wigner 6-j coefficient,",N,N],[5,"_9j","","This routine computes the Wigner 9-j coefficient,",N,[[["i32"],["i32"],["i32"],["i32"],["i32"],["i32"],["i32"],["i32"],["i32"]],["f64"]]],[5,"_9j_e","","This routine computes the Wigner 9-j coefficient,",N,N],[0,"dawson","rgsl","The Dawson integral is defined by \\exp(-x^2) \\int_0^x dt \\exp(t^2). A table of Dawsons integral can be found in Abramowitz & Stegun, Table 7.5.",N,N],[5,"dawson","rgsl::dawson","This routine computes the value of Dawsons integral for x.",N,[[["f64"]],["f64"]]],[5,"dawson_e","","This routine computes the value of Dawsons integral for x.",N,N],[0,"debye","rgsl","The Debye functions D_n(x) are defined by the following integral,",N,N],[5,"_1","rgsl::debye","This routine computes the first-order Debye function D_1(x) = (1/x) \\int_0^x dt (t/(e^t - 1)).",N,[[["f64"]],["f64"]]],[5,"_1_e","","This routine computes the first-order Debye function D_1(x) = (1/x) \\int_0^x dt (t/(e^t - 1)).",N,N],[5,"_2","","This routine computes the second-order Debye function D_2(x) = (2/x^2) \\int_0^x dt (t^2/(e^t - 1)).",N,[[["f64"]],["f64"]]],[5,"_2_e","","This routine computes the second-order Debye function D_2(x) = (2/x^2) \\int_0^x dt (t^2/(e^t - 1)).",N,N],[5,"_3","","This routine computes the third-order Debye function D_3(x) = (3/x^3) \\int_0^x dt (t^3/(e^t - 1)).",N,[[["f64"]],["f64"]]],[5,"_3_e","","This routine computes the third-order Debye function D_3(x) = (3/x^3) \\int_0^x dt (t^3/(e^t - 1)).",N,N],[5,"_4","","This routine computes the fourth-order Debye function D_4(x) = (4/x^4) \\int_0^x dt (t^4/(e^t - 1)).",N,[[["f64"]],["f64"]]],[5,"_4_e","","This routine computes the fourth-order Debye function D_4(x) = (4/x^4) \\int_0^x dt (t^4/(e^t - 1)).",N,N],[5,"_5","","This routine computes the fifth-order Debye function D_5(x) = (5/x^5) \\int_0^x dt (t^5/(e^t - 1)).",N,[[["f64"]],["f64"]]],[5,"_5_e","","This routine computes the fifth-order Debye function D_5(x) = (5/x^5) \\int_0^x dt (t^5/(e^t - 1)).",N,N],[5,"_6","","This routine computes the sixth-order Debye function D_6(x) = (6/x^6) \\int_0^x dt (t^6/(e^t - 1)).",N,[[["f64"]],["f64"]]],[5,"_6_e","","This routine computes the sixth-order Debye function D_6(x) = (6/x^6) \\int_0^x dt (t^6/(e^t - 1)).",N,N],[0,"dilogarithm","rgsl","",N,N],[5,"dilog","rgsl::dilogarithm","These routines compute the dilogarithm for a real argument. In Lewins notation this is Li_2(x), the real part of the dilogarithm of a real x. It is defined by the integral representation Li_2(x) = - \\Re \\int_0^x ds \\log(1-s) / s. Note that \\Im(Li_2(x)) = 0 for x <= 1, and -\\pi\\log(x) for x > 1.",N,[[["f64"]],["f64"]]],[5,"dilog_e","","These routines compute the dilogarithm for a real argument. In Lewins notation this is Li_2(x), the real part of the dilogarithm of a real x. It is defined by the integral representation Li_2(x) = - \\Re \\int_0^x ds \\log(1-s) / s. Note that \\Im(Li_2(x)) = 0 for x <= 1, and -\\pi\\log(x) for x > 1.",N,N],[5,"complex_dilog_e","","This function computes the full complex-valued dilogarithm for the complex argument z = r \\exp(i \\theta). The real and imaginary parts of the result are returned in result_re, result_im.",N,N],[0,"eigen","rgsl","##References and Further Reading",N,N],[5,"symmv_sort","rgsl::eigen","This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding real eigenvectors stored in the columns of the matrix evec into ascending or descending order according to the value of the parameter sort_type",N,[[["vectorf64"],["matrixf64"],["eigensort"]],["value"]]],[5,"hermv_sort","","This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding complex eigenvectors stored in the columns of the matrix evec into ascending or descending order according to the value of the parameter sort_type.",N,[[["vectorf64"],["matrixcomplexf64"],["eigensort"]],["value"]]],[5,"nonsymmv_sort","","This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding complex eigenvectors stored in the columns of the matrix evec into ascending or descending order according to the value of the parameter sort_type. Only EigenSort::AbsAsc and EigenSort::AbsDesc are supported due to the eigenvalues being complex.",N,[[["vectorcomplexf64"],["matrixcomplexf64"],["eigensort"]],["value"]]],[5,"gensymmv_sort","","This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding real eigenvectors stored in the columns of the matrix evec into ascending or descending order according to the value of the parameter sort_type.",N,[[["vectorf64"],["matrixf64"],["eigensort"]],["value"]]],[5,"genhermv_sort","","This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding complex eigenvectors stored in the columns of the matrix evec into ascending or descending order according to the value of the parameter sort_type.",N,[[["vectorf64"],["matrixcomplexf64"],["eigensort"]],["value"]]],[5,"genv_sort","","This function simultaneously sorts the eigenvalues stored in the vectors (alpha, beta) and the corresponding complex eigenvectors stored in the columns of the matrix evec into ascending or descending order according to the value of the parameter sort_type. Only EigenSort::AbsAsc and EigenSort::AbsDesc are supported due to the eigenvalues being complex.",N,[[["vectorcomplexf64"],["vectorf64"],["matrixcomplexf64"],["eigensort"]],["value"]]],[0,"elementary","rgsl","",N,N],[8,"Elementary","rgsl::elementary","",N,N],[10,"log1p","","This function computes the value of log(1+x) in a way that is accurate for small x. It provides an alternative to the BSD math function log1p(x).",106,[[["self"]],["self"]]],[10,"expm1","","This function computes the value of exp(x)-1 in a way that is accurate for small x. It provides an alternative to the BSD math function expm1(x).",106,[[["self"]],["self"]]],[10,"hypot","","This function computes the value of sqrt{x^2 + y^2} in a way that avoids overflow. It provides an alternative to the BSD math function hypot(x,y).",106,[[["self"],["f64"]],["self"]]],[10,"hypot3","","This function computes the value of sqrt{x^2 + y^2 + z^2} in a way that avoids overflow.",106,[[["self"],["f64"],["f64"]],["self"]]],[10,"acosh","","This function computes the value of arccosh(x). It provides an alternative to the standard math function acosh(x).",106,[[["self"]],["self"]]],[10,"asinh","","This function computes the value of arcsinh(x). It provides an alternative to the standard math function asinh(x).",106,[[["self"]],["self"]]],[10,"atanh","","This function computes the value of arctanh(x). It provides an alternative to the standard math function atanh(x).",106,[[["self"]],["self"]]],[10,"ldexp","","This function computes the value of x * 2^e. It provides an alternative to the standard math function ldexp(x,e).",106,[[["self"],["i32"]],["self"]]],[10,"frexp","","This function splits the number x into its normalized fraction f and exponent e, such that x = f * 2^e and 0.5 <= f < 1. The function returns f and stores the exponent in e. If x is zero, both f and e are set to zero. This function provides an alternative to the standard math function frexp(x, e).",106,[[["self"],["i32"]],["self"]]],[0,"elementary_operations","rgsl","",N,N],[5,"multiply_e","rgsl::elementary_operations","This function multiplies x and y storing the product and its associated error in result.",N,N],[5,"multiply_err_e","","This function multiplies x and y with associated absolute errors dx and dy. The product xy +/- xy \\sqrt((dx/x)^2 +(dy/y)^2) is stored in result.",N,N],[0,"elliptic","rgsl","Further information about the elliptic integrals can be found in Abramowitz & Stegun, Chapter 17.",N,N],[0,"legendre","rgsl::elliptic","The Legendre forms of elliptic integrals F(\\phi,k), E(\\phi,k) and \\Pi(\\phi,k,n) are defined by,",N,N],[0,"complete","rgsl::elliptic::legendre","",N,N],[5,"ellint_Kcomp","rgsl::elliptic::legendre::complete","This routine computes the complete elliptic integral K(k) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.",N,[[["f64"],["mode"]],["f64"]]],[5,"ellint_Kcomp_e","","This routine computes the complete elliptic integral K(k) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.",N,N],[5,"ellint_Ecomp","","This routine computes the complete elliptic integral E(k) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.",N,[[["f64"],["mode"]],["f64"]]],[5,"ellint_Ecomp_e","","This routine computes the complete elliptic integral E(k) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.",N,N],[5,"ellint_Pcomp","","This routine computes the complete elliptic integral \\Pi(k,n) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameters m = k^2 and \\sin^2(\\alpha) = k^2, with the change of sign n \\to -n.",N,[[["f64"],["f64"],["mode"]],["f64"]]],[5,"ellint_Pcomp_e","","This routine computes the complete elliptic integral \\Pi(k,n) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameters m = k^2 and \\sin^2(\\alpha) = k^2, with the change of sign n \\to -n.",N,N],[0,"incomplete","rgsl::elliptic::legendre","",N,N],[5,"ellint_F","rgsl::elliptic::legendre::incomplete","This routine computes the incomplete elliptic integral F(\\phi,k) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.",N,[[["f64"],["f64"],["mode"]],["f64"]]],[5,"ellint_F_e","","This routine computes the incomplete elliptic integral F(\\phi,k) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.",N,N],[5,"ellint_E","","This routine computes the incomplete elliptic integral E(\\phi,k) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.",N,[[["f64"],["f64"],["mode"]],["f64"]]],[5,"ellint_E_e","","This routine computes the incomplete elliptic integral E(\\phi,k) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.",N,N],[5,"ellint_P","","This routine computes the incomplete elliptic integral \\Pi(\\phi,k,n) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameters m = k^2 and \\sin^2(\\alpha) = k^2, with the change of sign n \\to -n.",N,[[["f64"],["f64"],["f64"],["mode"]],["f64"]]],[5,"ellint_P_e","","This routine computes the incomplete elliptic integral \\Pi(\\phi,k,n) to the accuracy specified by the mode variable mode. Note that Abramowitz & Stegun define this function in terms of the parameters m = k^2 and \\sin^2(\\alpha) = k^2, with the change of sign n \\to -n.",N,N],[5,"ellint_D","","This routine computes the incomplete elliptic integral D(\\phi,k) which is defined through the Carlson form RD(x,y,z) by the following relation,",N,[[["f64"],["f64"],["f64"],["mode"]],["f64"]]],[5,"ellint_D_e","","This routine computes the incomplete elliptic integral D(\\phi,k) which is defined through the Carlson form RD(x,y,z) by the following relation,",N,N],[0,"carlson","rgsl::elliptic","The Carlson symmetric forms of elliptical integrals RC(x,y), RD(x,y,z), RF(x,y,z) and RJ(x,y,z,p) are defined by,",N,N],[5,"ellint_RC","rgsl::elliptic::carlson","This routine computes the incomplete elliptic integral RC(x,y) to the accuracy specified by the mode variable mode.",N,[[["f64"],["f64"],["mode"]],["f64"]]],[5,"ellint_RC_e","","This routine computes the incomplete elliptic integral RC(x,y) to the accuracy specified by the mode variable mode.",N,N],[5,"ellint_RD","","This routine computes the incomplete elliptic integral RD(x,y,z) to the accuracy specified by the mode variable mode.",N,[[["f64"],["f64"],["f64"],["mode"]],["f64"]]],[5,"ellint_RD_e","","This routine computes the incomplete elliptic integral RD(x,y,z) to the accuracy specified by the mode variable mode.",N,N],[5,"ellint_RF","","This routine computes the incomplete elliptic integral RF(x,y,z) to the accuracy specified by the mode variable mode.",N,[[["f64"],["f64"],["f64"],["mode"]],["f64"]]],[5,"ellint_RF_e","","This routine computes the incomplete elliptic integral RF(x,y,z) to the accuracy specified by the mode variable mode.",N,N],[5,"ellint_RJ","","This routine computes the incomplete elliptic integral RJ(x,y,z,p) to the accuracy specified by the mode variable mode.",N,[[["f64"],["f64"],["f64"],["f64"],["mode"]],["f64"]]],[5,"ellint_RJ_e","","This routine computes the incomplete elliptic integral RJ(x,y,z,p) to the accuracy specified by the mode variable mode.",N,N],[0,"error","rgsl","The error function is described in Abramowitz & Stegun, Chapter 7.",N,N],[5,"erf","rgsl::error","This routine computes the error function erf(x), where erf(x) = (2/\\sqrt(\\pi)) \\int_0^x dt \\exp(-t^2).",N,[[["f64"]],["f64"]]],[5,"erf_e","","This routine computes the error function erf(x), where erf(x) = (2/\\sqrt(\\pi)) \\int_0^x dt \\exp(-t^2).",N,N],[5,"erfc","","This routine computes the complementary error function erfc(x) = 1 - erf(x) = (2/\\sqrt(\\pi)) \\int_x^\\infty \\exp(-t^2).",N,[[["f64"]],["f64"]]],[5,"erfc_e","","This routine computes the complementary error function erfc(x) = 1 - erf(x) = (2/\\sqrt(\\pi)) \\int_x^\\infty \\exp(-t^2).",N,N],[5,"log_erfc","","This routine computes the logarithm of the complementary error function \\log(\\erfc(x)).",N,[[["f64"]],["f64"]]],[5,"log_erfc_e","","This routine computes the logarithm of the complementary error function \\log(\\erfc(x)).",N,N],[5,"erf_Z","","This routine computes the Gaussian probability density function Z(x) = (1/\\sqrt{2\\pi}) \\exp(-x^2/2).",N,[[["f64"]],["f64"]]],[5,"erf_Z_e","","This routine computes the Gaussian probability density function Z(x) = (1/\\sqrt{2\\pi}) \\exp(-x^2/2).",N,N],[5,"erf_Q","","This routine computes the upper tail of the Gaussian probability function Q(x) = (1/\\sqrt{2\\pi}) \\int_x^\\infty dt \\exp(-t^2/2).",N,[[["f64"]],["f64"]]],[5,"erf_Q_e","","This routine computes the upper tail of the Gaussian probability function Q(x) = (1/\\sqrt{2\\pi}) \\int_x^\\infty dt \\exp(-t^2/2).",N,N],[5,"hazard","","This routine computes the hazard function for the normal distribution.",N,[[["f64"]],["f64"]]],[5,"hazard_e","","This routine computes the hazard function for the normal distribution.",N,N],[5,"str_error","","",N,[[["value"]],["str"]]],[5,"set_error_handler","","`f` is the type of GSL error handler functions. An error handler will be passed four arguments which specify the reason for the error (a string), the name of the source file in which it occurred (also a string), the line number in that file (an integer) and the error number (an integer). The source file and line number are set at compile time using the FILE and LINE directives in the preprocessor. An error handler function returns type void. Error handler functions should be defined like this,",N,[[["option"]],["option"]]],[5,"set_error_handler_off","","This function turns off the error handler by defining an error handler which does nothing. This will cause the program to continue after any error, so the return values from any library routines must be checked. This is the recommended behavior for production programs. The previous handler is returned (so that you can restore it later).",N,[[],["option"]]],[0,"exponential","rgsl","",N,N],[5,"exp","rgsl::exponential","This routine provides an exponential function \\exp(x) using GSL semantics and error checking.",N,[[["f64"]],["f64"]]],[5,"exp_e","","This routine provides an exponential function \\exp(x) using GSL semantics and error checking.",N,N],[5,"exp_e10_e","","This function computes the exponential \\exp(x) using the gsl_sf_result_e10 type to return a result with extended range. This function may be useful if the value of \\exp(x) would overflow the numeric range of double.",N,N],[5,"exp_mult","","This routine exponentiates x and multiply by the factor y to return the product y \\exp(x).",N,[[["f64"],["f64"]],["f64"]]],[5,"exp_mult_e","","This routine exponentiates x and multiply by the factor y to return the product y \\exp(x).",N,N],[5,"exp_mult_e10_e","","This function computes the exponential \\exp(x) using the gsl_sf_result_e10 type to return a result with extended range. This function may be useful if the value of \\exp(x) would overflow the numeric range of double.",N,N],[5,"expm1","","This routine computes the quantity \\exp(x)-1 using an algorithm that is accurate for small x.",N,[[["f64"]],["f64"]]],[5,"expm1_e","","This routine computes the quantity \\exp(x)-1 using an algorithm that is accurate for small x.",N,N],[5,"exprel","","This routine computes the quantity (\\exp(x)-1)/x using an algorithm that is accurate for small x. For small x the algorithm is based on the expansion (\\exp(x)-1)/x = 1 + x/2 + x^2/(23) + x^3/(23*4) + \\dots.",N,[[["f64"]],["f64"]]],[5,"exprel_e","","This routine computes the quantity (\\exp(x)-1)/x using an algorithm that is accurate for small x. For small x the algorithm is based on the expansion (\\exp(x)-1)/x = 1 + x/2 + x^2/(23) + x^3/(23*4) + \\dots.",N,N],[5,"exprel_2","","This routine computes the quantity 2(\\exp(x)-1-x)/x^2 using an algorithm that is accurate for small x. For small x the algorithm is based on the expansion 2(\\exp(x)-1-x)/x^2 = 1 + x/3 + x^2/(34) + x^3/(34*5) + \\dots.",N,[[["f64"]],["f64"]]],[5,"exprel_2_e","","This routine computes the quantity 2(\\exp(x)-1-x)/x^2 using an algorithm that is accurate for small x. For small x the algorithm is based on the expansion 2(\\exp(x)-1-x)/x^2 = 1 + x/3 + x^2/(34) + x^3/(34*5) + \\dots.",N,N],[5,"exprel_n","","This routine computes the N-relative exponential, which is the n-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel_2. The N-relative exponential is given by:",N,[[["i32"],["f64"]],["f64"]]],[5,"exprel_n_e","","This routine computes the N-relative exponential, which is the n-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel_2. The N-relative exponential is given by:",N,N],[5,"exp_err_e","","This function exponentiates x with an associated absolute error dx.",N,N],[5,"exp_err_e10_e","","This function exponentiates a quantity x with an associated absolute error dx using the ::types::ResultE10 type to return a result with extended range.",N,N],[5,"exp_mult_err_e","","This routine computes the product y \\exp(x) for the quantities x, y with associated absolute errors dx, dy.",N,N],[5,"exp_mult_err_e10_e","","This routine computes the product y \\exp(x) for the quantities x, y with associated absolute errors dx, dy using the gsl_sf_result_e10 type to return a result with extended range.",N,N],[0,"exponential_integrals","rgsl","",N,N],[5,"E1","rgsl::exponential_integrals","This routine computes the exponential integral E_1(x),",N,[[["f64"]],["f64"]]],[5,"E1_e","","This routine computes the exponential integral E_1(x),",N,N],[5,"E2","","This routine computes the second-order exponential integral E_2(x),",N,[[["f64"]],["f64"]]],[5,"E2_e","","This routine computes the second-order exponential integral E_2(x),",N,N],[5,"En","","This routine computes the exponential integral E_n(x) of order n,",N,[[["i32"],["f64"]],["f64"]]],[5,"En_e","","This routine computes the exponential integral E_n(x) of order n,",N,N],[5,"Ei","","This routine computes the exponential integral Ei(x),",N,[[["f64"]],["f64"]]],[5,"Ei_e","","This routine computes the exponential integral Ei(x),",N,N],[5,"Shi","","This routine computes the integral Shi(x) = \\int_0^x dt \\sinh(t)/t.",N,[[["f64"]],["f64"]]],[5,"Shi_e","","This routine computes the integral Shi(x) = \\int_0^x dt \\sinh(t)/t.",N,N],[5,"Chi","","This routine computes the integral Chi(x) := \\Re[ \\gamma_E + \\log(x) + \\int_0^x dt (\\cosh(t)-1)/t] , where \\gamma_E is the Euler constant (available as the macro M_EULER).",N,[[["f64"]],["f64"]]],[5,"Chi_e","","This routine computes the integral Chi(x) := \\Re[ \\gamma_E + \\log(x) + \\int_0^x dt (\\cosh(t)-1)/t] , where \\gamma_E is the Euler constant (available as the macro M_EULER).",N,N],[5,"_3","","This routine computes the third-order exponential integral Ei_3(x) = \\int_0^xdt \\exp(-t^3) for x >= 0.",N,[[["f64"]],["f64"]]],[5,"_3_e","","This routine computes the third-order exponential integral Ei_3(x) = \\int_0^xdt \\exp(-t^3) for x >= 0.",N,N],[5,"Si","","This routine computes the Sine integral Si(x) = \\int_0^x dt \\sin(t)/t.",N,[[["f64"]],["f64"]]],[5,"Si_e","","This routine computes the Sine integral Si(x) = \\int_0^x dt \\sin(t)/t.",N,N],[5,"Ci","","This routine computes the Cosine integral Ci(x) = -\\int_x^\\infty dt \\cos(t)/t for x > 0.",N,[[["f64"]],["f64"]]],[5,"Ci_e","","This routine computes the Cosine integral Ci(x) = -\\int_x^\\infty dt \\cos(t)/t for x > 0.",N,N],[5,"atanint","","This routine computes the Arctangent integral, which is defined as AtanInt(x) = \\int_0^x dt \\arctan(t)/t.",N,[[["f64"]],["f64"]]],[5,"atanint_e","","This routine computes the Arctangent integral, which is defined as AtanInt(x) = \\int_0^x dt \\arctan(t)/t.",N,N],[0,"fermi_dirac","rgsl","",N,N],[0,"complete_integrals","rgsl::fermi_dirac","The complete Fermi-Dirac integral F_j(x) is given by,",N,N],[5,"fermi_dirac_m1","rgsl::fermi_dirac::complete_integrals","This routine computes the complete Fermi-Dirac integral with an index of -1. This integral is given by F_{-1}(x) = e^x / (1 + e^x).",N,[[["f64"]],["f64"]]],[5,"fermi_dirac_m1_e","","This routine computes the complete Fermi-Dirac integral with an index of -1. This integral is given by F_{-1}(x) = e^x / (1 + e^x).",N,N],[5,"fermi_dirac_0","","This routine computes the complete Fermi-Dirac integral with an index of 0. This integral is given by F_0(x) = \\ln(1 + e^x).",N,[[["f64"]],["f64"]]],[5,"fermi_dirac_0_e","","This routine computes the complete Fermi-Dirac integral with an index of 0. This integral is given by F_0(x) = \\ln(1 + e^x).",N,N],[5,"fermi_dirac_1","","This routine computes the complete Fermi-Dirac integral with an index of 1, F_1(x) = \\int_0^\\infty dt (t /(\\exp(t-x)+1)).",N,[[["f64"]],["f64"]]],[5,"fermi_dirac_1_e","","This routine computes the complete Fermi-Dirac integral with an index of 1, F_1(x) = \\int_0^\\infty dt (t /(\\exp(t-x)+1)).",N,N],[5,"fermi_dirac_2","","This routine computes the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \\int_0^\\infty dt (t^2 /(\\exp(t-x)+1)).",N,[[["f64"]],["f64"]]],[5,"fermi_dirac_2_e","","This routine computes the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \\int_0^\\infty dt (t^2 /(\\exp(t-x)+1)).",N,N],[5,"fermi_dirac_int","","This routine computes the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\\Gamma(j+1)) \\int_0^\\infty dt (t^j /(\\exp(t-x)+1)).",N,[[["i32"],["f64"]],["f64"]]],[5,"fermi_dirac_int_e","","This routine computes the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\\Gamma(j+1)) \\int_0^\\infty dt (t^j /(\\exp(t-x)+1)).",N,N],[5,"fermi_dirac_mhalf","","This routine computes the complete Fermi-Dirac integral F_{-1/2}(x).",N,[[["f64"]],["f64"]]],[5,"fermi_dirac_mhalf_e","","This routine computes the complete Fermi-Dirac integral F_{-1/2}(x).",N,N],[5,"fermi_dirac_half","","This routine computes the complete Fermi-Dirac integral F_{1/2}(x).",N,[[["f64"]],["f64"]]],[5,"fermi_dirac_half_e","","This routine computes the complete Fermi-Dirac integral F_{1/2}(x).",N,N],[5,"fermi_dirac_3half","","This routine computes the complete Fermi-Dirac integral F_{3/2}(x).",N,[[["f64"]],["f64"]]],[5,"fermi_dirac_3half_e","","This routine computes the complete Fermi-Dirac integral F_{3/2}(x).",N,N],[0,"incomplete_integrals","rgsl::fermi_dirac","The incomplete Fermi-Dirac integral F_j(x,b) is given by,",N,N],[5,"fermi_dirac_inc_0","rgsl::fermi_dirac::incomplete_integrals","This routine computes the incomplete Fermi-Dirac integral with an index of zero, F_0(x,b) = \\ln(1 + e^{b-x}) - (b-x).",N,[[["f64"],["f64"]],["f64"]]],[5,"fermi_dirac_inc_0_e","","This routine computes the incomplete Fermi-Dirac integral with an index of zero, F_0(x,b) = \\ln(1 + e^{b-x}) - (b-x).",N,N],[0,"fft","rgsl","#Fast Fourier Transforms (FFTs)",N,N],[0,"radix2","rgsl::fft","These functions compute forward, backward and inverse FFTs of length n with stride stride, on the packed complex array data using an in-place radix-2 decimation-in-time algorithm. The length of the transform is restricted to powers of two. For the transform version of the function the sign argument can be either forward (-1) or backward (+1).",N,N],[5,"forward","rgsl::fft::radix2","",N,N],[5,"transform","","",N,N],[5,"backward","","",N,N],[5,"inverse","","",N,N],[5,"dif_forward","","This is decimation-in-frequency version of the radix-2 FFT function.",N,N],[5,"dif_transform","","This is decimation-in-frequency version of the radix-2 FFT function.",N,N],[5,"dif_backward","","This is decimation-in-frequency version of the radix-2 FFT function.",N,N],[5,"dif_inverse","","This is decimation-in-frequency version of the radix-2 FFT function.",N,N],[0,"mixed_radix","rgsl::fft","These functions compute forward, backward and inverse FFTs of length n with stride stride, on the packed complex array data, using a mixed radix decimation-in-frequency algorithm. There is no restriction on the length n. Efficient modules are provided for subtransforms of length 2, 3, 4, 5, 6 and 7. Any remaining factors are computed with a slow, O(n^2), general-n module. The caller must supply a wavetable containing the trigonometric lookup tables and a workspace work. For the transform version of the function the sign argument can be either forward (-1) or backward (+1).",N,N],[5,"forward","rgsl::fft::mixed_radix","",N,N],[5,"transform","","",N,N],[5,"backward","","",N,N],[5,"inverse","","",N,N],[0,"real_radix2","rgsl::fft","This section describes radix-2 FFT algorithms for real data. They use the Cooley-Tukey algorithm to compute in-place FFTs for lengths which are a power of 2.",N,N],[5,"transform","rgsl::fft::real_radix2","This function computes an in-place radix-2 FFT of length n and stride stride on the real array data. The output is a half-complex sequence, which is stored in-place. The arrangement of the half-complex terms uses the following scheme: for k < n/2 the real part of the k-th term is stored in location k, and the corresponding imaginary part is stored in location n-k. Terms with k > n/2 can be reconstructed using the symmetry z_k = z^*_{n-k}. The terms for k=0 and k=n/2 are both purely real, and count as a special case. Their real parts are stored in locations 0 and n/2 respectively, while their imaginary parts which are zero are not stored.",N,N],[5,"inverse","","This function computes the inverse or backwards in-place radix-2 FFT of length n and stride stride on the half-complex sequence data stored according the output scheme used by gsl_fft_real_radix2. The result is a real array stored in natural order.",N,N],[5,"backward","","This function computes the inverse or backwards in-place radix-2 FFT of length n and stride stride on the half-complex sequence data stored according the output scheme used by gsl_fft_real_radix2. The result is a real array stored in natural order.",N,N],[5,"unpack","","This function converts halfcomplex_coefficient, an array of half-complex coefficients as returned by gsl_fft_real_radix2_transform, into an ordinary complex array, complex_coefficient. It fills in the complex array using the symmetry z_k = z_{n-k}^* to reconstruct the redundant elements. The algorithm for the conversion is,",N,N],[0,"fit","rgsl","Linear Regression",N,N],[5,"linear","rgsl::fit","This function computes the best-fit linear regression coefficients (c0,c1) of the model Y = c_0 + c_1 X for the dataset (x, y), two vectors of length n with strides xstride and ystride. The errors on y are assumed unknown so the variance-covariance matrix for the parameters (c0, c1) is estimated from the scatter of the points around the best-fit line and returned via the parameters (cov00, cov01, cov11). The sum of squares of the residuals from the best-fit line is returned in sumsq. Note: the correlation coefficient of the data can be computed using gsl_stats_correlation (see `Correlation`), it does not depend on the fit.",N,N],[5,"wlinear","","This function computes the best-fit linear regression coefficients (c0,c1) of the model Y = c_0 + c_1 X for the weighted dataset (x, y), two vectors of length n with strides xstride and ystride. The vector w, of length n and stride wstride, specifies the weight of each datapoint. The weight is the reciprocal of the variance for each datapoint in y.",N,N],[5,"linear_est","","This function uses the best-fit linear regression coefficients c0, c1 and their covariance cov00, cov01, cov11 to compute the fitted function y and its standard deviation y_err for the model Y = c_0 + c_1 X at the point x.",N,[[["f64"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"]],["value"]]],[5,"mul","","This function computes the best-fit linear regression coefficient c1 of the model Y = c_1 X for the datasets (x, y), two vectors of length n with strides xstride and ystride. The errors on y are assumed unknown so the variance of the parameter c1 is estimated from the scatter of the points around the best-fit line and returned via the parameter cov11. The sum of squares of the residuals from the best-fit line is returned in sumsq.",N,N],[5,"wmul","","This function computes the best-fit linear regression coefficient c1 of the model Y = c_1 X for the weighted datasets (x, y), two vectors of length n with strides xstride and ystride. The vector w, of length n and stride wstride, specifies the weight of each datapoint. The weight is the reciprocal of the variance for each datapoint in y.",N,N],[5,"mul_est","","This function uses the best-fit linear regression coefficient c1 and its covariance cov11 to compute the fitted function y and its standard deviation y_err for the model Y = c_1 X at the point x.",N,[[["f64"],["f64"],["f64"],["f64"],["f64"]],["value"]]],[0,"gamma_beta","rgsl","This following routines compute the gamma and beta functions in their full and incomplete forms, as well as various kinds of factorials.",N,N],[0,"gamma","rgsl::gamma_beta","The Gamma function is defined by the following integral,",N,N],[5,"gamma","rgsl::gamma_beta::gamma","These routines compute the Gamma function \\Gamma(x), subject to x not being a negative integer or zero. The function is computed using the real Lanczos method. The maximum value of x such that \\Gamma(x) is not considered an overflow is given by the macro GSL_SF_GAMMA_XMAX and is 171.0.",N,[[["f64"]],["f64"]]],[5,"gamma_e","","This routine provides an exponential function \\exp(x) using GSL semantics and error checking.",N,N],[5,"lngamma","","This routine computes the Gamma function \\Gamma(x), subject to x not being a negative integer or zero. The function is computed using the real Lanczos method. The maximum value of x such that \\Gamma(x) is not considered an overflow is given by the macro GSL_SF_GAMMA_XMAX and is 171.0.",N,[[["f64"]],["f64"]]],[5,"lngamma_e","","This routine computes the Gamma function \\Gamma(x), subject to x not being a negative integer or zero. The function is computed using the real Lanczos method. The maximum value of x such that \\Gamma(x) is not considered an overflow is given by the macro GSL_SF_GAMMA_XMAX and is 171.0.",N,N],[5,"lngamma_sgn_e","","This routine computes the sign of the gamma function and the logarithm of its magnitude, subject to x not being a negative integer or zero. The function is computed using the real Lanczos method. The value of the gamma function and its error can be reconstructed using the relation \\Gamma(x) = sgn * \\exp(result_lg), taking into account the two components of result_lg.",N,N],[5,"gammastar","","This routine computes the regulated Gamma Function \\Gamma^*(x) for x > 0. The regulated gamma function is given by,",N,[[["f64"]],["f64"]]],[5,"gammastar_e","","This routine computes the regulated Gamma Function \\Gamma^*(x) for x > 0. The regulated gamma function is given by,",N,N],[5,"gammainv","","This routine computes the reciprocal of the gamma function, 1/\\Gamma(x) using the real Lanczos method.",N,[[["f64"]],["f64"]]],[5,"gammainv_e","","This routine computes the reciprocal of the gamma function, 1/\\Gamma(x) using the real Lanczos method.",N,N],[5,"lngamma_complex_e","","This routine computes \\log(\\Gamma(z)) for complex z=z_r+i z_i and z not a negative integer or zero, using the complex Lanczos method. The returned parameters are lnr = \\log|\\Gamma(z)| and arg = \\arg(\\Gamma(z)) in (-\\pi,\\pi]. Note that the phase part (arg) is not well-determined when |z| is very large, due to inevitable roundoff in restricting to (-\\pi,\\pi]. This will result in a GSL_ELOSS error when it occurs. The absolute value part (lnr), however, never suffers from loss of precision.",N,N],[0,"factorials","rgsl::gamma_beta","Although factorials can be computed from the Gamma function, using the relation n! = \\Gamma(n+1) for non-negative integer n, it is usually more efficient to call the functions in this section, particularly for small values of n, whose factorial values are maintained in hardcoded tables.",N,N],[5,"fact","rgsl::gamma_beta::factorials","This routine computes the factorial n!. The factorial is related to the Gamma function by n! = \\Gamma(n+1). The maximum value of n such that n! is not considered an overflow is given by the macro SF_FACT_NMAX and is 170.",N,[[["u32"]],["f64"]]],[5,"fact_e","","This routine computes the factorial n!. The factorial is related to the Gamma function by n! = \\Gamma(n+1). The maximum value of n such that n! is not considered an overflow is given by the macro SF_FACT_NMAX and is 170.",N,N],[5,"doublefact","","This routine computes the double factorial n!! = n(n-2)(n-4) \\dots. The maximum value of n such that n!! is not considered an overflow is given by the macro SF_DOUBLEFACT_NMAX and is 297.",N,[[["u32"]],["f64"]]],[5,"doublefact_e","","This routine computes the double factorial n!! = n(n-2)(n-4) \\dots. The maximum value of n such that n!! is not considered an overflow is given by the macro SF_DOUBLEFACT_NMAX and is 297.",N,N],[5,"lnfact","","This routine computes the logarithm of the factorial of n, \\log(n!). The algorithm is faster than computing \\ln(\\Gamma(n+1)) via gsl_sf_lngamma for n < 170, but defers for larger n.",N,[[["u32"]],["f64"]]],[5,"lnfact_e","","This routine computes the logarithm of the factorial of n, \\log(n!). The algorithm is faster than computing \\ln(\\Gamma(n+1)) via gsl_sf_lngamma for n < 170, but defers for larger n.",N,N],[5,"lndoublefact","","This routine computes the logarithm of the double factorial of n, \\log(n!!).",N,[[["u32"]],["f64"]]],[5,"lndoublefact_e","","This routine computes the logarithm of the double factorial of n, \\log(n!!).",N,N],[5,"choose","","This routine computes the combinatorial factor n choose m = n!/(m!(n-m)!)",N,[[["u32"],["u32"]],["f64"]]],[5,"choose_e","","This routine computes the combinatorial factor n choose m = n!/(m!(n-m)!)",N,N],[5,"lnchoose","","This routine computes the logarithm of n choose m. This is equivalent to the sum \\log(n!) - \\log(m!) - \\log((n-m)!).",N,[[["u32"],["u32"]],["f64"]]],[5,"lnchoose_e","","This routine computes the logarithm of n choose m. This is equivalent to the sum \\log(n!) - \\log(m!) - \\log((n-m)!).",N,N],[5,"taylorcoeff","","This routine computes the Taylor coefficient x^n / n! for x >= 0, n >= 0.",N,[[["i32"],["f64"]],["f64"]]],[5,"taylorcoeff_e","","This routine computes the Taylor coefficient x^n / n! for x >= 0, n >= 0.",N,N],[0,"pochhammer_symbol","rgsl::gamma_beta","",N,N],[5,"poch","rgsl::gamma_beta::pochhammer_symbol","This routine computes the Pochhammer symbol (a)_x = \\Gamma(a + x)/\\Gamma(a). The Pochhammer symbol is also known as the Apell symbol and sometimes written as (a,x). When a and a+x are negative integers or zero, the limiting value of the ratio is returned.",N,[[["f64"],["f64"]],["f64"]]],[5,"poch_e","","This routine computes the Pochhammer symbol (a)_x = \\Gamma(a + x)/\\Gamma(a). The Pochhammer symbol is also known as the Apell symbol and sometimes written as (a,x). When a and a+x are negative integers or zero, the limiting value of the ratio is returned.",N,N],[5,"lnpoch","","This routine computes the logarithm of the Pochhammer symbol, \\log((a)_x) = \\log(\\Gamma(a + x)/\\Gamma(a)).",N,[[["f64"],["f64"]],["f64"]]],[5,"lnpoch_e","","This routine computes the logarithm of the Pochhammer symbol, \\log((a)_x) = \\log(\\Gamma(a + x)/\\Gamma(a)).",N,N],[5,"lnpoch_sgn_e","","These routines compute the sign of the Pochhammer symbol and the logarithm of its magnitude. The computed parameters are result = \\log(|(a)_x|) with a corresponding error term, and sgn = \\sgn((a)_x) where (a)_x = \\Gamma(a + x)/\\Gamma(a).",N,N],[5,"pochrel","","This routine computes the relative Pochhammer symbol ((a)_x - 1)/x where (a)_x = \\Gamma(a + x)/\\Gamma(a).",N,[[["f64"],["f64"]],["f64"]]],[5,"pochrel_e","","This routine computes the relative Pochhammer symbol ((a)_x - 1)/x where (a)_x = \\Gamma(a + x)/\\Gamma(a).",N,N],[0,"beta","rgsl::gamma_beta","",N,N],[5,"beta","rgsl::gamma_beta::beta","This routine computes the Beta Function, B(a,b) = \\Gamma(a)\\Gamma(b)/\\Gamma(a+b) subject to a and b not being negative integers.",N,[[["f64"],["f64"]],["f64"]]],[5,"beta_e","","This routine computes the Beta Function, B(a,b) = \\Gamma(a)\\Gamma(b)/\\Gamma(a+b) subject to a and b not being negative integers.",N,N],[5,"lnbeta","","This routine computes the logarithm of the Beta Function, \\log(B(a,b)) subject to a and b not being negative integers.",N,[[["f64"],["f64"]],["f64"]]],[5,"lnbeta_e","","This routine computes the logarithm of the Beta Function, \\log(B(a,b)) subject to a and b not being negative integers.",N,N],[0,"incomplete_gamma","rgsl::gamma_beta","",N,N],[5,"gamma_inc","rgsl::gamma_beta::incomplete_gamma","This routine computes the unnormalized incomplete Gamma Function \\Gamma(a,x) = \\int_x^\\infty dt t^{a-1} \\exp(-t) for a real and x >= 0.",N,[[["f64"],["f64"]],["f64"]]],[5,"gamma_inc_e","","This routine computes the unnormalized incomplete Gamma Function \\Gamma(a,x) = \\int_x^\\infty dt t^{a-1} \\exp(-t) for a real and x >= 0.",N,N],[5,"gamma_inc_Q","","This routine computes the normalized incomplete Gamma Function Q(a,x) = 1/\\Gamma(a) \\int_x^\\infty dt t^{a-1} \\exp(-t) for a > 0, x >= 0.",N,[[["f64"],["f64"]],["f64"]]],[5,"gamma_inc_Q_e","","This routine computes the normalized incomplete Gamma Function Q(a,x) = 1/\\Gamma(a) \\int_x^\\infty dt t^{a-1} \\exp(-t) for a > 0, x >= 0.",N,N],[5,"gamma_inc_P","","This routine computes the complementary normalized incomplete Gamma Function P(a,x) = 1 - Q(a,x) = 1/\\Gamma(a) \\int_0^x dt t^{a-1} \\exp(-t) for a > 0, x >= 0.",N,[[["f64"],["f64"]],["f64"]]],[5,"gamma_inc_P_e","","This routine computes the complementary normalized incomplete Gamma Function P(a,x) = 1 - Q(a,x) = 1/\\Gamma(a) \\int_0^x dt t^{a-1} \\exp(-t) for a > 0, x >= 0.",N,N],[0,"incomplete_beta","rgsl::gamma_beta","",N,N],[5,"beta_inc","rgsl::gamma_beta::incomplete_beta","This routine computes the normalized incomplete Beta function I_x(a,b)=B_x(a,b)/B(a,b) where B_x(a,b) = \\int_0^x t^{a-1} (1-t)^{b-1} dt for 0 <= x <= 1. For a > 0, b > 0 the value is computed using a continued fraction expansion. For all other values it is computed using the relation I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b).",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"beta_inc_e","","This routine computes the normalized incomplete Beta function I_x(a,b)=B_x(a,b)/B(a,b) where B_x(a,b) = \\int_0^x t^{a-1} (1-t)^{b-1} dt for 0 <= x <= 1. For a > 0, b > 0 the value is computed using a continued fraction expansion. For all other values it is computed using the relation I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b).",N,N],[0,"gegenbauer","rgsl","The Gegenbauer polynomials are defined in Abramowitz & Stegun, Chapter 22, where they are known as Ultraspherical polynomials.",N,N],[5,"gegenpoly_1","rgsl::gegenbauer","This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.",N,[[["f64"],["f64"]],["f64"]]],[5,"gegenpoly_2","","This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.",N,[[["f64"],["f64"]],["f64"]]],[5,"gegenpoly_3","","This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.",N,[[["f64"],["f64"]],["f64"]]],[5,"gegenpoly_1_e","","This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.",N,N],[5,"gegenpoly_2_e","","This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.",N,N],[5,"gegenpoly_3_e","","This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.",N,N],[5,"gegenpoly_n","","This function evaluates the Gegenbauer polynomial C^{(\\lambda)}_n(x) for a specific value of n, lambda, x subject to \\lambda > -1/2, n >= 0.",N,[[["i32"],["f64"],["f64"]],["f64"]]],[5,"gegenpoly_n_e","","This function evaluates the Gegenbauer polynomial C^{(\\lambda)}_n(x) for a specific value of n, lambda, x subject to \\lambda > -1/2, n >= 0.",N,N],[5,"gegenpoly_array","","This function computes an array of Gegenbauer polynomials C^{(\\lambda)}_n(x) for n = 0, 1, 2, \\dots, nmax, subject to \\lambda > -1/2, nmax >= 0.",N,N],[0,"hypergeometric","rgsl","Hypergeometric functions are described in Abramowitz & Stegun, Chapters 13 and 15.",N,N],[5,"hyperg_0F1","rgsl::hypergeometric","This routine computes the hypergeometric function 0F1(c,x).",N,[[["f64"],["f64"]],["f64"]]],[5,"hyperg_0F1_e","","This routine computes the hypergeometric function 0F1(c,x).",N,N],[5,"hyperg_1F1_int","","This routine computes the confluent hypergeometric function 1F1(m,n,x) = M(m,n,x) for integer parameters m, n.",N,[[["i32"],["i32"],["f64"]],["f64"]]],[5,"hyperg_1F1_int_e","","This routine computes the confluent hypergeometric function 1F1(m,n,x) = M(m,n,x) for integer parameters m, n.",N,N],[5,"hyperg_1F1","","This routine computes the confluent hypergeometric function 1F1(a,b,x) = M(a,b,x) for general parameters a, b.",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"hyperg_1F1_e","","This routine computes the confluent hypergeometric function 1F1(a,b,x) = M(a,b,x) for general parameters a, b.",N,N],[5,"hyperg_1F1_U_int","","This routine computes the confluent hypergeometric function U(m,n,x) for integer parameters m, n.",N,[[["i32"],["i32"],["f64"]],["f64"]]],[5,"hyperg_1F1_U_int_e","","This routine computes the confluent hypergeometric function U(m,n,x) for integer parameters m, n.",N,N],[5,"hyperg_1F1_U_int_e10_e","","This routine computes the confluent hypergeometric function U(m,n,x) for integer parameters m, n using the [`ResultE10]`(types/result/struct.ResultE10.html) type to return a result with extended range.",N,N],[5,"hyperg_U","","This routine computes the confluent hypergeometric function U(a,b,x).",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"hyperg_U_e","","This routine computes the confluent hypergeometric function U(a,b,x).",N,N],[5,"hyperg_U_e10_e","","This routine computes the confluent hypergeometric function U(a,b,x) using the [`ResultE10]`(types/result/struct.ResultE10.html) type to return a result with extended range.",N,N],[5,"hyperg_2F1","","This routine computes the Gauss hypergeometric function 2F1(a,b,c,x) = F(a,b,c,x) for |x| < 1.",N,[[["f64"],["f64"],["f64"],["f64"]],["f64"]]],[5,"hyperg_2F1_e","","This routine computes the Gauss hypergeometric function 2F1(a,b,c,x) = F(a,b,c,x) for |x| < 1.",N,N],[5,"hyperg_2F1_conj","","This routine computes the Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for |x| < 1.",N,[[["f64"],["f64"],["f64"],["f64"]],["f64"]]],[5,"hyperg_2F1_conj_e","","This routine computes the Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for |x| < 1.",N,N],[5,"hyperg_2F1_renorm","","This routine computes the renormalized Gauss hypergeometric function 2F1(a,b,c,x) / \\Gamma(c) for |x| < 1.",N,[[["f64"],["f64"],["f64"],["f64"]],["f64"]]],[5,"hyperg_2F1_renorm_e","","This routine computes the renormalized Gauss hypergeometric function 2F1(a,b,c,x) / \\Gamma(c) for |x| < 1.",N,N],[5,"hyperg_2F1_conj_renorm","","This routine computes the renormalized Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c, x) / \\Gamma(c) for |x| < 1.",N,[[["f64"],["f64"],["f64"],["f64"]],["f64"]]],[5,"hyperg_2F1_conj_renorm_e","","This routine computes the renormalized Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c, x) / \\Gamma(c) for |x| < 1.",N,N],[5,"hyperg_2F0","","This routine computes the hypergeometric function 2F0(a,b,x). The series representation is a divergent hypergeometric series. However, for x < 0 we have 2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)",N,[[["f64"],["f64"],["f64"]],["f64"]]],[5,"hyperg_2F0_e","","This routine computes the hypergeometric function 2F0(a,b,x). The series representation is a divergent hypergeometric series. However, for x < 0 we have 2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)",N,N],[0,"integration","rgsl","##Introduction",N,N],[5,"qng","rgsl::integration","This function applies the Gauss-Kronrod 10-point, 21-point, 43-point and 87-point integration rules in succession until an estimate of the integral of f over (a,b) is achieved within the desired absolute and relative error limits, eps_abs and eps_rel. The function returns the final approximation, result, an estimate of the absolute error, abserr and the number of function evaluations used, neval. The Gauss-Kronrod rules are designed in such a way that each rule uses all the results of its predecessors, in order to minimize the total number of function evaluations.",N,[[["function"],["t"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"],["usize"]],["value"]]],[5,"qk15","","Gauss quadrature weights and kronrod quadrature abscissae and weights as evaluated with 80 decimal digit arithmetic by L. W. Fullerton, Bell Labs, Nov. 1981.",N,[[["function"],["t"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"]]]],[5,"qk21","","",N,[[["function"],["t"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"]]]],[5,"qk31","","",N,[[["function"],["t"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"]]]],[5,"qk41","","",N,[[["function"],["t"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"]]]],[5,"qk51","","",N,[[["function"],["t"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"]]]],[5,"qk61","","",N,[[["function"],["t"],["f64"],["f64"],["f64"],["f64"],["f64"],["f64"]]]],[5,"qk","","",N,N],[5,"qawf","","This function attempts to compute a Fourier integral of the function f over the semi-infinite interval [a,+\\infty).",N,[[["function"],["t"],["f64"],["f64"],["usize"],["integrationworkspace"],["integrationworkspace"],["integrationqawotable"],["f64"],["f64"]],["value"]]],[0,"interpolation","rgsl","",N,N],[5,"bsearch","rgsl::interpolation","This function returns the index i of the array x_array such that x_array[i] <= x < x_array[i+1]. The index is searched for in the range [index_lo,index_hi].",N,N],[5,"eval","","This function returns the interpolated value of y for a given point x, using the interpolation object interp, data arrays xa and ya and the accelerator acc. When x is outside the range of xa, the error code ::Dom is returned with a value of rgsl::NAN for y.",N,N],[5,"eval_e","","This function returns the interpolated value of y for a given point x, using the interpolation object interp, data arrays xa and ya and the accelerator acc. When x is outside the range of xa, the error code ::Dom is returned with a value of rgsl::NAN for y.",N,N],[5,"eval_deriv","","This function returns the derivative d of an interpolated function for a given point x, using the interpolation object interp, data arrays xa and ya and the accelerator acc.",N,N],[5,"eval_deriv_e","","This function returns the derivative d of an interpolated function for a given point x, using the interpolation object interp, data arrays xa and ya and the accelerator acc.",N,N],[5,"eval_deriv2","","This function returns the second derivative d2 of an interpolated function for a given point x, using the interpolation object interp, data arrays xa and ya and the accelerator acc.",N,N],[5,"eval_deriv2_e","","This function returns the second derivative d2 of an interpolated function for a given point x, using the interpolation object interp, data arrays xa and ya and the accelerator acc.",N,N],[5,"eval_integ","","This function returns the numerical integral result of an interpolated function over the range [a, b], using the interpolation object interp, data arrays xa and ya and the accelerator acc.",N,N],[5,"eval_integ_e","","This function returns the numerical integral result of an interpolated function over the range [a, b], using the interpolation object interp, data arrays xa and ya and the accelerator acc.",N,N],[0,"jacobian_elliptic","rgsl","The Jacobian Elliptic functions are defined in Abramowitz & Stegun, Chapter 16.",N,N],[5,"elljac_e","rgsl::jacobian_elliptic","This function computes the Jacobian elliptic functions sn(u|m), cn(u|m), dn(u|m) by descending Landen transformations.",N,[[["f64"],["f64"],["f64"],["f64"],["f64"]],["value"]]],[0,"laguerre","rgsl","The generalized Laguerre polynomials are defined in terms of confluent hypergeometric functions as L^a_n(x) = ((a+1)n / n!) 1F1(-n,a+1,x), and are sometimes referred to as the associated Laguerre polynomials. They are related to the plain Laguerre polynomials L_n(x) by L^0_n(x) = L_n(x) and L^k_n(x) = (-1)^k (d^k/dx^k) L(n+k)(x). For more information see Abramowitz & Stegun, Chapter 22.",N,N],[5,"laguerre_1","rgsl::laguerre","This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.",N,[[["f64"],["f64"]],["f64"]]],[5,"laguerre_2","","This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.",N,[[["f64"],["f64"]],["f64"]]],[5,"laguerre_3","","This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.",N,[[["f64"],["f64"]],["f64"]]],[5,"laguerre_1_e","","This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.",N,N],[5,"laguerre_2_e","","This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.",N,N],[5,"laguerre_3_e","","This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.",N,N],[5,"laguerre_n","","the generalized Laguerre polynomials L^a_n(x) for a > -1, n >= 0.",N,[[["i32"],["f64"],["f64"]],["f64"]]],[5,"laguerre_n_e","","the generalized Laguerre polynomials L^a_n(x) for a > -1, n >= 0.",N,N],[0,"lambert_w","rgsl","Lamberts W functions, W(x), are defined to be solutions of the equation W(x) \\exp(W(x)) = x. This function has multiple branches for x < 0; however, it has only two real-valued branches. We define W_0(x) to be the principal branch, where W > -1 for x < 0, and W_{-1}(x) to be the other real branch, where W < -1 for x < 0.",N,N],[5,"lambert_W0","rgsl::lambert_w","This computes the principal branch of the Lambert W function, W_0(x).",N,[[["f64"]],["f64"]]],[5,"lambert_W0_e","","This computes the principal branch of the Lambert W function, W_0(x).",N,N],[5,"lambert_Wm1","","This computes the secondary real-valued branch of the Lambert W function, W_{-1}(x).",N,[[["f64"]],["f64"]]],[5,"lambert_Wm1_e","","This computes the secondary real-valued branch of the Lambert W function, W_{-1}(x).",N,N],[0,"legendre","rgsl","The Legendre Functions and Legendre Polynomials are described in Abramowitz & Stegun, Chapter 8.",N,N],[0,"polynomials","rgsl::legendre","",N,N],[5,"legendre_P1","rgsl::legendre::polynomials","This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.",N,[[["f64"]],["f64"]]],[5,"legendre_P2","","This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.",N,[[["f64"]],["f64"]]],[5,"legendre_P3","","This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.",N,[[["f64"]],["f64"]]],[5,"legendre_P1_e","","This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.",N,N],[5,"legendre_P2_e","","This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.",N,N],[5,"legendre_P3_e","","This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.",N,N],[5,"legendre_Pl","","This function evaluates the Legendre polynomial P_l(x) for a specific value of l, x subject to l >= 0, |x| <= 1",N,[[["i32"],["f64"]],["f64"]]],[5,"legendre_Pl_e","","This function evaluates the Legendre polynomial P_l(x) for a specific value of l, x subject to l >= 0, |x| <= 1",N,N],[5,"legendre_Pl_array","","This function computes arrays of Legendre polynomials P_l(x) and derivatives dP_l(x)/dx, for l = 0, \\dots, lmax, |x| <= 1",N,N],[5,"legendre_Pl_deriv_array","","This function computes arrays of Legendre polynomials P_l(x) and derivatives dP_l(x)/dx, for l = 0, \\dots, lmax, |x| <= 1",N,N],[5,"legendre_Q0","","This function computes the Legendre function Q_0(x) for x > -1, x != 1",N,[[["f64"]],["f64"]]],[5,"legendre_Q0_e","","This function computes the Legendre function Q_0(x) for x > -1, x != 1",N,N],[5,"legendre_Q1","","This function computes the Legendre function Q_0(x) for x > -1, x != 1.",N,[[["f64"]],["f64"]]],[5,"legendre_Q1_e","","This function computes the Legendre function Q_0(x) for x > -1, x != 1.",N,N],[5,"legendre_Ql","","This function computes the Legendre function Q_l(x) for x > -1, x != 1 and l >= 0.",N,[[["i32"],["f64"]],["f64"]]],[5,"legendre_Ql_e","","This function computes the Legendre function Q_l(x) for x > -1, x != 1 and l >= 0.",N,N],[0,"associated_polynomials","rgsl::legendre","The following functions compute the associated Legendre Polynomials P_l^m(x). Note that this function grows combinatorially with l and can overflow for l larger than about 150. There is no trouble for small m, but overflow occurs when m and l are both large. Rather than allow overflows, these functions refuse to calculate P_l^m(x) and return `OvrFlw` when they can sense that l and m are too big.",N,N],[5,"legendre_Plm","rgsl::legendre::associated_polynomials","This routine computes the associated Legendre polynomial P_l^m(x) for m >= 0, l >= m, |x| <= 1.",N,[[["i32"],["i32"],["f64"]],["f64"]]],[5,"legendre_Plm_e","","This routine computes the associated Legendre polynomial P_l^m(x) for m >= 0, l >= m, |x| <= 1.",N,N],[5,"legendre_Plm_array","","This function computes arrays of Legendre polynomials P_l^m(x) and derivatives dP_l^m(x)/dx, for m >= 0, l = |m|, ..., lmax, |x| <= 1.",N,N],[5,"legendre_Plm_deriv_array","","This function computes arrays of Legendre polynomials P_l^m(x) and derivatives dP_l^m(x)/dx, for m >= 0, l = |m|, ..., lmax, |x| <= 1.",N,N],[5,"legendre_sphPlm","","This routine computes the normalized associated Legendre polynomial \\sqrt{(2l+1)/(4\\pi)} \\sqrt{(l-m)!/(l+m)!} P_l^m(x) suitable for use in spherical harmonics. The parameters must satisfy m >= 0, l >= m, |x| <= 1. This routine avoids the overflows that occur for the standard normalization of P_l^m(x).",N,[[["i32"],["i32"],["f64"]],["f64"]]],[5,"legendre_sphPlm_e","","This routine computes the normalized associated Legendre polynomial \\sqrt{(2l+1)/(4\\pi)} \\sqrt{(l-m)!/(l+m)!} P_l^m(x) suitable for use in spherical harmonics. The parameters must satisfy m >= 0, l >= m, |x| <= 1. This routine avoids the overflows that occur for the standard normalization of P_l^m(x).",N,N],[5,"legendre_sphPlm_array","","This function computes arrays of normalized associated Legendre functions \\sqrt{(2l+1)/(4\\pi)} \\sqrt{(l-m)!/(l+m)!} P_l^m(x), and derivatives, for m >= 0, l = |m|, ..., lmax, |x| <= 1.0",N,N],[5,"legendre_sphPlm_deriv_array","","This function computes arrays of normalized associated Legendre functions \\sqrt{(2l+1)/(4\\pi)} \\sqrt{(l-m)!/(l+m)!} P_l^m(x), and derivatives, for m >= 0, l = |m|, ..., lmax, |x| <= 1.0",N,N],[5,"legendre_array_size","","This function returns the size of result_array[] needed for the array versions of P_l^m(x), lmax - m + 1.",N,[[["i32"],["i32"]],["value"]]],[0,"conical","rgsl::legendre","The Conical Functions P^\\mu_{-(1/2)+i\\lambda}(x) and Q^\\mu_{-(1/2)+i\\lambda} are described in Abramowitz & Stegun, Section 8.12.",N,N],[5,"half","rgsl::legendre::conical","This routine computes the irregular Spherical Conical Function P^{1/2}_{-1/2 + i \\lambda}(x) for x > -1.",N,[[["f64"],["f64"]],["f64"]]],[5,"half_e","","This routine computes the irregular Spherical Conical Function P^{1/2}_{-1/2 + i \\lambda}(x) for x > -1.",N,N],[5,"mhalf","","This routine computes the regular Spherical Conical Function P^{-1/2}_{-1/2 + i \\lambda}(x) for x > -1.",N,[[["f64"],["f64"]],["f64"]]],[5,"mhalf_e","","This routine computes the regular Spherical Conical Function P^{-1/2}_{-1/2 + i \\lambda}(x) for x > -1.",N,N],[5,"_0","","This routine computes the conical function P^0_{-1/2 + i \\lambda}(x) for x > -1.",N,[[["f64"],["f64"]],["f64"]]],[5,"_0_e","","This routine computes the conical function P^0_{-1/2 + i \\lambda}(x) for x > -1.",N,N],[5,"_1","","This routine computes the conical function P^1_{-1/2 + i \\lambda}(x) for x > -1.",N,[[["f64"],["f64"]],["f64"]]],[5,"_1_e","","This routine computes the conical function P^1_{-1/2 + i \\lambda}(x) for x > -1.",N,N],[5,"sph_reg","","This routine computes the Regular Spherical Conical Function P^{-1/2-l}_{-1/2 + i \\lambda}(x) for x > -1, l >= -1.",N,[[["i32"],["f64"],["f64"]],["f64"]]],[5,"sph_reg_e","","This routine computes the Regular Spherical Conical Function P^{-1/2-l}_{-1/2 + i \\lambda}(x) for x > -1, l >= -1.",N,N],[5,"cyl_reg","","This routine computes the Regular Cylindrical Conical Function P^{-m}_{-1/2 + i \\lambda}(x) for x > -1, m >= -1.",N,[[["i32"],["f64"],["f64"]],["f64"]]],[5,"cyl_reg_e","","This routine computes the Regular Cylindrical Conical Function P^{-m}_{-1/2 + i \\lambda}(x) for x > -1, m >= -1.",N,N],[0,"radial","rgsl::legendre","The following spherical functions are specializations of Legendre functions which give the regular eigenfunctions of the Laplacian on a 3-dimensional hyperbolic space H3d. Of particular interest is the flat limit, \\lambda \\to \\infty, \\eta \\to 0, \\lambda\\eta fixed.",N,N],[5,"legendre_H3d_0","rgsl::legendre::radial","This routine computes the zeroth radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, L^{H3d}_0(\\lambda,\\eta) := \\sin(\\lambda\\eta)/(\\lambda\\sinh(\\eta)) for \\eta >= 0. In the flat limit this takes the form L^{H3d}_0(\\lambda,\\eta) = j_0(\\lambda\\eta).",N,[[["f64"],["f64"]],["f64"]]],[5,"legendre_H3d_0_e","","This routine computes the zeroth radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, L^{H3d}_0(\\lambda,\\eta) := \\sin(\\lambda\\eta)/(\\lambda\\sinh(\\eta)) for \\eta >= 0. In the flat limit this takes the form L^{H3d}_0(\\lambda,\\eta) = j_0(\\lambda\\eta).",N,N],[5,"legendre_H3d_1","","This routine computes the first radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, L^{H3d}_1(\\lambda,\\eta) := 1/\\sqrt{\\lambda^2 + 1} \\sin(\\lambda \\eta)/(\\lambda \\sinh(\\eta)) (\\coth(\\eta) - \\lambda \\cot(\\lambda\\eta)) for \\eta >= 0. In the flat limit this takes the form L^{H3d}_1(\\lambda,\\eta) = j_1(\\lambda\\eta).",N,[[["f64"],["f64"]],["f64"]]],[5,"legendre_H3d_1_e","","This routine computes the first radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, L^{H3d}_1(\\lambda,\\eta) := 1/\\sqrt{\\lambda^2 + 1} \\sin(\\lambda \\eta)/(\\lambda \\sinh(\\eta)) (\\coth(\\eta) - \\lambda \\cot(\\lambda\\eta)) for \\eta >= 0. In the flat limit this takes the form L^{H3d}_1(\\lambda,\\eta) = j_1(\\lambda\\eta).",N,N],[5,"legendre_H3d","","This routine computes the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space \\eta >= 0, l >= 0. In the flat limit this takes the form L^{H3d}_l(\\lambda,\\eta) = j_l(\\lambda\\eta).",N,[[["i32"],["f64"],["f64"]],["f64"]]],[5,"legendre_H3d_e","","This routine computes the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space \\eta >= 0, l >= 0. In the flat limit this takes the form L^{H3d}_l(\\lambda,\\eta) = j_l(\\lambda\\eta).",N,N],[5,"legendre_H3d_array","","This function computes an array of radial eigenfunctions L^{H3d}_l(\\lambda, \\eta) for 0 <= l <= lmax.",N,N],[0,"linear_algebra","rgsl","#Linear Algebra",N,N],[5,"LU_decomp","rgsl::linear_algebra","Factorise a general N x N matrix A into,",N,[[["matrixf64"],["permutation"],["i32"]],["value"]]],[5,"complex_LU_decomp","","Factorise a general N x N complex matrix A into,",N,[[["matrixcomplexf64"],["permutation"],["i32"]],["value"]]],[5,"LU_solve","","This function solves the square system A x = b using the LU decomposition of A into (LU, p) given by LU_decomp or LU_decomp as input.",N,[[["matrixf64"],["permutation"],["vectorf64"],["vectorf64"]],["value"]]],[5,"complex_LU_solve","","This function solves the square system A x = b using the LU decomposition of A into (LU, p) given by LU_decomp or LU_decomp as input.",N,[[["matrixcomplexf64"],["permutation"],["vectorcomplexf64"],["vectorcomplexf64"]],["value"]]],[5,"LU_svx","","This function solves the square system A x = b in-place using the precomputed LU decomposition of A into (LU,p). On input x should contain the right-hand side b, which is replaced by the solution on output.",N,[[["matrixf64"],["permutation"],["vectorf64"]],["value"]]],[5,"complex_LU_svx","","This function solves the square system A x = b in-place using the precomputed LU decomposition of A into (LU,p). On input x should contain the right-hand side b, which is replaced by the solution on output.",N,[[["matrixcomplexf64"],["permutation"],["vectorcomplexf64"]],["value"]]],[5,"LU_refine","","This function applies an iterative improvement to x, the solution of A x = b, from the precomputed LU decomposition of A into (LU,p). The initial residual r = A x - b is also computed and stored in residual.",N,[[["matrixf64"],["matrixf64"],["permutation"],["vectorf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"complex_LU_refine","","This function applies an iterative improvement to x, the solution of A x = b, from the precomputed LU decomposition of A into (LU,p). The initial residual r = A x - b is also computed and stored in residual.",N,[[["matrixcomplexf64"],["matrixcomplexf64"],["permutation"],["vectorcomplexf64"],["vectorcomplexf64"],["vectorcomplexf64"]],["value"]]],[5,"LU_invert","","This function computes the inverse of a matrix A from its LU decomposition (LU,p), storing the result in the matrix inverse. The inverse is computed by solving the system A x = b for each column of the identity matrix. It is preferable to avoid direct use of the inverse whenever possible, as the linear solver functions can obtain the same result more efficiently and reliably (consult any introductory textbook on numerical linear algebra for details).",N,[[["matrixf64"],["permutation"],["matrixf64"]],["value"]]],[5,"complex_LU_invert","","This function computes the inverse of a matrix A from its LU decomposition (LU,p), storing the result in the matrix inverse. The inverse is computed by solving the system A x = b for each column of the identity matrix. It is preferable to avoid direct use of the inverse whenever possible, as the linear solver functions can obtain the same result more efficiently and reliably (consult any introductory textbook on numerical linear algebra for details).",N,[[["matrixcomplexf64"],["permutation"],["matrixcomplexf64"]],["value"]]],[5,"LU_det","","This function computes the determinant of a matrix A from its LU decomposition, LU. The determinant is computed as the product of the diagonal elements of U and the sign of the row permutation signum.",N,[[["matrixf64"],["i32"]],["f64"]]],[5,"complex_LU_det","","This function computes the determinant of a matrix A from its LU decomposition, LU. The determinant is computed as the product of the diagonal elements of U and the sign of the row permutation signum.",N,[[["matrixcomplexf64"],["i32"]],["complexf64"]]],[5,"LU_lndet","","These functions compute the logarithm of the absolute value of the determinant of a matrix A, \\ln|\\det(A)|, from its LU decomposition, LU. This function may be useful if the direct computation of the determinant would overflow or underflow.",N,[[["matrixf64"]],["f64"]]],[5,"complex_LU_lndet","","These functions compute the logarithm of the absolute value of the determinant of a matrix A, \\ln|\\det(A)|, from its LU decomposition, LU. This function may be useful if the direct computation of the determinant would overflow or underflow.",N,[[["matrixcomplexf64"]],["f64"]]],[5,"LU_sgndet","","This function computes the sign or phase factor of the determinant of a matrix A, \\det(A)/|\\det(A)|, from its LU decomposition, LU.",N,[[["matrixf64"],["i32"]],["f64"]]],[5,"complex_LU_sgndet","","This function computes the sign or phase factor of the determinant of a matrix A, \\det(A)/|\\det(A)|, from its LU decomposition, LU.",N,[[["matrixcomplexf64"],["i32"]],["complexf64"]]],[5,"QR_decomp","","This function factorizes the M-by-N matrix A into the QR decomposition A = Q R. On output the diagonal and upper triangular part of the input matrix contain the matrix R. The vector tau and the columns of the lower triangular part of the matrix A contain the Householder coefficients and Householder vectors which encode the orthogonal matrix Q. The vector tau must be of length k=\\min(M,N). The matrix Q is related to these components by, Q = Q_k ... Q_2 Q_1 where Q_i = I - \\tau_i v_i v_i^T and v_i is the Householder vector v_i = (0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme as used by LAPACK.",N,[[["matrixf64"],["vectorf64"]],["value"]]],[5,"QR_solve","","This function solves the square system A x = b using the QR decomposition of A held in (QR, tau) which must have been computed previously with gsl_linalg_QR_decomp. The least-squares solution for rectangular systems can be found using QR_lssolve.",N,[[["matrixf64"],["vectorf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"QR_svx","","This function solves the square system A x = b in-place using the QR decomposition of A held in (QR,tau) which must have been computed previously by gsl_linalg_QR_decomp. On input x should contain the right-hand side b, which is replaced by the solution on output.",N,[[["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"QR_lssolve","","This function finds the least squares solution to the overdetermined system A x = b where the matrix A has more rows than columns. The least squares solution minimizes the Euclidean norm of the residual, ||Ax - b||.The routine requires as input the QR decomposition of A into (QR, tau) given by gsl_linalg_QR_decomp. The solution is returned in x. The residual is computed as a by-product and stored in residual.",N,[[["matrixf64"],["vectorf64"],["vectorf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"QR_QTvec","","This function applies the matrix Q^T encoded in the decomposition (QR,tau) to the vector v, storing the result Q^T v in v. The matrix multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T.",N,[[["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"QR_Qvec","","This function applies the matrix Q encoded in the decomposition (QR,tau) to the vector v, storing the result Q v in v. The matrix multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q.",N,[[["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"QR_QTmat","","This function applies the matrix Q^T encoded in the decomposition (QR,tau) to the matrix A, storing the result Q^T A in A. The matrix multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T.",N,[[["matrixf64"],["vectorf64"],["matrixf64"]],["value"]]],[5,"QR_Rsolve","","This function solves the triangular system R x = b for x. It may be useful if the product b' = Q^T b has already been computed using gsl_linalg_QR_QTvec.",N,[[["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"QR_Rsvx","","This function solves the triangular system R x = b for x in-place. On input x should contain the right-hand side b and is replaced by the solution on output. This function may be useful if the product b' = Q^T b has already been computed using gsl_linalg_QR_QTvec.",N,[[["matrixf64"],["vectorf64"]],["value"]]],[5,"QR_unpack","","This function unpacks the encoded QR decomposition (QR,tau) into the matrices Q and R, where Q is M-by-M and R is M-by-N.",N,[[["matrixf64"],["vectorf64"],["matrixf64"],["matrixf64"]],["value"]]],[5,"QR_QRsolve","","This function solves the system R x = Q^T b for x. It can be used when the QR decomposition of a matrix is available in unpacked form as (Q, R).",N,[[["matrixf64"],["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"QR_update","","This function performs a rank-1 update w v^T of the QR decomposition (Q, R). The update is given by Q'R' = Q (R + w v^T) where the output matrices Q' and R' are also orthogonal and right triangular. Note that w is destroyed by the update.",N,[[["matrixf64"],["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"R_solve","","This function solves the triangular system R x = b for the N-by-N matrix R.",N,[[["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"R_svx","","This function solves the triangular system R x = b in-place. On input x should contain the right-hand side b, which is replaced by the solution on output.",N,[[["matrixf64"],["vectorf64"]],["value"]]],[5,"QRPT_decomp","","This function factorizes the M-by-N matrix A into the QRP^T decomposition A = Q R P^T. On output the diagonal and upper triangular part of the input matrix contain the matrix R. The permutation matrix P is stored in the permutation p. The sign of the permutation is given by signum. It has the value (-1)^n, where n is the number of interchanges in the permutation. The vector tau and the columns of the lower triangular part of the matrix A contain the Householder coefficients and vectors which encode the orthogonal matrix Q. The vector tau must be of length k=\\min(M,N). The matrix Q is related to these components by, Q = Q_k ... Q_2 Q_1 where Q_i = I - \\tau_i v_i v_i^T and v_i is the Householder vector v_i = (0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme as used by LAPACK. The vector norm is a workspace of length N used for column pivoting.",N,[[["matrixf64"],["vectorf64"],["permutation"],["i32"],["vectorf64"]],["value"]]],[5,"QRPT_decomp2","","This function factorizes the matrix A into the decomposition A = Q R P^T without modifying A itself and storing the output in the separate matrices q and r.",N,[[["matrixf64"],["matrixf64"],["matrixf64"],["vectorf64"],["permutation"],["i32"],["vectorf64"]],["value"]]],[5,"QRPT_solve","","This function solves the square system A x = b using the QRP^T decomposition of A held in (QR, tau, p) which must have been computed previously by QRPT_decomp.",N,[[["matrixf64"],["vectorf64"],["permutation"],["vectorf64"],["vectorf64"]],["value"]]],[5,"QRPT_svx","","This function solves the square system A x = b in-place using the QRP^T decomposition of A held in (QR,tau,p). On input x should contain the right-hand side b, which is replaced by the solution on output.",N,[[["matrixf64"],["vectorf64"],["permutation"],["vectorf64"]],["value"]]],[5,"QRPT_QRsolve","","This function solves the square system R P^T x = Q^T b for x. It can be used when the QR decomposition of a matrix is available in unpacked form as (Q, R).",N,[[["matrixf64"],["matrixf64"],["permutation"],["vectorf64"],["vectorf64"]],["value"]]],[5,"QRPT_update","","This function performs a rank-1 update w v^T of the QRP^T decomposition (Q, R, p). The update is given by Q'R' = Q (R + w v^T P) where the output matrices Q' and R' are also orthogonal and right triangular. Note that w is destroyed by the update. The permutation p is not changed.",N,[[["matrixf64"],["matrixf64"],["permutation"],["vectorf64"],["vectorf64"]],["value"]]],[5,"QRPT_Rsolve","","This function solves the triangular system R P^T x = b for the N-by-N matrix R contained in QR.",N,[[["matrixf64"],["permutation"],["vectorf64"],["vectorf64"]],["value"]]],[5,"QRPT_Rsvx","","This function solves the triangular system R P^T x = b in-place for the N-by-N matrix R contained in QR. On input x should contain the right-hand side b, which is replaced by the solution on output.",N,[[["matrixf64"],["permutation"],["vectorf64"]],["value"]]],[5,"SV_decomp","","This function factorizes the M-by-N matrix A into the singular value decomposition A = U S V^T for M >= N. On output the matrix A is replaced by U. The diagonal elements of the singular value matrix S are stored in the vector S. The singular values are non-negative and form a non-increasing sequence from S_1 to S_N. The matrix V contains the elements of V in untransposed form. To form the product U S V^T it is necessary to take the transpose of V. A workspace of length N is required in work.",N,[[["matrixf64"],["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"SV_decomp_mod","","This function computes the SVD using the modified Golub-Reinsch algorithm, which is faster for M>>N. It requires the vector work of length N and the N-by-N matrix X as additional working space.",N,[[["matrixf64"],["matrixf64"],["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"SV_decomp_jacobi","","This function computes the SVD of the M-by-N matrix A using one-sided Jacobi orthogonalization for M >= N. The Jacobi method can compute singular values to higher relative accuracy than Golub-Reinsch algorithms (see references for details).",N,[[["matrixf64"],["matrixf64"],["vectorf64"]],["value"]]],[5,"SV_solve","","This function solves the system A x = b using the singular value decomposition (U, S, V) of A which must have been computed previously with gsl_linalg_SV_decomp.",N,[[["matrixf64"],["matrixf64"],["vectorf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"SV_leverage","","This function computes the statistical leverage values h_i of a matrix A using its singular value decomposition (U, S, V) previously computed with gsl_linalg_SV_decomp. h_i are the diagonal values of the matrix A (A^T A)^{-1} A^T and depend only on the matrix U which is the input to this function.",N,[[["matrixf64"],["vectorf64"]],["value"]]],[5,"cholesky_decomp","","This function factorizes the symmetric, positive-definite square matrix A into the Cholesky decomposition A = L L^T (or A = L L^H for the complex case). On input, the values from the diagonal and lower-triangular part of the matrix A are used (the upper triangular part is ignored). On output the diagonal and lower triangular part of the input matrix A contain the matrix L, while the upper triangular part of the input matrix is overwritten with L^T (the diagonal terms being identical for both L and L^T). If the matrix is not positive-definite then the decomposition will fail, returning the error code ::Dom.",N,[[["matrixf64"]],["value"]]],[5,"complex_cholesky_decomp","","This function factorizes the symmetric, positive-definite square matrix A into the Cholesky decomposition A = L L^T (or A = L L^H for the complex case). On input, the values from the diagonal and lower-triangular part of the matrix A are used (the upper triangular part is ignored). On output the diagonal and lower triangular part of the input matrix A contain the matrix L, while the upper triangular part of the input matrix is overwritten with L^T (the diagonal terms being identical for both L and L^T). If the matrix is not positive-definite then the decomposition will fail, returning the error code ::Dom.",N,[[["matrixcomplexf64"]],["value"]]],[5,"cholesky_solve","","This function solves the system A x = b using the Cholesky decomposition of A held in the matrix cholesky which must have been previously computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp.",N,[[["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"complex_cholesky_solve","","This function solves the system A x = b using the Cholesky decomposition of A held in the matrix cholesky which must have been previously computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp.",N,[[["matrixcomplexf64"],["vectorcomplexf64"],["vectorcomplexf64"]],["value"]]],[5,"cholesky_svx","","This function solves the system A x = b in-place using the Cholesky decomposition of A held in the matrix cholesky which must have been previously computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On input x should contain the right-hand side b, which is replaced by the solution on output.",N,[[["matrixf64"],["vectorf64"]],["value"]]],[5,"complex_cholesky_svx","","This function solves the system A x = b in-place using the Cholesky decomposition of A held in the matrix cholesky which must have been previously computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On input x should contain the right-hand side b, which is replaced by the solution on output.",N,[[["matrixcomplexf64"],["vectorcomplexf64"]],["value"]]],[5,"cholesky_invert","","This function computes the inverse of a matrix from its Cholesky decomposition cholesky, which must have been previously computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On output, the inverse is stored in-place in cholesky.",N,[[["matrixf64"]],["value"]]],[5,"complex_cholesky_invert","","This function computes the inverse of a matrix from its Cholesky decomposition cholesky, which must have been previously computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On output, the inverse is stored in-place in cholesky.",N,[[["matrixcomplexf64"]],["value"]]],[5,"symmtd_decomp","","This function factorizes the symmetric square matrix A into the symmetric tridiagonal decomposition Q T Q^T. On output the diagonal and subdiagonal part of the input matrix A contain the tridiagonal matrix T. The remaining lower triangular part of the input matrix contains the Householder vectors which, together with the Householder coefficients tau, encode the orthogonal matrix Q. This storage scheme is the same as used by LAPACK. The upper triangular part of A is not referenced.",N,[[["matrixf64"],["vectorf64"]],["value"]]],[5,"symmtd_unpack","","This function unpacks the encoded symmetric tridiagonal decomposition (A, tau) obtained from gsl_linalg_symmtd_decomp into the orthogonal matrix Q, the vector of diagonal elements diag and the vector of subdiagonal elements subdiag.",N,[[["matrixf64"],["vectorf64"],["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"symmtd_unpack_T","","This function unpacks the diagonal and subdiagonal of the encoded symmetric tridiagonal decomposition (A, tau) obtained from gsl_linalg_symmtd_decomp into the vectors diag and subdiag.",N,[[["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"hermtd_decomp","","This function factorizes the hermitian matrix A into the symmetric tridiagonal decomposition U T U^T. On output the real parts of the diagonal and subdiagonal part of the input matrix A contain the tridiagonal matrix T. The remaining lower triangular part of the input matrix contains the Householder vectors which, together with the Householder coefficients tau, encode the unitary matrix U. This storage scheme is the same as used by LAPACK. The upper triangular part of A and imaginary parts of the diagonal are not referenced.",N,[[["matrixcomplexf64"],["vectorcomplexf64"]],["value"]]],[5,"hermtd_unpack","","This function unpacks the encoded tridiagonal decomposition (A, tau) obtained from gsl_linalg_hermtd_decomp into the unitary matrix U, the real vector of diagonal elements diag and the real vector of subdiagonal elements subdiag.",N,[[["matrixcomplexf64"],["vectorcomplexf64"],["matrixcomplexf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"hermtd_unpack_T","","This function unpacks the diagonal and subdiagonal of the encoded tridiagonal decomposition (A, tau) obtained from the gsl_linalg_hermtd_decomp into the real vectors diag and subdiag.",N,[[["matrixcomplexf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"hessenberg_decomp","","This function computes the Hessenberg decomposition of the matrix A by applying the similarity transformation H = U^T A U. On output, H is stored in the upper portion of A. The information required to construct the matrix U is stored in the lower triangular portion of A. U is a product of N - 2 Householder matrices. The Householder vectors are stored in the lower portion of A (below the subdiagonal) and the Householder coefficients are stored in the vector tau. tau must be of length N.",N,[[["matrixf64"],["vectorf64"]],["value"]]],[5,"hessenberg_unpack","","This function constructs the orthogonal matrix U from the information stored in the Hessenberg matrix H along with the vector tau. H and tau are outputs from gsl_linalg_hessenberg_decomp.",N,[[["matrixf64"],["vectorf64"],["matrixf64"]],["value"]]],[5,"hessenberg_unpack_accum","","This function is similar to gsl_linalg_hessenberg_unpack, except it accumulates the matrix U into V, so that V' = VU. The matrix V must be initialized prior to calling this function. Setting V to the identity matrix provides the same result as gsl_linalg_hessenberg_unpack. If H is order N, then V must have N columns but may have any number of rows.",N,[[["matrixf64"],["vectorf64"],["matrixf64"]],["value"]]],[5,"hessenberg_set_zero","","This function sets the lower triangular portion of H, below the subdiagonal, to zero. It is useful for clearing out the Householder vectors after calling gsl_linalg_hessenberg_decomp.",N,[[["matrixf64"]],["value"]]],[5,"hesstri_decomp","","This function computes the Hessenberg-Triangular decomposition of the matrix pair (A, B). On output, H is stored in A, and R is stored in B. If U and V are provided (they may be null), the similarity transformations are stored in them. Additional workspace of length N is needed in work.",N,[[["matrixf64"],["matrixf64"],["matrixf64"],["matrixf64"],["vectorf64"]],["value"]]],[5,"bidiag_decomp","","This function factorizes the M-by-N matrix A into bidiagonal form U B V^T. The diagonal and superdiagonal of the matrix B are stored in the diagonal and superdiagonal of A. The orthogonal matrices U and V are stored as compressed Householder vectors in the remaining elements of A. The Householder coefficients are stored in the vectors tau_U and tau_V. The length of tau_U must equal the number of elements in the diagonal of A and the length of tau_V should be one element shorter.",N,[[["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"bidiag_unpack","","This function unpacks the bidiagonal decomposition of A produced by gsl_linalg_bidiag_decomp, (A, tau_U, tau_V) into the separate orthogonal matrices U, V and the diagonal vector diag and superdiagonal superdiag. Note that U is stored as a compact M-by-N orthogonal matrix satisfying U^T U = I for efficiency.",N,[[["matrixf64"],["vectorf64"],["matrixf64"],["vectorf64"],["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"bidiag_unpack2","","This function unpacks the bidiagonal decomposition of A produced by gsl_linalg_bidiag_decomp, (A, tau_U, tau_V) into the separate orthogonal matrices U, V and the diagonal vector diag and superdiagonal superdiag. The matrix U is stored in-place in A.",N,[[["matrixf64"],["vectorf64"],["vectorf64"],["matrixf64"]],["value"]]],[5,"bidiag_unpack_B","","This function unpacks the diagonal and superdiagonal of the bidiagonal decomposition of A from gsl_linalg_bidiag_decomp, into the diagonal vector diag and superdiagonal vector superdiag.",N,[[["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"householder_transform","","This function prepares a Householder transformation P = I - \\tau v v^T which can be used to zero all the elements of the input vector except the first. On output the transformation is stored in the vector v and the scalar \\tau is returned.",N,[[["vectorf64"]],["f64"]]],[5,"complex_householder_transform","","This function prepares a Householder transformation P = I - \\tau v v^T which can be used to zero all the elements of the input vector except the first. On output the transformation is stored in the vector v and the scalar \\tau is returned.",N,[[["vectorcomplexf64"]],["complexf64"]]],[5,"householder_hm","","This function applies the Householder matrix P defined by the scalar tau and the vector v to the left-hand side of the matrix A. On output the result P A is stored in A.",N,[[["f64"],["vectorf64"],["matrixf64"]],["value"]]],[5,"complex_householder_hm","","This function applies the Householder matrix P defined by the scalar tau and the vector v to the left-hand side of the matrix A. On output the result P A is stored in A.",N,[[["complexf64"],["vectorcomplexf64"],["matrixcomplexf64"]],["value"]]],[5,"householder_mh","","This function applies the Householder matrix P defined by the scalar tau and the vector v to the right-hand side of the matrix A. On output the result A P is stored in A.",N,[[["f64"],["vectorf64"],["matrixf64"]],["value"]]],[5,"complex_householder_mh","","This function applies the Householder matrix P defined by the scalar tau and the vector v to the right-hand side of the matrix A. On output the result A P is stored in A.",N,[[["complexf64"],["vectorcomplexf64"],["matrixcomplexf64"]],["value"]]],[5,"householder_hv","","This function applies the Householder transformation P defined by the scalar tau and the vector v to the vector w. On output the result P w is stored in w.",N,[[["f64"],["vectorf64"],["matrixf64"]],["value"]]],[5,"complex_householder_hv","","This function applies the Householder transformation P defined by the scalar tau and the vector v to the vector w. On output the result P w is stored in w.",N,[[["complexf64"],["vectorcomplexf64"],["matrixcomplexf64"]],["value"]]],[5,"HH_solve","","This function solves the system A x = b directly using Householder transformations. On output the solution is stored in x and b is not modified. The matrix A is destroyed by the Householder transformations.",N,[[["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"HH_svx","","This function solves the system A x = b in-place using Householder transformations. On input x should contain the right-hand side b, which is replaced by the solution on output. The matrix A is destroyed by the Householder transformations.",N,[[["matrixf64"],["vectorf64"]],["value"]]],[5,"solve_tridiag","","This function solves the general N-by-N system A x = b where A is tridiagonal (N >= 2). The super-diagonal and sub-diagonal vectors e and f must be one element shorter than the diagonal vector diag. The form of A for the 4-by-4 case is shown below,",N,[[["vectorf64"],["vectorf64"],["vectorf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"solve_symm_tridiag","","This function solves the general N-by-N system A x = b where A is symmetric tridiagonal (N >= 2). The off-diagonal vector e must be one element shorter than the diagonal vector diag. The form of A for the 4-by-4 case is shown below,",N,[[["vectorf64"],["vectorf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"solve_cyc_tridiag","","This function solves the general N-by-N system A x = b where A is cyclic tridiagonal (N >= 3). The cyclic super-diagonal and sub-diagonal vectors e and f must have the same number of elements as the diagonal vector diag. The form of A for the 4-by-4 case is shown below,",N,[[["vectorf64"],["vectorf64"],["vectorf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"solve_symm_cyc_tridiag","","This function solves the general N-by-N system A x = b where A is symmetric cyclic tridiagonal (N >= 3). The cyclic off-diagonal vector e must have the same number of elements as the diagonal vector diag. The form of A for the 4-by-4 case is shown below,",N,[[["vectorf64"],["vectorf64"],["vectorf64"],["vectorf64"]],["value"]]],[5,"balance_matrix","","This function replaces the matrix A with its balanced counterpart and stores the diagonal elements of the similarity transformation into the vector D.",N,[[["matrixf64"],["vectorf64"]],["value"]]],[0,"logarithm","rgsl","Information on the properties of the Logarithm function can be found in Abramowitz & Stegun, Chapter 4.",N,N],[5,"log","rgsl::logarithm","This routine computes the logarithm of x, \\log(x), for x > 0.",N,[[["f64"]],["f64"]]],[5,"log_e","","This routine computes the logarithm of x, \\log(x), for x > 0.",N,N],[5,"log_abs","","This routine computes the logarithm of the magnitude of x, \\log(|x|), for x \\ne 0.",N,[[["f64"]],["f64"]]],[5,"log_abs_e","","This routine computes the logarithm of the magnitude of x, \\log(|x|), for x \\ne 0.",N,N],[5,"complex_log_e","","This routine computes the complex logarithm of z = z_r + i z_i. The results are returned as lnr, theta such that \\exp(lnr + i \\theta) = z_r + i z_i, where \\theta lies in the range [-\\pi,\\pi].",N,N],[5,"log_1plusx","","This routine computes \\log(1 + x) for x > -1 using an algorithm that is accurate for small x.",N,[[["f64"]],["f64"]]],[5,"log_1plusx_e","","This routine computes \\log(1 + x) for x > -1 using an algorithm that is accurate for small x.",N,N],[5,"log_1plusx_mx","","This routine computes \\log(1 + x) - x for x > -1 using an algorithm that is accurate for small x.",N,[[["f64"]],["f64"]]],[5,"log_1plusx_mx_e","","This routine computes \\log(1 + x) - x for x > -1 using an algorithm that is accurate for small x.",N,N],[0,"minimizer","rgsl","",N,N],[5,"test_interval","rgsl::minimizer","This function tests for the convergence of the interval [x_lower, x_upper] with absolute error epsabs and relative error epsrel. The  test returns ::Value::Success if the following condition is achieved,",N,[[["f64"],["f64"],["f64"],["f64"]],["value"]]],[0,"multifit","rgsl","",N,N],[5,"covar","rgsl::multifit","Compute the covariance matrix cov = inv (J^T J) by QRP^T decomposition of J",N,[[["matrixf64"],["f64"],["matrixf64"]],["value"]]],[5,"test_delta","","",N,[[["vectorf64"],["vectorf64"],["f64"],["f64"]],["value"]]],[5,"gradient","","",N,[[["matrixf64"],["vectorf64"],["vectorf64"]],["value"]]],[0,"numerical_differentiation","rgsl","#Numerical Differentiation",N,N],[5,"deriv_central","rgsl::numerical_differentiation","This function computes the numerical derivative of the function f at the point x using an adaptive central difference algorithm with a step-size of h. The derivative is returned in result and an estimate of its absolute error is returned in abserr.",N,[[["function"],["t"],["f64"],["f64"],["f64"],["f64"]],["value"]]],[5,"deriv_forward","","This function computes the numerical derivative of the function f at the point x using an adaptive forward difference algorithm with a step-size of h. The function is evaluated only at points greater than x, and never at x itself. The derivative is returned in result and an estimate of its absolute error is returned in abserr. This function should be used if f(x) has a discontinuity at x, or is undefined for values less than x.",N,[[["function"],["t"],["f64"],["f64"],["f64"],["f64"]],["value"]]],[5,"deriv_backward","","This function computes the numerical derivative of the function f at the point x using an adaptive backward difference algorithm with a step-size of h. The function is evaluated only at points less than x, and never at x itself. The derivative is returned in result and an estimate of its absolute error is returned in abserr. This function should be used if f(x) has a discontinuity at x, or is undefined for values greater than x.",N,[[["function"],["t"],["f64"],["f64"],["f64"],["f64"]],["value"]]],[0,"physical_constant","rgsl","Physical Constants",N,N],[7,"MKSA_SPEED_OF_LIGHT","rgsl::physical_constant","The speed of light in vacuum, c. m / s",N,N],[7,"MKSA_VACUUM_PERMEABILITY","","The permeability of free space, \\mu_0. This constant is defined in the MKSA system only. `kg m / A^2 s^2`",N,N],[7,"MKSA_VACUUM_PERMITTIVITY","","The permittivity of free space, \\epsilon_0. This constant is defined in the MKSA system only. `A^2 s^4 / kg m^3`",N,N],[7,"MKSA_PLANCKS_CONSTANT_H","","Plancks constant, h. kg m^2 / s",N,N],[7,"MKSA_PLANCKS_CONSTANT_HBAR","","Plancks constant divided by 2\\pi, \\hbar. kg m^2 / s",N,N],[7,"NUM_AVOGADRO","","Avogadros number, N_a. 1 / mol",N,N],[7,"MKSA_FARADAY","","The molar charge of 1 Faraday. A s / mol",N,N],[7,"MKSA_BOLTZMANN","","The Boltzmann constant, k. kg m^2 / K s^2",N,N],[7,"MKSA_MOLAR_GAS","","The molar gas constant, R_0. kg m^2 / K mol s^2",N,N],[7,"MKSA_STANDARD_GAS_VOLUME","","The standard gas volume, V_0. m^3 / mol",N,N],[7,"MKSA_STEFAN_BOLTZMANN_CONSTANT","","The Stefan-Boltzmann radiation constant, \\sigma. kg / K^4 s^3",N,N],[7,"MKSA_GAUSS","","The magnetic field of 1 Gauss. kg / A s^2",N,N],[7,"MKSA_ASTRONOMICAL_UNIT","","The length of 1 astronomical unit (mean earth-sun distance), au. m",N,N],[7,"MKSA_GRAVITATIONAL_CONSTANT","","The gravitational constant, G. m^3 / kg s^2",N,N],[7,"MKSA_LIGHT_YEAR","","The distance of 1 light-year, ly. m",N,N],[7,"MKSA_PARSEC","","The distance of 1 parsec, pc. m",N,N],[7,"MKSA_GRAV_ACCEL","","The standard gravitational acceleration on Earth, g. m / s^2",N,N],[7,"MKSA_SOLAR_MASS","","The mass of the Sun. kg",N,N],[7,"MKSA_ELECTRON_CHARGE","","The charge of the electron, e. A s",N,N],[7,"MKSA_ELECTRON_VOLT","","The energy of 1 electron volt, eV. kg m^2 / s^2",N,N],[7,"MKSA_UNIFIED_ATOMIC_MASS","","The unified atomic mass, amu. kg",N,N],[7,"MKSA_MASS_ELECTRON","","The mass of the electron, m_e. kg",N,N],[7,"MKSA_MASS_MUON","","The mass of the muon, m_\\mu. kg",N,N],[7,"MKSA_MASS_PROTON","","The mass of the proton, m_p. kg",N,N],[7,"MKSA_MASS_NEUTRON","","The mass of the neutron, m_n. kg",N,N],[7,"NUM_FINE_STRUCTURE","","The electromagnetic fine structure constant \\alpha. 1",N,N],[7,"MKSA_RYDBERG","","The Rydberg constant, Ry, in units of energy. This is related to the Rydberg inverse wavelength `R_\\infty by Ry = h c R_\\infty. kg m^2 / s^2`",N,N],[7,"MKSA_BOHR_RADIUS","","The Bohr radius, a_0. m",N,N],[7,"MKSA_ANGSTROM","","The length of 1 angstrom. m",N,N],[7,"MKSA_BARN","","The area of 1 barn. m^2",N,N],[7,"MKSA_BOHR_MAGNETON","","The Bohr Magneton, \\mu_B. A m^2",N,N],[7,"MKSA_NUCLEAR_MAGNETON","","The Nuclear Magneton, \\mu_N. A m^2",N,N],[7,"MKSA_ELECTRON_MAGNETIC_MOMENT","","The absolute value of the magnetic moment of the electron, \\mu_e. The physical magnetic moment of the electron is negative. A m^2",N,N],[7,"MKSA_PROTON_MAGNETIC_MOMENT","","The magnetic moment of the proton, \\mu_p. A m^2",N,N],[7,"MKSA_THOMSON_CROSS_SECTION","","The Thomson cross section, \\sigma_T. m^2",N,N],[7,"MKSA_DEBYE","","The electric dipole moment of 1 Debye, D. A s^2 / m^2",N,N],[7,"MKSA_MINUTE","","The number of seconds in 1 minute. s",N,N],[7,"MKSA_HOUR","","The number of seconds in 1 hour. s",N,N],[7,"MKSA_DAY","","The number of seconds in 1 day. s",N,N],[7,"MKSA_WEEK","","The number of seconds in 1 week. s",N,N],[7,"MKSA_INCH","","The length of 1 inch. m",N,N],[7,"MKSA_FOOT","","The length of 1 foot. m",N,N],[7,"MKSA_YARD","","The length of 1 yard. m",N,N],[7,"MKSA_MILE","","The length of 1 mile. m",N,N],[7,"MKSA_MIL","","The length of 1 mil (1/1000th of an inch). m",N,N],[7,"MKSA_KILOMETERS_PER_HOUR","","The speed of 1 kilometer per hour. m / s",N,N],[7,"MKSA_MILES_PER_HOUR","","The speed of 1 mile per hour. m / s",N,N],[7,"MKSA_NAUTICAL_MILE","","The length of 1 nautical mile. m",N,N],[7,"MKSA_FATHOM","","The length of 1 fathom. m",N,N],[7,"MKSA_KNOT","","The speed of 1 knot. m / s",N,N],[7,"MKSA_POINT","","The length of 1 printers point (1/72 inch). m",N,N],[7,"MKSA_TEXPOINT","","The length of 1 TeX point (1/72.27 inch). m",N,N],[7,"MKSA_MICRON","","The length of 1 micron. m",N,N],[7,"MKSA_HECTARE","","The area of 1 hectare. m^2",N,N],[7,"MKSA_ACRE","","The area of 1 acre. m^2",N,N],[7,"MKSA_LITER","","The volume of 1 liter. m^3",N,N],[7,"MKSA_US_GALLON","","The volume of 1 US gallon. m^3",N,N],[7,"MKSA_CANADIAN_GALLON","","The volume of 1 Canadian gallon. m^3",N,N],[7,"MKSA_UK_GALLON","","The volume of 1 UK gallon. m^3",N,N],[7,"MKSA_QUART","","The volume of 1 quart. m^3",N,N],[7,"MKSA_PINT","","The volume of 1 pint. m^3",N,N],[7,"MKSA_CUP","","m^3",N,N],[7,"MKSA_POUND_MASS","","The mass of 1 pound. kg",N,N],[7,"MKSA_OUNCE_MASS","","The mass of 1 ounce. kg",N,N],[7,"MKSA_TON","","The mass of 1 ton. kg",N,N],[7,"MKSA_METRIC_TON","","The mass of 1 metric ton (1000 kg). kg",N,N],[7,"MKSA_UK_TON","","The mass of 1 UK ton. kg",N,N],[7,"MKSA_TROY_OUNCE","","The mass of 1 troy ounce. kg",N,N],[7,"MKSA_CARAT","","The mass of 1 carat. kg",N,N],[7,"MKSA_GRAM_FORCE","","The force of 1 gram weight. kg m / s^2",N,N],[7,"MKSA_POUND_FORCE","","The force of 1 pound weight. kg m / s^2",N,N],[7,"MKSA_KILOPOUND_FORCE","","The force of 1 kilopound weight. kg m / s^2",N,N],[7,"MKSA_POUNDAL","","The force of 1 poundal. kg m / s^2",N,N],[7,"MKSA_CALORIE","","The energy of 1 calorie. kg m^2 / s^2",N,N],[7,"MKSA_BTU","","The energy of 1 British Thermal Unit, btu. kg m^2 / s^2",N,N],[7,"MKSA_THERM","","The energy of 1 Therm. kg m^2 / s^2",N,N],[7,"MKSA_HORSEPOWER","","The power of 1 horsepower. kg m^2 / s^3",N,N],[7,"MKSA_BAR","","The pressure of 1 bar. kg / m s^2",N,N],[7,"MKSA_STD_ATMOSPHERE","","The pressure of 1 standard atmosphere. kg / m s^2",N,N],[7,"MKSA_TORR","","The pressure of 1 torr. kg / m s^2",N,N],[7,"MKSA_METER_OF_MERCURY","","The pressure of 1 meter of mercury. kg / m s^2",N,N],[7,"MKSA_INCH_OF_MERCURY","","The pressure of 1 inch of mercury. kg / m s^2",N,N],[7,"MKSA_INCH_OF_WATER","","The pressure of 1 inch of water. kg / m s^2",N,N],[7,"MKSA_PSI","","The pressure of 1 pound per square inch. kg / m s^2",N,N],[7,"MKSA_POISE","","The dynamic viscosity of 1 poise. kg m^-1 s^-1",N,N],[7,"MKSA_STOKES","","The kinematic viscosity of 1 stokes. m^2 / s",N,N],[7,"MKSA_STILB","","The luminance of 1 stilb. cd / m^2",N,N],[7,"MKSA_LUMEN","","The luminous flux of 1 lumen. cd sr",N,N],[7,"MKSA_LUX","","The illuminance of 1 lux. cd sr / m^2",N,N],[7,"MKSA_PHOT","","The illuminance of 1 phot. cd sr / m^2",N,N],[7,"MKSA_FOOTCANDLE","","The illuminance of 1 footcandle. cd sr / m^2",N,N],[7,"MKSA_LAMBERT","","The luminance of 1 lambert. cd sr / m^2",N,N],[7,"MKSA_FOOTLAMBERT","","The luminance of 1 footlambert. cd sr / m^2",N,N],[7,"MKSA_CURIE","","The activity of 1 curie. 1 / s",N,N],[7,"MKSA_ROENTGEN","","The exposure of 1 roentgen. A s / kg",N,N],[7,"MKSA_RAD","","The absorbed dose of 1 rad. m^2 / s^2",N,N],[7,"MKSA_NEWTON","","The SI unit of force, 1 Newton. kg m / s^2",N,N],[7,"MKSA_DYNE","","The force of 1 Dyne = 10^-5 Newton. kg m / s^2",N,N],[7,"MKSA_JOULE","","The SI unit of energy, 1 Joule. kg m^2 / s^2",N,N],[7,"MKSA_ERG","","The energy 1 erg = 10^-7 Joule. kg m^2 / s^2",N,N],[7,"NUM_YOTTA","","10^24",N,N],[7,"NUM_ZETTA","","10^21",N,N],[7,"NUM_EXA","","10^18",N,N],[7,"NUM_PETA","","10^15",N,N],[7,"NUM_TERA","","10^12",N,N],[7,"NUM_GIGA","","10^9",N,N],[7,"NUM_MEGA","","10^6",N,N],[7,"NUM_KILO","","10^3",N,N],[7,"NUM_MILLI","","10^-3",N,N],[7,"NUM_MICRO","","10^-6",N,N],[7,"NUM_NANO","","10^-9",N,N],[7,"NUM_PICO","","10^-12",N,N],[7,"NUM_FEMTO","","10^-15",N,N],[7,"NUM_ATTO","","10^-18",N,N],[7,"NUM_ZEPTO","","10^-21",N,N],[7,"NUM_YOCTO","","10^-24",N,N],[0,"polynomials","rgsl","#Polynomials",N,N],[0,"evaluation","rgsl::polynomials","The functions described here evaluate the polynomial `P(x) = c[0] + c[1] x + c[2] x^2 + \\dots + c[len-1] x^{len-1}` using Horners method for stability.",N,N],[5,"poly_eval","rgsl::polynomials::evaluation","This function evaluates a polynomial with real coefficients for the real variable x.",N,N],[5,"poly_complex_eval","","This function evaluates a polynomial with real coefficients for the complex variable z.",N,N],[5,"complex_poly_complex_eval","","This function evaluates a polynomial with complex coefficients for the complex variable z.",N,N],[5,"poly_eval_derivs","","This function evaluates a polynomial and its derivatives storing the results in the array res of size lenres. The output array contains the values of d^k P/d x^k for the specified value of x starting with k = 0.",N,N],[0,"divided_difference_representation","rgsl::polynomials","The functions described here manipulate polynomials stored in Newtons divided-difference representation. The use of divided-differences is described in Abramowitz & Stegun sections 25.1.4 and 25.2.26, and Burden and Faires, chapter 3, and discussed briefly below.",N,N],[5,"poly_dd_init","rgsl::polynomials::divided_difference_representation","This function computes a divided-difference representation of the interpolating polynomial for the points (x, y) stored in the arrays xa and ya of length size. On output the divided-differences of (xa,ya) are stored in the array dd, also of length size. Using the notation above, dd[k] = [x_0,x_1,...,x_k].",N,N],[5,"poly_dd_eval","","This function evaluates the polynomial stored in divided-difference form in the arrays dd and xa of length size at the point x.",N,N],[5,"poly_dd_taylor","","This function converts the divided-difference representation of a polynomial to a Taylor expansion. The divided-difference representation is supplied in the arrays dd and xa of length size. On output the Taylor coefficients of the polynomial expanded about the point xp are stored in the array c also of length size. A workspace of length size must be provided in the array w.",N,N],[5,"poly_dd_hermite_init","","This function computes a divided-difference representation of the interpolating Hermite polynomial for the points (x, y) stored in the arrays xa and ya of length size. Hermite interpolation constructs polynomials which also match first derivatives dy/dx which are provided in the array dya also of length size. The first derivatives can be incorported into the usual divided-difference algorithm by forming a new dataset z = {x_0,x_0,x_1,x_1,...}, which is stored in the array za of length 2size on output. On output the divided-differences of the Hermite representation are stored in the array dd, also of length 2size. Using the notation above, dd[k] = [z_0,z_1,...,z_k]. The resulting Hermite polynomial can be evaluated by calling gsl_poly_dd_eval and using za for the input argument xa.",N,N],[0,"quadratic_equations","rgsl::polynomials","",N,N],[5,"poly_solve_quadratic","rgsl::polynomials::quadratic_equations","This function finds the real roots of the quadratic equation,",N,[[["f64"],["f64"],["f64"],["f64"],["f64"]],["i32"]]],[5,"poly_complex_solve_quadratic","","This function finds the complex roots of the quadratic equation,",N,[[["f64"],["f64"],["f64"],["complexf64"],["complexf64"]],["i32"]]],[0,"cubic_equations","rgsl::polynomials","",N,N],[5,"poly_solve_cubic","rgsl::polynomials::cubic_equations","This function finds the real roots of the cubic equation,",N,[[["f64"],["f64"],["f64"],["f64"],["f64"],["f64"]],["i32"]]],[5,"poly_complex_solve_cubic","","This function finds the complex roots of the cubic equation,",N,[[["f64"],["f64"],["f64"],["complexf64"],["complexf64"],["complexf64"]],["i32"]]],[0,"pow","rgsl","",N,N],[8,"Pow","rgsl::pow","",N,N],[10,"pow_int","","This routine computes the power x^n for integer n. The power is computed efficientlyfor example, x^8 is computed as ((x^2)^2)^2, requiring only 3 multiplications. A version of this function which also computes the numerical error in the result is available as gsl_sf_pow_int_e.",107,[[["self"],["i32"]],["self"]]],[10,"pow_uint","","This routine computes the power x^n for integer n. The power is computed efficientlyfor example, x^8 is computed as ((x^2)^2)^2, requiring only 3 multiplications. A version of this function which also computes the numerical error in the result is available as gsl_sf_pow_int_e.",107,[[["self"],["u32"]],["self"]]],[10,"pow2","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",107,[[["self"]],["self"]]],[10,"pow3","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",107,[[["self"]],["self"]]],[10,"pow4","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",107,[[["self"]],["self"]]],[10,"pow5","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",107,[[["self"]],["self"]]],[10,"pow6","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",107,[[["self"]],["self"]]],[10,"pow7","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",107,[[["self"]],["self"]]],[10,"pow8","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",107,[[["self"]],["self"]]],[10,"pow9","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",107,[[["self"]],["self"]]],[0,"power","rgsl","The following functions are equivalent to the function gsl_pow_int (see 1Small integer powers1) with an error estimate.",N,N],[5,"pow_int","rgsl::power","This routine computes the power x^n for integer n. The power is computed using the minimum number of multiplications. For example, x^8 is computed as ((x^2)^2)^2, requiring only 3 multiplications. For reasons of efficiency, these functions do not check for overflow or underflow conditions.",N,[[["f64"],["i32"]],["f64"]]],[5,"pow_int_e","","This routine computes the power x^n for integer n. The power is computed using the minimum number of multiplications. For example, x^8 is computed as ((x^2)^2)^2, requiring only 3 multiplications. For reasons of efficiency, these functions do not check for overflow or underflow conditions.",N,N],[0,"psi","rgsl","The polygamma functions of order n are defined by",N,N],[0,"diagamma","rgsl::psi","",N,N],[5,"psi_int","rgsl::psi::diagamma","This routine computes the digamma function \\psi(n) for positive integer n. The digamma function is also called the Psi function.",N,[[["i32"]],["f64"]]],[5,"psi_int_e","","This routine computes the digamma function \\psi(n) for positive integer n. The digamma function is also called the Psi function.",N,N],[5,"psi","","This routine computes the digamma function \\psi(x) for general x, x \\ne 0.",N,[[["f64"]],["f64"]]],[5,"psi_e","","This routine computes the digamma function \\psi(x) for general x, x \\ne 0.",N,N],[5,"psi_1piy","","This routine computes the real part of the digamma function on the line 1+i y, \\Re[\\psi(1 + i y)].",N,[[["f64"]],["f64"]]],[5,"psi_1piy_e","","This routine computes the real part of the digamma function on the line 1+i y, \\Re[\\psi(1 + i y)].",N,N],[0,"trigamma","rgsl::psi","",N,N],[5,"psi_1_int","rgsl::psi::trigamma","This routine computes the Trigamma function \\psi'(n) for positive integer n.",N,[[["i32"]],["f64"]]],[5,"psi_1_int_e","","This routine computes the Trigamma function \\psi'(n) for positive integer n.",N,N],[5,"psi_1","","This routine computes the Trigamma function \\psi'(x) for general x.",N,[[["f64"]],["f64"]]],[5,"psi_1_e","","This routine computes the Trigamma function \\psi'(x) for general x.",N,N],[0,"polygamma","rgsl::psi","",N,N],[5,"psi_n","rgsl::psi::polygamma","This routine computes the polygamma function \\psi^{(n)}(x) for n >= 0, x > 0.",N,[[["i32"],["f64"]],["f64"]]],[5,"psi_n_e","","This routine computes the polygamma function \\psi^{(n)}(x) for n >= 0, x > 0.",N,N],[0,"roots","rgsl","",N,N],[5,"test_interval","rgsl::roots","",N,[[["f64"],["f64"],["f64"],["f64"]],["value"]]],[5,"test_residual","","",N,[[["f64"],["f64"]],["value"]]],[5,"test_delta","","",N,[[["f64"],["f64"],["f64"],["f64"]],["value"]]],[0,"sort","rgsl","#Sorting",N,N],[0,"objects","rgsl::sort","The following function provides a simple alternative to the standard library function qsort. It is intended for systems lacking qsort, not as a replacement for it. The function qsort should be used whenever possible, as it will be faster and can provide stable ordering of equal elements. Documentation for qsort is available in the GNU C Library Reference Manual.",N,N],[5,"heapsort","rgsl::sort::objects","This function sorts the count elements of the array array, each of size size, into ascending order using the comparison function compare. The type of the comparison function is defined by,",N,N],[5,"heapsort_index","","This function indirectly sorts the count elements of the array array, each of size size, into ascending order using the comparison function compare. The resulting permutation is stored in p, an array of length n. The elements of p give the index of the array element which would have been stored in that position if the array had been sorted in place. The first element of p gives the index of the least element in array, and the last element of p gives the index of the greatest element in array. The array itself is not changed.",N,N],[0,"vectors","rgsl::sort","The following functions will sort the elements of an array or vector, either directly or indirectly. They are defined for all real and integer types using the normal suffix rules. For example, the float versions of the array functions are gsl_sort_float and gsl_sort_float_index. The corresponding vector functions are gsl_sort_vector_float and gsl_sort_vector_float_index. The prototypes are available in the header files gsl_sort_float.h gsl_sort_vector_float.h. The complete set of prototypes can be included using the header files gsl_sort.h and gsl_sort_vector.h.",N,N],[5,"sort","rgsl::sort::vectors","This function sorts the n elements of the array data with stride stride into ascending numerical order.",N,N],[5,"sort2","","This function sorts the n elements of the array data1 with stride stride1 into ascending numerical order, while making the same rearrangement of the array data2 with stride stride2, also of size n.",N,N],[5,"sort_vector","","This function sorts the elements of the vector v into ascending numerical order.",N,[[["vectorf64"]]]],[5,"sort_vector2","","This function sorts the elements of the vector v1 into ascending numerical order, while making the same rearrangement of the vector v2.",N,[[["vectorf64"],["vectorf64"]]]],[5,"sort_index","","This function indirectly sorts the n elements of the array data with stride stride into ascending order, storing the resulting permutation in p. The array p must be allocated with a sufficient length to store the n elements of the permutation. The elements of p give the index of the array element which would have been stored in that position if the array had been sorted in place. The array data is not changed.",N,N],[5,"sort_vector_index","","This function indirectly sorts the elements of the vector v into ascending order, storing the resulting permutation in p. The elements of p give the index of the vector element which would have been stored in that position if the vector had been sorted in place. The first element of p gives the index of the least element in v, and the last element of p gives the index of the greatest element in v. The vector v is not changed.",N,[[["permutation"],["vectorf64"]],["value"]]],[0,"select","rgsl::sort","The functions described in this section select the k smallest or largest elements of a data set of size N. The routines use an O(kN) direct insertion algorithm which is suited to subsets that are small compared with the total size of the dataset. For example, the routines are useful for selecting the 10 largest values from one million data points, but not for selecting the largest 100,000 values. If the subset is a significant part of the total dataset it may be faster to sort all the elements of the dataset directly with an O(N \\log N) algorithm and obtain the smallest or largest values that way.",N,N],[5,"sort_smallest","rgsl::sort::select","This function copies the k smallest elements of the array src, of size n and stride stride, in ascending numerical order into the array dest. The size k of the subset must be less than or equal to n. The data src is not modified by this operation.",N,N],[5,"sort_largest","","This function copies the k largest elements of the array src, of size n and stride stride, in descending numerical order into the array dest. k must be less than or equal to n. The data src is not modified by this operation.",N,N],[5,"sort_vector_smallest","","This function copies the k smallest or largest elements of the vector v into the array dest. k must be less than or equal to the length of the vector v.",N,N],[5,"sort_vector_largest","","This function copies the k smallest or largest elements of the vector v into the array dest. k must be less than or equal to the length of the vector v.",N,N],[5,"sort_smallest_index","","This function stores the indices of the k smallest elements of the array src, of size n and stride stride, in the array p. The indices are chosen so that the corresponding data is in ascending numerical order. k must be less than or equal to n. The data src is not modified by this operation.",N,N],[5,"sort_largest_index","","This function stores the indices of the k largest elements of the array src, of size n and stride stride, in the array p. The indices are chosen so that the corresponding data is in descending numerical order. k must be less than or equal to n. The data src is not modified by this operation.",N,N],[5,"sort_vector_smallest_index","","This function stores the indices of the k smallest or largest elements of the vector v in the array p. k must be less than or equal to the length of the vector v.",N,N],[5,"sort_vector_largest_index","","This function stores the indices of the k smallest or largest elements of the vector v in the array p. k must be less than or equal to the length of the vector v.",N,N],[0,"statistics","rgsl","#Statistics",N,N],[5,"mean","rgsl::statistics","This function returns the arithmetic mean of data, a dataset of length n with stride stride. The arithmetic mean, or sample mean, is denoted by \\Hat\\mu and defined as,",N,N],[5,"variance","","This function returns the estimated, or sample, variance of data, a dataset of length n with stride stride. The estimated variance is denoted by \\Hat\\sigma^2 and is defined by,",N,N],[5,"variance_m","","This function returns the sample variance of data relative to the given value of mean. The function is computed with \\Hat\\mu replaced by the value of mean that you supply,",N,N],[5,"sd","","The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding variance functions above.",N,N],[5,"sd_m","","The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding variance functions above.",N,N],[5,"tss","","This function returns the total sum of squares (TSS) of data about the mean. For gsl_stats_tss_m the user-supplied value of mean is used, and for gsl_stats_tss it is computed using gsl_stats_mean.",N,N],[5,"tss_m","","This function returns the total sum of squares (TSS) of data about the mean. For gsl_stats_tss_m the user-supplied value of mean is used, and for gsl_stats_tss it is computed using gsl_stats_mean.",N,N],[5,"variance_with_fixed_mean","","This function computes an unbiased estimate of the variance of data when the population mean mean of the underlying distribution is known a priori. In this case the estimator for the variance uses the factor 1/N and the sample mean \\Hat\\mu is replaced by the known population mean \\mu,",N,N],[5,"sd_with_fixed_mean","","This function calculates the standard deviation of data for a fixed population mean mean. The result is the square root of the corresponding variance function.",N,N],[5,"absdev","","This function computes the absolute deviation from the mean of data, a dataset of length n with stride stride. The absolute deviation from the mean is defined as,",N,N],[5,"absdev_m","","This function computes the absolute deviation of the dataset data relative to the given value of mean,",N,N],[5,"skew","","This function computes the skewness of data, a dataset of length n with stride stride. The skewness is defined as,",N,N],[5,"skew_m_sd","","This function computes the skewness of the dataset data using the given values of the mean mean and standard deviation sd,",N,N],[5,"kurtosis","","This function computes the kurtosis of data, a dataset of length n with stride stride. The kurtosis is defined as,",N,N],[5,"kurtosis_m_sd","","This function computes the kurtosis of the dataset data using the given values of the mean mean and standard deviation sd,",N,N],[5,"lag1_autocorrelation","","This function computes the lag-1 autocorrelation of the dataset data.",N,N],[5,"lag1_autocorrelation_m","","This function computes the lag-1 autocorrelation of the dataset data using the given value of the mean mean.",N,N],[5,"covariance","","This function computes the covariance of the datasets data1 and data2 which must both be of the same length n.",N,N],[5,"covariance_m","","This function computes the covariance of the datasets data1 and data2 using the given values of the means, mean1 and mean2. This is useful if you have already computed the means of data1 and data2 and want to avoid recomputing them.",N,N],[5,"correlation","","This function efficiently computes the Pearson correlation coefficient between the datasets data1 and data2 which must both be of the same length n.",N,N],[5,"spearman","","This function computes the Spearman rank correlation coefficient between the datasets data1 and data2 which must both be of the same length n. Additional workspace of size 2*n is required in work. The Spearman rank correlation between vectors x and y is equivalent to the Pearson correlation between the ranked vectors x_R and y_R, where ranks are defined to be the average of the positions of an element in the ascending order of the values.",N,N],[5,"wmean","","This function returns the weighted mean of the dataset data with stride stride and length n, using the set of weights w with stride wstride and length n. The weighted mean is defined as,",N,N],[5,"wvariance","","This function returns the estimated variance of the dataset data with stride stride and length n, using the set of weights w with stride wstride and length n. The estimated variance of a weighted dataset is calculated as,",N,N],[5,"wvariance_m","","This function returns the estimated variance of the weighted dataset data using the given weighted mean wmean.",N,N],[5,"wsd","","The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding variance function gsl_stats_wvariance above.",N,N],[5,"wsd_m","","This function returns the square root of the corresponding variance function gsl_stats_wvariance_m above.",N,N],[5,"wvariance_with_fixed_mean","","This function computes an unbiased estimate of the variance of the weighted dataset data when the population mean mean of the underlying distribution is known a priori. In this case the estimator for the variance replaces the sample mean \\Hat\\mu by the known population mean \\mu,",N,N],[5,"wsd_with_fixed_mean","","The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding variance function above.",N,N],[5,"wtss","","This function returns the weighted total sum of squares (TSS) of data about the weighted mean. For gsl_stats_wtss_m the user-supplied value of wmean is used, and for gsl_stats_wtss it is computed using gsl_stats_wmean.",N,N],[5,"wtss_m","","This function returns the weighted total sum of squares (TSS) of data about the weighted mean. For gsl_stats_wtss_m the user-supplied value of wmean is used, and for gsl_stats_wtss it is computed using gsl_stats_wmean.",N,N],[5,"wabsdev","","This function computes the weighted absolute deviation from the weighted mean of data. The absolute deviation from the mean is defined as,",N,N],[5,"wabsdev_m","","This function computes the absolute deviation of the weighted dataset data about the given weighted mean wmean.",N,N],[5,"wskew","","This function computes the weighted skewness of the dataset data.",N,N],[5,"wskew_m_sd","","This function computes the weighted skewness of the dataset data using the given values of the weighted mean and weighted standard deviation, wmean and wsd.",N,N],[5,"wkurtosis","","This function computes the weighted kurtosis of the dataset data.",N,N],[5,"wkurtosis_m_sd","","This function computes the weighted kurtosis of the dataset data using the given values of the weighted mean and weighted standard deviation, wmean and wsd.",N,N],[5,"max","","This function returns the maximum value in data, a dataset of length n with stride stride. The maximum value is defined as the value of the element x_i which satisfies x_i >= x_j for all j.",N,N],[5,"min","","This function returns the minimum value in data, a dataset of length n with stride stride. The minimum value is defined as the value of the element x_i which satisfies x_i <= x_j for all j.",N,N],[5,"minmax","","This function finds both the minimum and maximum values min, max in data in a single pass.",N,N],[5,"max_index","","This function returns the index of the maximum value in data, a dataset of length n with stride stride. The maximum value is defined as the value of the element x_i which satisfies x_i >= x_j for all j. When there are several equal maximum elements then the first one is chosen.",N,N],[5,"min_index","","This function returns the index of the minimum value in data, a dataset of length n with stride stride. The minimum value is defined as the value of the element x_i which satisfies x_i >= x_j for all j. When there are several equal minimum elements then the first one is chosen.",N,N],[5,"minmax_index","","This function returns the indexes min_index, max_index of the minimum and maximum values in data in a single pass.",N,N],[5,"median_from_sorted_data","","This function returns the median value of sorted_data, a dataset of length n with stride stride. The elements of the array must be in ascending numerical order. There are no checks to see whether the data are sorted, so the function gsl_sort should always be used first.",N,N],[5,"quantile_from_sorted_data","","This function returns a quantile value of sorted_data, a double-precision array of length n with stride stride. The elements of the array must be in ascending numerical order. The quantile is determined by the f, a fraction between 0 and 1. For example, to compute the value of the 75th percentile f should have the value 0.75.",N,N],[0,"synchrotron","rgsl","",N,N],[5,"synchrotron_1","rgsl::synchrotron","This routine computes the first synchrotron function x \\int_x^\\infty dt K_{5/3}(t) for x >= 0.",N,[[["f64"]],["f64"]]],[5,"synchrotron_1_e","","This routine computes the first synchrotron function x \\int_x^\\infty dt K_{5/3}(t) for x >= 0.",N,N],[5,"synchrotron_2","","This routine computes the second synchrotron function x K_{2/3}(x) for x >= 0.",N,[[["f64"]],["f64"]]],[5,"synchrotron_2_e","","This routine computes the second synchrotron function x K_{2/3}(x) for x >= 0.",N,N],[0,"transport","rgsl","The transport functions J(n,x) are defined by the integral representations J(n,x) := \\int_0^x dt t^n e^t /(e^t - 1)^2.",N,N],[5,"transport_2","rgsl::transport","This routine computes the transport function J(2,x).",N,[[["f64"]],["f64"]]],[5,"transport_2_e","","This routine computes the transport function J(2,x).",N,N],[5,"transport_3","","This routine computes the transport function J(3,x).",N,[[["f64"]],["f64"]]],[5,"transport_3_e","","This routine computes the transport function J(3,x).",N,N],[5,"transport_4","","This routine computes the transport function J(4,x).",N,[[["f64"]],["f64"]]],[5,"transport_4_e","","This routine computes the transport function J(4,x).",N,N],[5,"transport_5","","This routine computes the transport function J(5,x).",N,[[["f64"]],["f64"]]],[5,"transport_5_e","","This routine computes the transport function J(5,x).",N,N],[0,"trigonometric","rgsl","",N,N],[8,"Trigonometric","rgsl::trigonometric","",N,N],[10,"sin","","This routine computes the sine function \\sin(x).",108,[[["self"]],["self"]]],[10,"sin_e","","This routine computes the sine function \\sin(x).",108,N],[10,"cos","","This routine computes the cosine function \\sin(x).",108,[[["self"]],["self"]]],[10,"cos_e","","This routine computes the cosine function \\sin(x).",108,N],[10,"sf_hypot","","This routine computes the hypotenuse function \\sqrt{x^2 + y^2} avoiding overflow and underflow.",108,[[["self"]],["self"]]],[10,"sf_hypot_e","","This routine computes the hypotenuse function \\sqrt{x^2 + y^2} avoiding overflow and underflow.",108,N],[10,"sinc","","This routine computes \\sinc(x) = \\sin(\\pi x) / (\\pi x) for any value of x.",108,[[["self"]],["self"]]],[10,"sinc_e","","This routine computes \\sinc(x) = \\sin(\\pi x) / (\\pi x) for any value of x.",108,N],[10,"complex_sin_e","","This function computes the complex sine, \\sin(z_r + i z_i) storing the real and imaginary parts in szr, szi.",108,N],[10,"complex_cos_e","","This function computes the complex cosine, \\cos(z_r + i z_i) storing the real and imaginary parts in czr, czi.",108,N],[10,"complex_logsin_e","","This function computes the logarithm of the complex sine, \\log(\\sin(z_r + i z_i)) storing the real and imaginary parts in lszr, lszi.",108,N],[10,"lnsinh","","This routine computes \\log(\\sinh(x)) for x > 0.",108,[[["self"]],["self"]]],[10,"lnsinh_e","","This routine computes \\log(\\sinh(x)) for x > 0.",108,N],[10,"lncosh","","This routine computes \\log(\\cosh(x)) for x > 0.",108,[[["self"]],["self"]]],[10,"lncosh_e","","This routine computes \\log(\\cosh(x)) for x > 0.",108,N],[10,"polar_to_rect","","This function converts the polar coordinates (r,theta) to rectilinear coordinates (x,y), x = r\\cos(\\theta), y = r\\sin(\\theta).",108,N],[10,"rect_to_polar","","This function converts the rectilinear coordinates (x,y) to polar coordinates (r,theta), such that x = r\\cos(\\theta), y = r\\sin(\\theta). The argument theta lies in the range [-\\pi, \\pi].",108,N],[10,"angle_restrict_symm","","This routine forces the angle theta to lie in the range (-\\pi,\\pi].",108,[[["self"]],["self"]]],[10,"angle_restrict_symm_e","","This routine forces the angle theta to lie in the range (-\\pi,\\pi].",108,[[["self"]],["value"]]],[10,"angle_restrict_pos","","This routine forces the angle theta to lie in the range [0, 2\\pi).",108,[[["self"]],["self"]]],[10,"angle_restrict_pos_e","","This routine forces the angle theta to lie in the range [0, 2\\pi).",108,[[["self"]],["value"]]],[10,"sin_err_e","","This routine computes the sine of an angle x with an associated absolute error dx, \\sin(x \\pm dx).",108,N],[10,"cos_err_e","","This routine computes the cosine of an angle x with an associated absolute error dx, \\cos(x \\pm dx).",108,N],[0,"util","rgsl","",N,N],[5,"subinterval_too_small","rgsl::util","",N,[[["f64"],["f64"],["f64"]],["bool"]]],[0,"wavelet_transforms","rgsl","##Transform Functions",N,N],[0,"one_dimension","rgsl::wavelet_transforms","These functions compute in-place forward and inverse discrete wavelet transforms of length n with stride stride on the array data. The length of the transform n is restricted to powers of two. For the transform version of the function the argument dir can be either forward (+1) or backward (-1). A workspace work of length n must be provided.",N,N],[5,"transform","rgsl::wavelet_transforms::one_dimension","",N,N],[5,"transform_forward","","",N,N],[5,"transform_inverse","","",N,N],[0,"two_dimension","rgsl::wavelet_transforms","The library provides functions to perform two-dimensional discrete wavelet transforms on square matrices. The matrix dimensions must be an integer power of two. There are two possible orderings of the rows and columns in the two-dimensional wavelet transform, referred to as the standard and non-standard forms.",N,N],[5,"transform","rgsl::wavelet_transforms::two_dimension","These functions compute two-dimensional in-place forward and inverse discrete wavelet transforms in standard form on the array data stored in row-major form with dimensions size1 and size2 and physical row length tda. The dimensions must be equal (square matrix) and are restricted to powers of two. For the transform version of the function the argument dir can be either forward (+1) or backward (-1). A workspace work of the appropriate size must be provided. On exit, the appropriate elements of the array data are replaced by their two-dimensional wavelet transform.",N,N],[5,"transform_forward","","These functions compute two-dimensional in-place forward and inverse discrete wavelet transforms in standard form on the array data stored in row-major form with dimensions size1 and size2 and physical row length tda. The dimensions must be equal (square matrix) and are restricted to powers of two. For the transform version of the function the argument dir can be either forward (+1) or backward (-1). A workspace work of the appropriate size must be provided. On exit, the appropriate elements of the array data are replaced by their two-dimensional wavelet transform.",N,N],[5,"transform_inverse","","These functions compute two-dimensional in-place forward and inverse discrete wavelet transforms in standard form on the array data stored in row-major form with dimensions size1 and size2 and physical row length tda. The dimensions must be equal (square matrix) and are restricted to powers of two. For the transform version of the function the argument dir can be either forward (+1) or backward (-1). A workspace work of the appropriate size must be provided. On exit, the appropriate elements of the array data are replaced by their two-dimensional wavelet transform.",N,N],[5,"transform_matrix","","These functions compute the two-dimensional in-place wavelet transform on a matrix a.",N,[[["wavelet"],["matrixf64"],["waveletdirection"],["waveletworkspace"]],["value"]]],[5,"transform_matrix_forward","","These functions compute the two-dimensional in-place wavelet transform on a matrix a.",N,[[["wavelet"],["matrixf64"],["waveletworkspace"]],["value"]]],[5,"transform_matrix_inverse","","These functions compute the two-dimensional in-place wavelet transform on a matrix a.",N,[[["wavelet"],["matrixf64"],["waveletworkspace"]],["value"]]],[5,"nstransform","","These functions compute the two-dimensional wavelet transform in non-standard form.",N,N],[5,"nstransform_forward","","These functions compute the two-dimensional wavelet transform in non-standard form.",N,N],[5,"nstransform_inverse","","These functions compute the two-dimensional wavelet transform in non-standard form.",N,N],[5,"nstransform_matrix","","These functions compute the non-standard form of the two-dimensional in-place wavelet transform on a matrix a.",N,[[["wavelet"],["matrixf64"],["waveletdirection"],["waveletworkspace"]],["value"]]],[5,"nstransform_matrix_forward","","These functions compute the non-standard form of the two-dimensional in-place wavelet transform on a matrix a.",N,[[["wavelet"],["matrixf64"],["waveletworkspace"]],["value"]]],[5,"nstransform_matrix_inverse","","These functions compute the non-standard form of the two-dimensional in-place wavelet transform on a matrix a.",N,[[["wavelet"],["matrixf64"],["waveletworkspace"]],["value"]]],[0,"zeta","rgsl","The Riemann zeta function is defined in Abramowitz & Stegun, Section 23.2.",N,N],[0,"riemann","rgsl::zeta","The Riemann zeta function is defined by the infinite sum \\zeta(s) = \\sum_{k=1}^\\infty k^{-s}.",N,N],[5,"zeta_int","rgsl::zeta::riemann","This routine computes the Riemann zeta function \\zeta(n) for integer n, n \\ne 1.",N,[[["i32"]],["f64"]]],[5,"zeta_int_e","","This routine computes the Riemann zeta function \\zeta(n) for integer n, n \\ne 1.",N,N],[5,"zeta","","This routine computes the Riemann zeta function \\zeta(s) for arbitrary s, s \\ne 1.",N,[[["f64"]],["f64"]]],[5,"zeta_e","","This routine computes the Riemann zeta function \\zeta(s) for arbitrary s, s \\ne 1.",N,N],[0,"riemann_mins_one","rgsl::zeta","For large positive argument, the Riemann zeta function approaches one. In this region the fractional part is interesting, and therefore we need a function to evaluate it explicitly.",N,N],[5,"zetam1_int","rgsl::zeta::riemann_mins_one","This routine computes the Riemann zeta function \\zeta(n) for integer n, n \\ne 1.",N,[[["i32"]],["f64"]]],[5,"zetam1_int_e","","This routine computes the Riemann zeta function \\zeta(n) for integer n, n \\ne 1.",N,N],[5,"zetam1","","This routine computes \\zeta(s) - 1 for arbitrary s, s \\ne 1.",N,[[["f64"]],["f64"]]],[5,"zetam1_e","","This routine computes \\zeta(s) - 1 for arbitrary s, s \\ne 1.",N,N],[0,"hurwitz","rgsl::zeta","The Hurwitz zeta function is defined by \\zeta(s,q) = \\sum_0^\\infty (k+q)^{-s}.",N,N],[5,"hzeta","rgsl::zeta::hurwitz","This routine computes the Hurwitz zeta function \\zeta(s,q) for s > 1, q > 0.",N,[[["f64"],["f64"]],["f64"]]],[5,"hzeta_e","","This routine computes the Hurwitz zeta function \\zeta(s,q) for s > 1, q > 0.",N,N],[0,"eta","rgsl::zeta","The eta function is defined by \\eta(s) = (1-2^{1-s}) \\zeta(s).",N,N],[5,"eta_int","rgsl::zeta::eta","This routine computes the eta function \\eta(n) for integer n.",N,[[["i32"]],["f64"]]],[5,"eta_int_e","","This routine computes the eta function \\eta(n) for integer n.",N,N],[5,"eta","","This routine computes the eta function \\eta(s) for arbitrary s.",N,[[["f64"]],["f64"]]],[5,"eta_e","","This routine computes the eta function \\eta(s) for arbitrary s.",N,N],[6,"GSLResult","rgsl","A type for results generated by GSL functions where `Err` is `enums::Value`.",N,N],[6,"comparison_fn","","",N,N],[6,"function","","",N,N],[6,"integration_function","","",N,N],[6,"monte_function","","",N,N],[6,"select_function","","",N,N],[6,"value_function","","",N,N],[7,"SF_GAMMA_XMAX","","The maximum x such that gamma(x) is not considered an overflow.",N,N],[7,"SF_FACT_NMAX","","The maximum n such that gsl_sf_fact(n) does not give an overflow.",N,N],[7,"SF_DOUBLEFACT_NMAX","","The maximum n such that gsl_sf_doublefact(n) does not give an overflow.",N,N],[7,"SF_MATHIEU_COEFF","","",N,N],[7,"DBL_EPSILON","","",N,N],[7,"SQRT_DBL_EPSILON","","",N,N],[7,"ROOT3_DBL_EPSILON","","",N,N],[7,"ROOT4_DBL_EPSILON","","",N,N],[7,"ROOT5_DBL_EPSILON","","",N,N],[7,"ROOT6_DBL_EPSILON","","",N,N],[7,"DBL_MIN","","",N,N],[7,"SQRT_DBL_MIN","","",N,N],[7,"ROOT3_DBL_MIN","","",N,N],[7,"ROOT4_DBL_MIN","","",N,N],[7,"ROOT5_DBL_MIN","","",N,N],[7,"ROOT6_DBL_MIN","","",N,N],[7,"DBL_MAX","","",N,N],[7,"SQRT_DBL_MAX","","",N,N],[7,"ROOT3_DBL_MAX","","",N,N],[7,"ROOT4_DBL_MAX","","",N,N],[7,"ROOT5_DBL_MAX","","",N,N],[7,"ROOT6_DBL_MAX","","",N,N],[7,"LOG_DBL_MAX","","",N,N],[7,"NAN","","",N,N],[7,"POSINF","","",N,N],[7,"NEGINF","","",N,N],[14,"ffi_wrap","","",N,N],[11,"into","","",0,[[["self"]],["u"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"from","","",11,[[["t"]],["t"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"into","rgsl::types::basis_spline","",13,[[["self"]],["u"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"into","rgsl::types::chebyshev","",15,[[["self"]],["u"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"into","rgsl::types::combination","",16,[[["self"]],["u"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"into","rgsl::types::complex","",17,[[["self"]],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"from","","",17,[[["t"]],["t"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,N],[11,"from","","",18,[[["t"]],["t"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"into","rgsl::types::discrete_hankel","",19,[[["self"]],["u"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"into","rgsl::types::eigen_symmetric_workspace","",20,[[["self"]],["u"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"from","","",27,[[["t"]],["t"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"into","","",28,[[["self"]],["u"]]],[11,"from","","",28,[[["t"]],["t"]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"get_type_id","","",28,[[["self"]],["typeid"]]],[11,"try_into","","",28,[[["self"]],["result"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"into","","",29,[[["self"]],["u"]]],[11,"from","","",29,[[["t"]],["t"]]],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"into","","",30,[[["self"]],["u"]]],[11,"from","","",30,[[["t"]],["t"]]],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"from","","",31,[[["t"]],["t"]]],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"into","rgsl::types::fast_fourier_transforms","",32,[[["self"]],["u"]]],[11,"from","","",32,[[["t"]],["t"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"from","","",33,[[["t"]],["t"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"into","rgsl::types::histograms","",34,[[["self"]],["u"]]],[11,"from","","",34,[[["t"]],["t"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"from","","",35,[[["t"]],["t"]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"from","","",36,[[["t"]],["t"]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"from","","",37,[[["t"]],["t"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"into","rgsl::types::integration","",38,[[["self"]],["u"]]],[11,"from","","",38,[[["t"]],["t"]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"from","","",39,[[["t"]],["t"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"from","","",40,[[["t"]],["t"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"from","","",41,[[["t"]],["t"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"from","","",42,[[["t"]],["t"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"into","rgsl::types::interpolation","",43,[[["self"]],["u"]]],[11,"to_owned","","",43,[[["self"]],["t"]]],[11,"clone_into","","",43,N],[11,"from","","",43,[[["t"]],["t"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"from","","",44,[[["t"]],["t"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"to_owned","","",45,[[["self"]],["t"]]],[11,"clone_into","","",45,N],[11,"from","","",45,[[["t"]],["t"]]],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"from","","",46,[[["t"]],["t"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"into","rgsl::types::mathieu","",47,[[["self"]],["u"]]],[11,"from","","",47,[[["t"]],["t"]]],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"into","rgsl::types::matrix","",48,[[["self"]],["u"]]],[11,"from","","",48,[[["t"]],["t"]]],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"from","","",49,[[["t"]],["t"]]],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"from","","",50,[[["t"]],["t"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"into","rgsl::types::matrix_complex","",51,[[["self"]],["u"]]],[11,"from","","",51,[[["t"]],["t"]]],[11,"try_from","","",51,[[["u"]],["result"]]],[11,"borrow","","",51,[[["self"]],["t"]]],[11,"get_type_id","","",51,[[["self"]],["typeid"]]],[11,"try_into","","",51,[[["self"]],["result"]]],[11,"borrow_mut","","",51,[[["self"]],["t"]]],[11,"into","","",52,[[["self"]],["u"]]],[11,"from","","",52,[[["t"]],["t"]]],[11,"try_from","","",52,[[["u"]],["result"]]],[11,"borrow","","",52,[[["self"]],["t"]]],[11,"get_type_id","","",52,[[["self"]],["typeid"]]],[11,"try_into","","",52,[[["self"]],["result"]]],[11,"borrow_mut","","",52,[[["self"]],["t"]]],[11,"into","rgsl::types::minimizer","",54,[[["self"]],["u"]]],[11,"from","","",54,[[["t"]],["t"]]],[11,"try_from","","",54,[[["u"]],["result"]]],[11,"borrow","","",54,[[["self"]],["t"]]],[11,"get_type_id","","",54,[[["self"]],["typeid"]]],[11,"try_into","","",54,[[["self"]],["result"]]],[11,"borrow_mut","","",54,[[["self"]],["t"]]],[11,"into","","",53,[[["self"]],["u"]]],[11,"to_owned","","",53,[[["self"]],["t"]]],[11,"clone_into","","",53,N],[11,"from","","",53,[[["t"]],["t"]]],[11,"try_from","","",53,[[["u"]],["result"]]],[11,"borrow","","",53,[[["self"]],["t"]]],[11,"get_type_id","","",53,[[["self"]],["typeid"]]],[11,"try_into","","",53,[[["self"]],["result"]]],[11,"borrow_mut","","",53,[[["self"]],["t"]]],[11,"into","rgsl::types::monte_carlo","",57,[[["self"]],["u"]]],[11,"from","","",57,[[["t"]],["t"]]],[11,"try_from","","",57,[[["u"]],["result"]]],[11,"borrow","","",57,[[["self"]],["t"]]],[11,"get_type_id","","",57,[[["self"]],["typeid"]]],[11,"try_into","","",57,[[["self"]],["result"]]],[11,"borrow_mut","","",57,[[["self"]],["t"]]],[11,"into","","",58,[[["self"]],["u"]]],[11,"from","","",58,[[["t"]],["t"]]],[11,"try_from","","",58,[[["u"]],["result"]]],[11,"borrow","","",58,[[["self"]],["t"]]],[11,"get_type_id","","",58,[[["self"]],["typeid"]]],[11,"try_into","","",58,[[["self"]],["result"]]],[11,"borrow_mut","","",58,[[["self"]],["t"]]],[11,"into","","",55,[[["self"]],["u"]]],[11,"from","","",55,[[["t"]],["t"]]],[11,"try_from","","",55,[[["u"]],["result"]]],[11,"borrow","","",55,[[["self"]],["t"]]],[11,"get_type_id","","",55,[[["self"]],["typeid"]]],[11,"try_into","","",55,[[["self"]],["result"]]],[11,"borrow_mut","","",55,[[["self"]],["t"]]],[11,"into","","",59,[[["self"]],["u"]]],[11,"from","","",59,[[["t"]],["t"]]],[11,"try_from","","",59,[[["u"]],["result"]]],[11,"borrow","","",59,[[["self"]],["t"]]],[11,"get_type_id","","",59,[[["self"]],["typeid"]]],[11,"try_into","","",59,[[["self"]],["result"]]],[11,"borrow_mut","","",59,[[["self"]],["t"]]],[11,"into","","",60,[[["self"]],["u"]]],[11,"from","","",60,[[["t"]],["t"]]],[11,"try_from","","",60,[[["u"]],["result"]]],[11,"borrow","","",60,[[["self"]],["t"]]],[11,"get_type_id","","",60,[[["self"]],["typeid"]]],[11,"try_into","","",60,[[["self"]],["result"]]],[11,"borrow_mut","","",60,[[["self"]],["t"]]],[11,"into","","",56,[[["self"]],["u"]]],[11,"to_owned","","",56,[[["self"]],["t"]]],[11,"clone_into","","",56,N],[11,"from","","",56,[[["t"]],["t"]]],[11,"try_from","","",56,[[["u"]],["result"]]],[11,"borrow","","",56,[[["self"]],["t"]]],[11,"get_type_id","","",56,[[["self"]],["typeid"]]],[11,"try_into","","",56,[[["self"]],["result"]]],[11,"borrow_mut","","",56,[[["self"]],["t"]]],[11,"into","rgsl::types::multifit_solver","",109,[[["self"]],["u"]]],[11,"from","","",109,[[["t"]],["t"]]],[11,"try_from","","",109,[[["u"]],["result"]]],[11,"borrow","","",109,[[["self"]],["t"]]],[11,"get_type_id","","",109,[[["self"]],["typeid"]]],[11,"try_into","","",109,[[["self"]],["result"]]],[11,"borrow_mut","","",109,[[["self"]],["t"]]],[11,"into","","",63,[[["self"]],["u"]]],[11,"from","","",63,[[["t"]],["t"]]],[11,"try_from","","",63,[[["u"]],["result"]]],[11,"borrow","","",63,[[["self"]],["t"]]],[11,"get_type_id","","",63,[[["self"]],["typeid"]]],[11,"try_into","","",63,[[["self"]],["result"]]],[11,"borrow_mut","","",63,[[["self"]],["t"]]],[11,"into","","",61,[[["self"]],["u"]]],[11,"from","","",61,[[["t"]],["t"]]],[11,"try_from","","",61,[[["u"]],["result"]]],[11,"borrow","","",61,[[["self"]],["t"]]],[11,"get_type_id","","",61,[[["self"]],["typeid"]]],[11,"try_into","","",61,[[["self"]],["result"]]],[11,"borrow_mut","","",61,[[["self"]],["t"]]],[11,"into","","",64,[[["self"]],["u"]]],[11,"from","","",64,[[["t"]],["t"]]],[11,"try_from","","",64,[[["u"]],["result"]]],[11,"borrow","","",64,[[["self"]],["t"]]],[11,"get_type_id","","",64,[[["self"]],["typeid"]]],[11,"try_into","","",64,[[["self"]],["result"]]],[11,"borrow_mut","","",64,[[["self"]],["t"]]],[11,"into","","",65,[[["self"]],["u"]]],[11,"from","","",65,[[["t"]],["t"]]],[11,"try_from","","",65,[[["u"]],["result"]]],[11,"borrow","","",65,[[["self"]],["t"]]],[11,"get_type_id","","",65,[[["self"]],["typeid"]]],[11,"try_into","","",65,[[["self"]],["result"]]],[11,"borrow_mut","","",65,[[["self"]],["t"]]],[11,"into","","",62,[[["self"]],["u"]]],[11,"from","","",62,[[["t"]],["t"]]],[11,"try_from","","",62,[[["u"]],["result"]]],[11,"borrow","","",62,[[["self"]],["t"]]],[11,"get_type_id","","",62,[[["self"]],["typeid"]]],[11,"try_into","","",62,[[["self"]],["result"]]],[11,"borrow_mut","","",62,[[["self"]],["t"]]],[11,"into","rgsl::types::multiset","",66,[[["self"]],["u"]]],[11,"from","","",66,[[["t"]],["t"]]],[11,"try_from","","",66,[[["u"]],["result"]]],[11,"borrow","","",66,[[["self"]],["t"]]],[11,"get_type_id","","",66,[[["self"]],["typeid"]]],[11,"try_into","","",66,[[["self"]],["result"]]],[11,"borrow_mut","","",66,[[["self"]],["t"]]],[11,"into","rgsl::types::n_tuples","",67,[[["self"]],["u"]]],[11,"from","","",67,[[["t"]],["t"]]],[11,"try_from","","",67,[[["u"]],["result"]]],[11,"borrow","","",67,[[["self"]],["t"]]],[11,"get_type_id","","",67,[[["self"]],["typeid"]]],[11,"try_into","","",67,[[["self"]],["result"]]],[11,"borrow_mut","","",67,[[["self"]],["t"]]],[11,"into","rgsl::types::ordinary_differential_equations","",68,[[["self"]],["u"]]],[11,"from","","",68,[[["t"]],["t"]]],[11,"try_from","","",68,[[["u"]],["result"]]],[11,"borrow","","",68,[[["self"]],["t"]]],[11,"get_type_id","","",68,[[["self"]],["typeid"]]],[11,"try_into","","",68,[[["self"]],["result"]]],[11,"borrow_mut","","",68,[[["self"]],["t"]]],[11,"into","","",69,[[["self"]],["u"]]],[11,"from","","",69,[[["t"]],["t"]]],[11,"try_from","","",69,[[["u"]],["result"]]],[11,"borrow","","",69,[[["self"]],["t"]]],[11,"get_type_id","","",69,[[["self"]],["typeid"]]],[11,"try_into","","",69,[[["self"]],["result"]]],[11,"borrow_mut","","",69,[[["self"]],["t"]]],[11,"into","","",70,[[["self"]],["u"]]],[11,"to_owned","","",70,[[["self"]],["t"]]],[11,"clone_into","","",70,N],[11,"from","","",70,[[["t"]],["t"]]],[11,"try_from","","",70,[[["u"]],["result"]]],[11,"borrow","","",70,[[["self"]],["t"]]],[11,"get_type_id","","",70,[[["self"]],["typeid"]]],[11,"try_into","","",70,[[["self"]],["result"]]],[11,"borrow_mut","","",70,[[["self"]],["t"]]],[11,"into","","",71,[[["self"]],["u"]]],[11,"from","","",71,[[["t"]],["t"]]],[11,"try_from","","",71,[[["u"]],["result"]]],[11,"borrow","","",71,[[["self"]],["t"]]],[11,"get_type_id","","",71,[[["self"]],["typeid"]]],[11,"try_into","","",71,[[["self"]],["result"]]],[11,"borrow_mut","","",71,[[["self"]],["t"]]],[11,"into","","",72,[[["self"]],["u"]]],[11,"to_owned","","",72,[[["self"]],["t"]]],[11,"clone_into","","",72,N],[11,"from","","",72,[[["t"]],["t"]]],[11,"try_from","","",72,[[["u"]],["result"]]],[11,"borrow","","",72,[[["self"]],["t"]]],[11,"get_type_id","","",72,[[["self"]],["typeid"]]],[11,"try_into","","",72,[[["self"]],["result"]]],[11,"borrow_mut","","",72,[[["self"]],["t"]]],[11,"into","","",73,[[["self"]],["u"]]],[11,"from","","",73,[[["t"]],["t"]]],[11,"try_from","","",73,[[["u"]],["result"]]],[11,"borrow","","",73,[[["self"]],["t"]]],[11,"get_type_id","","",73,[[["self"]],["typeid"]]],[11,"try_into","","",73,[[["self"]],["result"]]],[11,"borrow_mut","","",73,[[["self"]],["t"]]],[11,"into","","",74,[[["self"]],["u"]]],[11,"from","","",74,[[["t"]],["t"]]],[11,"try_from","","",74,[[["u"]],["result"]]],[11,"borrow","","",74,[[["self"]],["t"]]],[11,"get_type_id","","",74,[[["self"]],["typeid"]]],[11,"try_into","","",74,[[["self"]],["result"]]],[11,"borrow_mut","","",74,[[["self"]],["t"]]],[11,"into","rgsl::types::permutation","",75,[[["self"]],["u"]]],[11,"from","","",75,[[["t"]],["t"]]],[11,"try_from","","",75,[[["u"]],["result"]]],[11,"borrow","","",75,[[["self"]],["t"]]],[11,"get_type_id","","",75,[[["self"]],["typeid"]]],[11,"try_into","","",75,[[["self"]],["result"]]],[11,"borrow_mut","","",75,[[["self"]],["t"]]],[11,"into","rgsl::types::polynomial","",76,[[["self"]],["u"]]],[11,"from","","",76,[[["t"]],["t"]]],[11,"try_from","","",76,[[["u"]],["result"]]],[11,"borrow","","",76,[[["self"]],["t"]]],[11,"get_type_id","","",76,[[["self"]],["typeid"]]],[11,"try_into","","",76,[[["self"]],["result"]]],[11,"borrow_mut","","",76,[[["self"]],["t"]]],[11,"into","rgsl::types::qrng","",77,[[["self"]],["u"]]],[11,"to_owned","","",77,[[["self"]],["t"]]],[11,"clone_into","","",77,N],[11,"from","","",77,[[["t"]],["t"]]],[11,"try_from","","",77,[[["u"]],["result"]]],[11,"borrow","","",77,[[["self"]],["t"]]],[11,"get_type_id","","",77,[[["self"]],["typeid"]]],[11,"try_into","","",77,[[["self"]],["result"]]],[11,"borrow_mut","","",77,[[["self"]],["t"]]],[11,"into","","",78,[[["self"]],["u"]]],[11,"to_owned","","",78,[[["self"]],["t"]]],[11,"clone_into","","",78,N],[11,"from","","",78,[[["t"]],["t"]]],[11,"try_from","","",78,[[["u"]],["result"]]],[11,"borrow","","",78,[[["self"]],["t"]]],[11,"get_type_id","","",78,[[["self"]],["typeid"]]],[11,"try_into","","",78,[[["self"]],["result"]]],[11,"borrow_mut","","",78,[[["self"]],["t"]]],[11,"into","rgsl::types::ran_discrete","",79,[[["self"]],["u"]]],[11,"from","","",79,[[["t"]],["t"]]],[11,"try_from","","",79,[[["u"]],["result"]]],[11,"borrow","","",79,[[["self"]],["t"]]],[11,"get_type_id","","",79,[[["self"]],["typeid"]]],[11,"try_into","","",79,[[["self"]],["result"]]],[11,"borrow_mut","","",79,[[["self"]],["t"]]],[11,"into","rgsl::types::result","",80,[[["self"]],["u"]]],[11,"to_owned","","",80,[[["self"]],["t"]]],[11,"clone_into","","",80,N],[11,"from","","",80,[[["t"]],["t"]]],[11,"try_from","","",80,[[["u"]],["result"]]],[11,"borrow","","",80,[[["self"]],["t"]]],[11,"get_type_id","","",80,[[["self"]],["typeid"]]],[11,"try_into","","",80,[[["self"]],["result"]]],[11,"borrow_mut","","",80,[[["self"]],["t"]]],[11,"into","","",81,[[["self"]],["u"]]],[11,"to_owned","","",81,[[["self"]],["t"]]],[11,"clone_into","","",81,N],[11,"from","","",81,[[["t"]],["t"]]],[11,"try_from","","",81,[[["u"]],["result"]]],[11,"borrow","","",81,[[["self"]],["t"]]],[11,"get_type_id","","",81,[[["self"]],["typeid"]]],[11,"try_into","","",81,[[["self"]],["result"]]],[11,"borrow_mut","","",81,[[["self"]],["t"]]],[11,"into","rgsl::types::rng","",82,[[["self"]],["u"]]],[11,"to_owned","","",82,[[["self"]],["t"]]],[11,"clone_into","","",82,N],[11,"from","","",82,[[["t"]],["t"]]],[11,"try_from","","",82,[[["u"]],["result"]]],[11,"borrow","","",82,[[["self"]],["t"]]],[11,"get_type_id","","",82,[[["self"]],["typeid"]]],[11,"try_into","","",82,[[["self"]],["result"]]],[11,"borrow_mut","","",82,[[["self"]],["t"]]],[11,"into","","",83,[[["self"]],["u"]]],[11,"to_owned","","",83,[[["self"]],["t"]]],[11,"clone_into","","",83,N],[11,"from","","",83,[[["t"]],["t"]]],[11,"try_from","","",83,[[["u"]],["result"]]],[11,"borrow","","",83,[[["self"]],["t"]]],[11,"get_type_id","","",83,[[["self"]],["typeid"]]],[11,"try_into","","",83,[[["self"]],["result"]]],[11,"borrow_mut","","",83,[[["self"]],["t"]]],[11,"into","rgsl::types::roots","",84,[[["self"]],["u"]]],[11,"from","","",84,[[["t"]],["t"]]],[11,"try_from","","",84,[[["u"]],["result"]]],[11,"borrow","","",84,[[["self"]],["t"]]],[11,"get_type_id","","",84,[[["self"]],["typeid"]]],[11,"try_into","","",84,[[["self"]],["result"]]],[11,"borrow_mut","","",84,[[["self"]],["t"]]],[11,"into","","",85,[[["self"]],["u"]]],[11,"from","","",85,[[["t"]],["t"]]],[11,"try_from","","",85,[[["u"]],["result"]]],[11,"borrow","","",85,[[["self"]],["t"]]],[11,"get_type_id","","",85,[[["self"]],["typeid"]]],[11,"try_into","","",85,[[["self"]],["result"]]],[11,"borrow_mut","","",85,[[["self"]],["t"]]],[11,"into","","",86,[[["self"]],["u"]]],[11,"from","","",86,[[["t"]],["t"]]],[11,"try_from","","",86,[[["u"]],["result"]]],[11,"borrow","","",86,[[["self"]],["t"]]],[11,"get_type_id","","",86,[[["self"]],["typeid"]]],[11,"try_into","","",86,[[["self"]],["result"]]],[11,"borrow_mut","","",86,[[["self"]],["t"]]],[11,"into","","",87,[[["self"]],["u"]]],[11,"from","","",87,[[["t"]],["t"]]],[11,"try_from","","",87,[[["u"]],["result"]]],[11,"borrow","","",87,[[["self"]],["t"]]],[11,"get_type_id","","",87,[[["self"]],["typeid"]]],[11,"try_into","","",87,[[["self"]],["result"]]],[11,"borrow_mut","","",87,[[["self"]],["t"]]],[11,"into","rgsl::types::series_acceleration","",88,[[["self"]],["u"]]],[11,"from","","",88,[[["t"]],["t"]]],[11,"try_from","","",88,[[["u"]],["result"]]],[11,"borrow","","",88,[[["self"]],["t"]]],[11,"get_type_id","","",88,[[["self"]],["typeid"]]],[11,"try_into","","",88,[[["self"]],["result"]]],[11,"borrow_mut","","",88,[[["self"]],["t"]]],[11,"into","","",89,[[["self"]],["u"]]],[11,"from","","",89,[[["t"]],["t"]]],[11,"try_from","","",89,[[["u"]],["result"]]],[11,"borrow","","",89,[[["self"]],["t"]]],[11,"get_type_id","","",89,[[["self"]],["typeid"]]],[11,"try_into","","",89,[[["self"]],["result"]]],[11,"borrow_mut","","",89,[[["self"]],["t"]]],[11,"into","rgsl::types::siman","",90,[[["self"]],["u"]]],[11,"from","","",90,[[["t"]],["t"]]],[11,"try_from","","",90,[[["u"]],["result"]]],[11,"borrow","","",90,[[["self"]],["t"]]],[11,"get_type_id","","",90,[[["self"]],["typeid"]]],[11,"try_into","","",90,[[["self"]],["result"]]],[11,"borrow_mut","","",90,[[["self"]],["t"]]],[11,"into","","",91,[[["self"]],["u"]]],[11,"from","","",91,[[["t"]],["t"]]],[11,"try_from","","",91,[[["u"]],["result"]]],[11,"borrow","","",91,[[["self"]],["t"]]],[11,"get_type_id","","",91,[[["self"]],["typeid"]]],[11,"try_into","","",91,[[["self"]],["result"]]],[11,"borrow_mut","","",91,[[["self"]],["t"]]],[11,"into","rgsl::types::vector","",92,[[["self"]],["u"]]],[11,"from","","",92,[[["t"]],["t"]]],[11,"try_from","","",92,[[["u"]],["result"]]],[11,"borrow","","",92,[[["self"]],["t"]]],[11,"get_type_id","","",92,[[["self"]],["typeid"]]],[11,"try_into","","",92,[[["self"]],["result"]]],[11,"borrow_mut","","",92,[[["self"]],["t"]]],[11,"into","","",93,[[["self"]],["u"]]],[11,"from","","",93,[[["t"]],["t"]]],[11,"try_from","","",93,[[["u"]],["result"]]],[11,"borrow","","",93,[[["self"]],["t"]]],[11,"get_type_id","","",93,[[["self"]],["typeid"]]],[11,"try_into","","",93,[[["self"]],["result"]]],[11,"borrow_mut","","",93,[[["self"]],["t"]]],[11,"into","","",94,[[["self"]],["u"]]],[11,"from","","",94,[[["t"]],["t"]]],[11,"try_from","","",94,[[["u"]],["result"]]],[11,"borrow","","",94,[[["self"]],["t"]]],[11,"get_type_id","","",94,[[["self"]],["typeid"]]],[11,"try_into","","",94,[[["self"]],["result"]]],[11,"borrow_mut","","",94,[[["self"]],["t"]]],[11,"into","rgsl::types::vector_complex","",95,[[["self"]],["u"]]],[11,"from","","",95,[[["t"]],["t"]]],[11,"try_from","","",95,[[["u"]],["result"]]],[11,"borrow","","",95,[[["self"]],["t"]]],[11,"get_type_id","","",95,[[["self"]],["typeid"]]],[11,"try_into","","",95,[[["self"]],["result"]]],[11,"borrow_mut","","",95,[[["self"]],["t"]]],[11,"into","","",96,[[["self"]],["u"]]],[11,"from","","",96,[[["t"]],["t"]]],[11,"try_from","","",96,[[["u"]],["result"]]],[11,"borrow","","",96,[[["self"]],["t"]]],[11,"get_type_id","","",96,[[["self"]],["typeid"]]],[11,"try_into","","",96,[[["self"]],["result"]]],[11,"borrow_mut","","",96,[[["self"]],["t"]]],[11,"into","rgsl::types::wavelet_transforms","",97,[[["self"]],["u"]]],[11,"from","","",97,[[["t"]],["t"]]],[11,"try_from","","",97,[[["u"]],["result"]]],[11,"borrow","","",97,[[["self"]],["t"]]],[11,"get_type_id","","",97,[[["self"]],["typeid"]]],[11,"try_into","","",97,[[["self"]],["result"]]],[11,"borrow_mut","","",97,[[["self"]],["t"]]],[11,"into","","",98,[[["self"]],["u"]]],[11,"to_owned","","",98,[[["self"]],["t"]]],[11,"clone_into","","",98,N],[11,"from","","",98,[[["t"]],["t"]]],[11,"try_from","","",98,[[["u"]],["result"]]],[11,"borrow","","",98,[[["self"]],["t"]]],[11,"get_type_id","","",98,[[["self"]],["typeid"]]],[11,"try_into","","",98,[[["self"]],["result"]]],[11,"borrow_mut","","",98,[[["self"]],["t"]]],[11,"into","","",99,[[["self"]],["u"]]],[11,"from","","",99,[[["t"]],["t"]]],[11,"try_from","","",99,[[["u"]],["result"]]],[11,"borrow","","",99,[[["self"]],["t"]]],[11,"get_type_id","","",99,[[["self"]],["typeid"]]],[11,"try_into","","",99,[[["self"]],["result"]]],[11,"borrow_mut","","",99,[[["self"]],["t"]]],[11,"into","rgsl::cblas","",100,[[["self"]],["u"]]],[11,"to_owned","","",100,[[["self"]],["t"]]],[11,"clone_into","","",100,N],[11,"from","","",100,[[["t"]],["t"]]],[11,"try_from","","",100,[[["u"]],["result"]]],[11,"borrow","","",100,[[["self"]],["t"]]],[11,"get_type_id","","",100,[[["self"]],["typeid"]]],[11,"try_into","","",100,[[["self"]],["result"]]],[11,"borrow_mut","","",100,[[["self"]],["t"]]],[11,"into","","",101,[[["self"]],["u"]]],[11,"to_owned","","",101,[[["self"]],["t"]]],[11,"clone_into","","",101,N],[11,"from","","",101,[[["t"]],["t"]]],[11,"try_from","","",101,[[["u"]],["result"]]],[11,"borrow","","",101,[[["self"]],["t"]]],[11,"get_type_id","","",101,[[["self"]],["typeid"]]],[11,"try_into","","",101,[[["self"]],["result"]]],[11,"borrow_mut","","",101,[[["self"]],["t"]]],[11,"into","","",102,[[["self"]],["u"]]],[11,"to_owned","","",102,[[["self"]],["t"]]],[11,"clone_into","","",102,N],[11,"from","","",102,[[["t"]],["t"]]],[11,"try_from","","",102,[[["u"]],["result"]]],[11,"borrow","","",102,[[["self"]],["t"]]],[11,"get_type_id","","",102,[[["self"]],["typeid"]]],[11,"try_into","","",102,[[["self"]],["result"]]],[11,"borrow_mut","","",102,[[["self"]],["t"]]],[11,"into","","",103,[[["self"]],["u"]]],[11,"to_owned","","",103,[[["self"]],["t"]]],[11,"clone_into","","",103,N],[11,"from","","",103,[[["t"]],["t"]]],[11,"try_from","","",103,[[["u"]],["result"]]],[11,"borrow","","",103,[[["self"]],["t"]]],[11,"get_type_id","","",103,[[["self"]],["typeid"]]],[11,"try_into","","",103,[[["self"]],["result"]]],[11,"borrow_mut","","",103,[[["self"]],["t"]]],[11,"into","","",104,[[["self"]],["u"]]],[11,"to_owned","","",104,[[["self"]],["t"]]],[11,"clone_into","","",104,N],[11,"from","","",104,[[["t"]],["t"]]],[11,"try_from","","",104,[[["u"]],["result"]]],[11,"borrow","","",104,[[["self"]],["t"]]],[11,"get_type_id","","",104,[[["self"]],["typeid"]]],[11,"try_into","","",104,[[["self"]],["result"]]],[11,"borrow_mut","","",104,[[["self"]],["t"]]],[11,"into","","",105,[[["self"]],["u"]]],[11,"to_owned","","",105,[[["self"]],["t"]]],[11,"clone_into","","",105,N],[11,"from","","",105,[[["t"]],["t"]]],[11,"try_from","","",105,[[["u"]],["result"]]],[11,"borrow","","",105,[[["self"]],["t"]]],[11,"get_type_id","","",105,[[["self"]],["typeid"]]],[11,"try_into","","",105,[[["self"]],["result"]]],[11,"borrow_mut","","",105,[[["self"]],["t"]]],[11,"into","rgsl","",3,[[["self"]],["c_int"]]],[11,"into","","",4,[[["self"]],["c_int"]]],[11,"into","","",5,[[["self"]],["c_int"]]],[11,"into","","",6,[[["self"]],["c_int"]]],[11,"into","","",7,[[["self"]],["c_int"]]],[11,"into","","",8,[[["self"]],["c_int"]]],[11,"into","","",9,[[["self"]],["c_int"]]],[11,"into","","",10,[[["self"]],["c_int"]]],[11,"into","","",11,[[["self"]],["c_int"]]],[11,"partial_cmp","","",2,[[["self"],["mode"]],["option",["ordering"]]]],[11,"partial_cmp","","",3,[[["self"],["value"]],["option",["ordering"]]]],[11,"lt","","",3,[[["self"],["value"]],["bool"]]],[11,"le","","",3,[[["self"],["value"]],["bool"]]],[11,"gt","","",3,[[["self"],["value"]],["bool"]]],[11,"ge","","",3,[[["self"],["value"]],["bool"]]],[11,"partial_cmp","","",4,[[["self"],["eigensort"]],["option",["ordering"]]]],[11,"partial_cmp","","",5,[[["self"],["fftdirection"]],["option",["ordering"]]]],[11,"partial_cmp","","",6,[[["self"],["gausskonrodrule"]],["option",["ordering"]]]],[11,"partial_cmp","","",7,[[["self"],["integrationqawo"]],["option",["ordering"]]]],[11,"partial_cmp","","",8,[[["self"],["vegasmode"]],["option",["ordering"]]]],[11,"partial_cmp","","",9,[[["self"],["odeiv"]],["option",["ordering"]]]],[11,"partial_cmp","","",10,[[["self"],["waveletdirection"]],["option",["ordering"]]]],[11,"partial_cmp","","",11,[[["self"],["sflegendrenorm"]],["option",["ordering"]]]],[11,"partial_cmp","rgsl::cblas","",101,[[["self"],["order"]],["option",["ordering"]]]],[11,"partial_cmp","","",102,[[["self"],["side"]],["option",["ordering"]]]],[11,"partial_cmp","","",103,[[["self"],["transpose"]],["option",["ordering"]]]],[11,"partial_cmp","","",104,[[["self"],["uplo"]],["option",["ordering"]]]],[11,"partial_cmp","","",105,[[["self"],["diag"]],["option",["ordering"]]]],[11,"default","rgsl::types::complex","",17,[[],["complexf64"]]],[11,"default","","",18,[[],["complexf32"]]],[11,"default","rgsl::types::monte_carlo","",60,[[],["vegasparams"]]],[11,"default","rgsl::types::result","",80,[[],["result"]]],[11,"default","","",81,[[],["resulte10"]]],[11,"eq","rgsl","",2,[[["self"],["mode"]],["bool"]]],[11,"eq","","",3,[[["self"],["value"]],["bool"]]],[11,"ne","","",3,[[["self"],["value"]],["bool"]]],[11,"eq","","",4,[[["self"],["eigensort"]],["bool"]]],[11,"eq","","",5,[[["self"],["fftdirection"]],["bool"]]],[11,"eq","","",6,[[["self"],["gausskonrodrule"]],["bool"]]],[11,"eq","","",7,[[["self"],["integrationqawo"]],["bool"]]],[11,"eq","","",8,[[["self"],["vegasmode"]],["bool"]]],[11,"eq","","",9,[[["self"],["odeiv"]],["bool"]]],[11,"eq","","",10,[[["self"],["waveletdirection"]],["bool"]]],[11,"eq","","",11,[[["self"],["sflegendrenorm"]],["bool"]]],[11,"eq","rgsl::types::complex","",17,[[["self"],["complexf64"]],["bool"]]],[11,"ne","","",17,[[["self"],["complexf64"]],["bool"]]],[11,"eq","","",18,[[["self"],["complexf32"]],["bool"]]],[11,"ne","","",18,[[["self"],["complexf32"]],["bool"]]],[11,"eq","rgsl::cblas","",101,[[["self"],["order"]],["bool"]]],[11,"eq","","",102,[[["self"],["side"]],["bool"]]],[11,"eq","","",103,[[["self"],["transpose"]],["bool"]]],[11,"eq","","",104,[[["self"],["uplo"]],["bool"]]],[11,"eq","","",105,[[["self"],["diag"]],["bool"]]],[11,"from","rgsl","",110,[[["value"]],["self"]]],[11,"from","","",3,[[["c_int"]],["value"]]],[11,"from","","",4,[[["c_int"]],["eigensort"]]],[11,"from","","",5,[[["c_int"]],["fftdirection"]]],[11,"from","","",6,[[["c_int"]],["gausskonrodrule"]]],[11,"from","","",7,[[["c_int"]],["integrationqawo"]]],[11,"from","","",8,[[["c_int"]],["vegasmode"]]],[11,"from","","",9,[[["c_int"]],["odeiv"]]],[11,"from","","",10,[[["c_int"]],["waveletdirection"]]],[11,"from","","",11,[[["c_int"]],["sflegendrenorm"]]],[11,"clone","","",2,[[["self"]],["mode"]]],[11,"clone","","",3,[[["self"]],["value"]]],[11,"clone","","",4,[[["self"]],["eigensort"]]],[11,"clone","","",5,[[["self"]],["fftdirection"]]],[11,"clone","","",6,[[["self"]],["gausskonrodrule"]]],[11,"clone","","",7,[[["self"]],["integrationqawo"]]],[11,"clone","","",8,[[["self"]],["vegasmode"]]],[11,"clone","","",9,[[["self"]],["odeiv"]]],[11,"clone","","",10,[[["self"]],["waveletdirection"]]],[11,"clone","","",11,[[["self"]],["sflegendrenorm"]]],[11,"clone","rgsl::types::complex","",17,[[["self"]],["complexf64"]]],[11,"clone","","",18,[[["self"]],["complexf32"]]],[11,"clone","rgsl::types::interpolation","",43,[[["self"]],["interpaccel"]]],[11,"clone","","",45,[[["self"]],["interptype"]]],[11,"clone","rgsl::types::minimizer","",53,[[["self"]],["minimizertype"]]],[11,"clone","rgsl::types::monte_carlo","",56,[[["self"]],["vegasverbosity"]]],[11,"clone","rgsl::types::ordinary_differential_equations","",70,[[["self"]],["odeiv2steptype"]]],[11,"clone","","",72,[[["self"]],["odeiv2controltype"]]],[11,"clone","rgsl::types::qrng","This function returns a pointer to a newly created generator which is an exact copy of the generator self.",77,[[["self"]],["qrng"]]],[11,"clone","","",78,[[["self"]],["qrngtype"]]],[11,"clone","rgsl::types::result","",80,[[["self"]],["result"]]],[11,"clone","","",81,[[["self"]],["resulte10"]]],[11,"clone","rgsl::types::rng","This function returns a pointer to a newly created generator which is an exact copy of the generator r.",82,[[["self"]],["rng"]]],[11,"clone","","",83,[[["self"]],["rngtype"]]],[11,"clone","rgsl::types::wavelet_transforms","",98,[[["self"]],["wavelettype"]]],[11,"clone","rgsl::cblas","",100,[[["self"]],["index"]]],[11,"clone","","",101,[[["self"]],["order"]]],[11,"clone","","",102,[[["self"]],["side"]]],[11,"clone","","",103,[[["self"]],["transpose"]]],[11,"clone","","",104,[[["self"]],["uplo"]]],[11,"clone","","",105,[[["self"]],["diag"]]],[11,"drop","rgsl","",12,[[["self"]]]],[11,"drop","rgsl::types::basis_spline","",13,[[["self"]]]],[11,"drop","","",14,[[["self"]]]],[11,"drop","rgsl::types::chebyshev","",15,[[["self"]]]],[11,"drop","rgsl::types::combination","",16,[[["self"]]]],[11,"drop","rgsl::types::discrete_hankel","",19,[[["self"]]]],[11,"drop","rgsl::types::eigen_symmetric_workspace","",20,[[["self"]]]],[11,"drop","","",21,[[["self"]]]],[11,"drop","","",22,[[["self"]]]],[11,"drop","","",23,[[["self"]]]],[11,"drop","","",24,[[["self"]]]],[11,"drop","","",25,[[["self"]]]],[11,"drop","","",26,[[["self"]]]],[11,"drop","","",27,[[["self"]]]],[11,"drop","","",28,[[["self"]]]],[11,"drop","","",29,[[["self"]]]],[11,"drop","","",30,[[["self"]]]],[11,"drop","","",31,[[["self"]]]],[11,"drop","rgsl::types::fast_fourier_transforms","",32,[[["self"]]]],[11,"drop","","",33,[[["self"]]]],[11,"drop","rgsl::types::histograms","",34,[[["self"]]]],[11,"drop","","",35,[[["self"]]]],[11,"drop","","",36,[[["self"]]]],[11,"drop","","",37,[[["self"]]]],[11,"drop","rgsl::types::integration","",38,[[["self"]]]],[11,"drop","","",39,[[["self"]]]],[11,"drop","","",40,[[["self"]]]],[11,"drop","","",41,[[["self"]]]],[11,"drop","","",42,[[["self"]]]],[11,"drop","rgsl::types::interpolation","",44,[[["self"]]]],[11,"drop","","",46,[[["self"]]]],[11,"drop","rgsl::types::mathieu","",47,[[["self"]]]],[11,"drop","rgsl::types::matrix","",49,[[["self"]]]],[11,"drop","","",50,[[["self"]]]],[11,"drop","rgsl::types::matrix_complex","",51,[[["self"]]]],[11,"drop","","",52,[[["self"]]]],[11,"drop","rgsl::types::minimizer","",54,[[["self"]]]],[11,"drop","rgsl::types::monte_carlo","",57,[[["self"]]]],[11,"drop","","",58,[[["self"]]]],[11,"drop","","",59,[[["self"]]]],[11,"drop","rgsl::types::multifit_solver","",63,[[["self"]]]],[11,"drop","","",64,[[["self"]]]],[11,"drop","rgsl::types::multiset","",66,[[["self"]]]],[11,"drop","rgsl::types::n_tuples","",67,[[["self"]]]],[11,"drop","rgsl::types::ordinary_differential_equations","",69,[[["self"]]]],[11,"drop","","",71,[[["self"]]]],[11,"drop","","",73,[[["self"]]]],[11,"drop","","",74,[[["self"]]]],[11,"drop","rgsl::types::permutation","",75,[[["self"]]]],[11,"drop","rgsl::types::polynomial","",76,[[["self"]]]],[11,"drop","rgsl::types::qrng","",77,[[["self"]]]],[11,"drop","rgsl::types::ran_discrete","",79,[[["self"]]]],[11,"drop","rgsl::types::rng","",82,[[["self"]]]],[11,"drop","rgsl::types::roots","",85,[[["self"]]]],[11,"drop","","",87,[[["self"]]]],[11,"drop","rgsl::types::series_acceleration","",88,[[["self"]]]],[11,"drop","","",89,[[["self"]]]],[11,"drop","rgsl::types::vector","",93,[[["self"]]]],[11,"drop","","",94,[[["self"]]]],[11,"drop","rgsl::types::vector_complex","",95,[[["self"]]]],[11,"drop","","",96,[[["self"]]]],[11,"drop","rgsl::types::wavelet_transforms","",97,[[["self"]]]],[11,"drop","","",99,[[["self"]]]],[11,"fmt","rgsl","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","rgsl::types::combination","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","rgsl::types::complex","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","rgsl::types::matrix","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",50,[[["self"],["formatter"]],["result"]]],[11,"fmt","rgsl::types::matrix_complex","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result"]]],[11,"fmt","rgsl::types::permutation","",75,[[["self"],["formatter"]],["result"]]],[11,"fmt","rgsl::types::vector","",93,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",94,[[["self"],["formatter"]],["result"]]],[11,"fmt","rgsl::types::vector_complex","",95,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",96,[[["self"],["formatter"]],["result"]]],[11,"fmt","rgsl::cblas","",101,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",102,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",103,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",104,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",105,[[["self"],["formatter"]],["result"]]]],"paths":[[3,"RootFunction"],[3,"RootFunctionFdf"],[4,"Mode"],[4,"Value"],[4,"EigenSort"],[4,"FftDirection"],[4,"GaussKonrodRule"],[4,"IntegrationQawo"],[4,"VegasMode"],[4,"ODEiv"],[4,"WaveletDirection"],[4,"SfLegendreNorm"],[3,"IOStream"],[3,"BSpLineWorkspace"],[3,"BSpLineDerivWorkspace"],[3,"ChebSeries"],[3,"Combination"],[3,"ComplexF64"],[3,"ComplexF32"],[3,"DiscreteHankel"],[3,"EigenSymmetricWorkspace"],[3,"EigenSymmetricVWorkspace"],[3,"EigenHermitianWorkspace"],[3,"EigenHermitianVWorkspace"],[3,"EigenNonSymmWorkspace"],[3,"EigenNonSymmVWorkspace"],[3,"EigenGenSymmWorkspace"],[3,"EigenGenSymmVWorkspace"],[3,"EigenGenHermWorkspace"],[3,"EigenGenHermVWorkspace"],[3,"EigenGenWorkspace"],[3,"EigenGenVWorkspace"],[3,"FftComplexWaveTable"],[3,"FftComplexWorkspace"],[3,"Histogram"],[3,"HistogramPdf"],[3,"Histogram2D"],[3,"Histogram2DPdf"],[3,"IntegrationWorkspace"],[3,"IntegrationQawsTable"],[3,"IntegrationQawoTable"],[3,"CquadWorkspace"],[3,"GLFixedTable"],[3,"InterpAccel"],[3,"Interp"],[3,"InterpType"],[3,"Spline"],[3,"MathieuWorkspace"],[3,"MatrixView"],[3,"MatrixF64"],[3,"MatrixF32"],[3,"MatrixComplexF64"],[3,"MatrixComplexF32"],[3,"MinimizerType"],[3,"Minimizer"],[3,"MiserParams"],[4,"VegasVerbosity"],[3,"PlainMonteCarlo"],[3,"MiserMonteCarlo"],[3,"VegasMonteCarlo"],[3,"VegasParams"],[3,"MultiFitFunction"],[3,"MultiFitFunctionFdf"],[3,"MultiFitFSolver"],[3,"MultiFitFdfSolver"],[3,"MultiFitFdfSolverType"],[3,"MultiSet"],[3,"NTuples"],[3,"ODEiv2System"],[3,"ODEiv2Step"],[3,"ODEiv2StepType"],[3,"ODEiv2Control"],[3,"ODEiv2ControlType"],[3,"ODEiv2Evolve"],[3,"ODEiv2Driver"],[3,"Permutation"],[3,"PolyComplex"],[3,"QRng"],[3,"QRngType"],[3,"RanDiscrete"],[3,"Result"],[3,"ResultE10"],[3,"Rng"],[3,"RngType"],[3,"RootFSolverType"],[3,"RootFSolver"],[3,"RootFdfSolverType"],[3,"RootFdfSolver"],[3,"LevinUWorkspace"],[3,"LevinUTruncWorkspace"],[3,"SimAnnealing"],[3,"SimAnnealingParams"],[3,"VectorView"],[3,"VectorF32"],[3,"VectorF64"],[3,"VectorComplexF64"],[3,"VectorComplexF32"],[3,"Wavelet"],[3,"WaveletType"],[3,"WaveletWorkspace"],[3,"Index"],[4,"Order"],[4,"Side"],[4,"Transpose"],[4,"Uplo"],[4,"Diag"],[8,"Elementary"],[8,"Pow"],[8,"Trigonometric"],[3,"MultiFitFSolverType"],[6,"GSLResult"]]};
searchIndex["special_functions"]={"doc":"Library providing pure rust implementation of various special functions, with particular focus to high-energy particle physics.","items":[[0,"bessel","special_functions","Bessel functions",N,N],[5,"k_0","special_functions::bessel","Approximation of modified Bessel function \\(K_0(x)\\) for all \\(x \\geq 0\\).",N,[[["f64"]],["f64"]]],[5,"k_1","","Approximation of modified Bessel function \\(K_1(x)\\) for all \\(x \\geq 0\\).",N,[[["f64"]],["f64"]]],[5,"k_2","","Approximation of modified Bessel function \\(K_2(x)\\) for all \\(x \\geq 0\\).",N,[[["f64"]],["f64"]]],[5,"k_3","","Approximation of modified Bessel function \\(K_3(x)\\) for all \\(x \\geq 0\\).",N,[[["f64"]],["f64"]]],[5,"k_n","","Approximation of modified Bessel function \\(K_n(x)\\) for all \\(x \\geq 0\\).",N,[[["i32"],["f64"]],["f64"]]],[5,"k_1_on_k_2","","Approximation of the ratio \\(K_2(x) / K_1(x)\\) for all \\(x \\geq 0\\). This ratio appears as the dilation factor in (inverse) decay rates of particles.",N,[[["f64"]],["f64"]]],[0,"interpolation","special_functions","Interpolation functions",N,N],[5,"linear","special_functions::interpolation","Perform linear interpolation on data.",N,N],[0,"polylog","special_functions","Polylogarithms",N,N],[5,"bose_einstein","special_functions::polylog","Approximation of polylogarithm appearing in the BoseEinstein statistics. Specifically, this approximates the function \\(\\Li_{3} e^x\\) for \\(x \\leq 0\\).",N,[[["f64"]],["f64"]]],[5,"fermi_dirac","","Approximation of polylogarithm appearing in the FermiDirac statistics. Specifically, this approximates the function \\(-\\Li_{3} (-e^x)\\) for all values of \\(x\\).",N,[[["f64"]],["f64"]]],[0,"polynomial","special_functions","Utilities to handle polynomials",N,N],[5,"polynomial","special_functions::polynomial","Evaluates an arbitrary single-variable polynomial at a particular point.",N,N]],"paths":[]};
initSearch(searchIndex);
