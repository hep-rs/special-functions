<!DOCTYPE html><html lang="en"><head><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'<head>l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N9HX7G4');</script><!-- End Google Tag Manager --><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `/home/travis/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>roots.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css"><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script src="../../../storage.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="shortcut icon" href="../../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../../rgsl/index.html'><div class='logo-container'><img src='../../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../../settings.html"><img src="../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="comment">//</span>
<span class="comment">// A rust binding for the GSL library by Guillaume Gomez (guillaume1.gomez@gmail.com)</span>
<span class="comment">//</span>

<span class="doccomment">/*!
# One dimensional Root-Finding

This chapter describes routines for finding roots of arbitrary one-dimensional functions.
The library provides low level components for a variety of iterative solvers and convergence
tests. These can be combined by the user to achieve the desired solution, with full access to
the intermediate steps of the iteration. Each class of methods uses the same framework, so
that you can switch between solvers at runtime without needing to recompile your program.
Each instance of a solver keeps track of its own state, allowing the solvers to be used in
multi-threaded programs.

## Overview

One-dimensional root finding algorithms can be divided into two classes, root bracketing and
root polishing. Algorithms which proceed by bracketing a root are guaranteed to converge.
Bracketing algorithms begin with a bounded region known to contain a root. The size of
this bounded region is reduced, iteratively, until it encloses the root to a desired tolerance.
This provides a rigorous error estimate for the location of the root.

The technique of root polishing attempts to improve an initial guess to the root. These
algorithms converge only if started “close enough” to a root, and sacrifice a rigorous error
bound for speed. By approximating the behavior of a function in the vicinity of a root they
attempt to find a higher order improvement of an initial guess. When the behavior of the
function is compatible with the algorithm and a good initial guess is available a polishing
algorithm can provide rapid convergence.

In GSL both types of algorithm are available in similar frameworks. The user provides
a high-level driver for the algorithms, and the library provides the individual functions
necessary for each of the steps. There are three main phases of the iteration. The steps are,
• initialize solver state, s, for algorithm T
• update s using the iteration T
• test s for convergence, and repeat iteration if necessary

The state for bracketing solvers is held in a gsl_root_fsolver struct. The updating
procedure uses only function evaluations (not derivatives). The state for root polishing
solvers is held in a gsl_root_fdfsolver struct. The updates require both the function and
its derivative (hence the name fdf) to be supplied by the user.
!*/</span>

<span class="kw">use</span> <span class="ident">ffi</span>;

<span class="doccomment">/// The root bracketing algorithms described in this section require an initial interval which is</span>
<span class="doccomment">/// guaranteed to contain a root—if a and b are the endpoints of the interval then f (a) must</span>
<span class="doccomment">/// differ in sign from f (b). This ensures that the function crosses zero at least once in the</span>
<span class="doccomment">/// interval. If a valid initial interval is used then these algorithm cannot fail, provided the</span>
<span class="doccomment">/// function is well-behaved.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Note that a bracketing algorithm cannot find roots of even degree, since these do not</span>
<span class="doccomment">/// cross the x-axis.</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RootFSolverType</span> {
    <span class="ident">s</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_type</span>,
}

<span class="kw">impl</span> <span class="ident">ffi</span>::<span class="ident">FFI</span><span class="op">&lt;</span><span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_type</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">RootFSolverType</span> {
    <span class="kw">fn</span> <span class="ident">wrap</span>(<span class="ident">r</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_type</span>) <span class="op">-&gt;</span> <span class="ident">RootFSolverType</span> {
        <span class="ident">RootFSolverType</span> { <span class="ident">s</span>: <span class="ident">r</span> }
    }

    <span class="kw">fn</span> <span class="ident">soft_wrap</span>(<span class="ident">r</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_type</span>) <span class="op">-&gt;</span> <span class="ident">RootFSolverType</span> {
        <span class="self">Self</span>::<span class="ident">wrap</span>(<span class="ident">r</span>)
    }

    <span class="kw">fn</span> <span class="ident">unwrap_shared</span>(<span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">RootFSolverType</span>) <span class="op">-&gt;</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_type</span> {
        <span class="ident">s</span>.<span class="ident">s</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="kw">_</span>
    }

    <span class="kw">fn</span> <span class="ident">unwrap_unique</span>(<span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">RootFSolverType</span>) <span class="op">-&gt;</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_type</span> {
        <span class="ident">s</span>.<span class="ident">s</span>
    }
}

<span class="kw">impl</span> <span class="ident">RootFSolverType</span> {
    <span class="doccomment">/// The bisection algorithm is the simplest method of bracketing the roots of a function.</span>
    <span class="doccomment">/// It is the slowest algorithm provided by the library, with linear convergence.</span>
    <span class="doccomment">/// On each iteration, the interval is bisected and the value of the function at the midpoint</span>
    <span class="doccomment">/// is calculated. The sign of this value is used to determine which half of the interval does</span>
    <span class="doccomment">/// not contain a root. That half is discarded to give a new, smaller interval containing</span>
    <span class="doccomment">/// the root. This procedure can be continued indefinitely until the interval is sufficiently</span>
    <span class="doccomment">/// small.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// At any time the current estimate of the root is taken as the midpoint of the interval.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bisection</span>() <span class="op">-&gt;</span> <span class="ident">RootFSolverType</span> {
        <span class="ident">RootFSolverType</span> { <span class="ident">s</span>: <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_bisection</span> } }
    }

    <span class="doccomment">/// The false position algorithm is a method of finding roots based on linear interpolation.</span>
    <span class="doccomment">/// Its convergence is linear, but it is usually faster than bisection.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// On each iteration a line is drawn between the endpoints (a, f (a)) and (b, f (b)) and</span>
    <span class="doccomment">/// the point where this line crosses the x-axis taken as a “midpoint”. The value of the</span>
    <span class="doccomment">/// function at this point is calculated and its sign is used to determine which side of the</span>
    <span class="doccomment">/// interval does not contain a root. That side is discarded to give a new, smaller interval</span>
    <span class="doccomment">/// containing the root. This procedure can be continued indefinitely until the interval</span>
    <span class="doccomment">/// is sufficiently small.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The best estimate of the root is taken from the linear interpolation of the interval on</span>
    <span class="doccomment">/// the current iteration.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">brent</span>() <span class="op">-&gt;</span> <span class="ident">RootFSolverType</span> {
        <span class="ident">RootFSolverType</span> { <span class="ident">s</span>: <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_brent</span> } }
    }

    <span class="doccomment">/// The Brent-Dekker method (referred to here as Brent’s method) combines an interpo-</span>
    <span class="doccomment">/// lation strategy with the bisection algorithm. This produces a fast algorithm which is</span>
    <span class="doccomment">/// still robust.</span>

    <span class="doccomment">/// On each iteration Brent’s method approximates the function using an interpolating</span>
    <span class="doccomment">/// curve. On the first iteration this is a linear interpolation of the two endpoints. For</span>
    <span class="doccomment">/// subsequent iterations the algorithm uses an inverse quadratic fit to the last three</span>
    <span class="doccomment">/// points, for higher accuracy. The intercept of the interpolating curve with the x-axis</span>
    <span class="doccomment">/// is taken as a guess for the root. If it lies within the bounds of the current interval</span>
    <span class="doccomment">/// then the interpolating point is accepted, and used to generate a smaller interval. If</span>
    <span class="doccomment">/// the interpolating point is not accepted then the algorithm falls back to an ordinary</span>
    <span class="doccomment">/// bisection step.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The best estimate of the root is taken from the most recent interpolation or bisection.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">falsepos</span>() <span class="op">-&gt;</span> <span class="ident">RootFSolverType</span> {
        <span class="ident">RootFSolverType</span> { <span class="ident">s</span>: <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_falsepos</span> } }
    }
}

<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">ffi</span>::<span class="ident">gsl_function</span> <span class="kw">as</span> <span class="ident">RootFunction</span>;

<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RootFSolver</span> {
    <span class="ident">s</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver</span>,
}


<span class="kw">impl</span> <span class="ident">RootFSolver</span> {
    <span class="doccomment">/// This function returns a pointer to a newly allocated instance of a solver of type T.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If there is insufficient memory to create the solver then the function returns a null</span>
    <span class="doccomment">/// pointer and the error handler is invoked with an error code of `Value::NoMemory`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">t</span>: <span class="kw-2">&amp;</span><span class="ident">RootFSolverType</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">RootFSolver</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_alloc</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">t</span>)) };

        <span class="kw">if</span> <span class="ident">tmp</span>.<span class="ident">is_null</span>() {
            <span class="prelude-val">None</span>
        } <span class="kw">else</span> {
            <span class="prelude-val">Some</span>(<span class="ident">RootFSolver</span> { <span class="ident">s</span>: <span class="ident">tmp</span> })
        }
    }

    <span class="doccomment">/// This function initializes, or reinitializes, an existing solver s to use the function f and</span>
    <span class="doccomment">/// the initial search interval [x lower, x upper].</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">RootFunction</span>, <span class="ident">x_lower</span>: <span class="ident">f64</span>, <span class="ident">x_upper</span>: <span class="ident">f64</span>) <span class="op">-&gt;</span> ::<span class="ident">Value</span> {
        ::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
            <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_set</span>(<span class="self">self</span>.<span class="ident">s</span>, <span class="ident">f</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">RootFunction</span>, <span class="ident">x_lower</span>, <span class="ident">x_upper</span>)
        })
    }

    <span class="doccomment">/// The following function drives the iteration of each algorithm. Each function performs one</span>
    <span class="doccomment">/// iteration to update the state of any solver of the corresponding type. The same func-</span>
    <span class="doccomment">/// tion works for all solvers so that different methods can be substituted at runtime without</span>
    <span class="doccomment">/// modifications to the code.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This function performs a single iteration of the solver s. If the iteration encounters</span>
    <span class="doccomment">/// an unexpected problem then an error code will be returned.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The solver maintains a current best estimate of the root at all times. The bracketing</span>
    <span class="doccomment">/// solvers also keep track of the current best interval bounding the root.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">iterate</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) <span class="op">-&gt;</span> ::<span class="ident">Value</span> {
        ::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_iterate</span>(<span class="self">self</span>.<span class="ident">s</span>) })
    }

    <span class="doccomment">/// Returns the solver type name.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">name</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">String</span> {
        <span class="kw">unsafe</span> {
            <span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_name</span>(<span class="self">self</span>.<span class="ident">s</span>);

            <span class="ident">String</span>::<span class="ident">from_utf8_lossy</span>(::<span class="ident">std</span>::<span class="ident">ffi</span>::<span class="ident">CStr</span>::<span class="ident">from_ptr</span>(<span class="ident">tmp</span>).<span class="ident">to_bytes</span>()).<span class="ident">to_string</span>()
        }
    }

    <span class="doccomment">/// This function returns the current estimate of the root for the solver s.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">root</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
        <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_root</span>(<span class="self">self</span>.<span class="ident">s</span>) }
    }

    <span class="doccomment">/// These functions return the current bracketing interval for the solver s.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">x_lower</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
        <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_x_lower</span>(<span class="self">self</span>.<span class="ident">s</span>) }
    }

    <span class="doccomment">/// These functions return the current bracketing interval for the solver s.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">x_upper</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
        <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_x_upper</span>(<span class="self">self</span>.<span class="ident">s</span>) }
    }
}

<span class="kw">impl</span> <span class="ident">Drop</span> <span class="kw">for</span> <span class="ident">RootFSolver</span> {
    <span class="kw">fn</span> <span class="ident">drop</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) {
        <span class="kw">if</span> <span class="op">!</span><span class="self">self</span>.<span class="ident">s</span>.<span class="ident">is_null</span>() {
            <span class="kw">unsafe</span> {
                <span class="ident">ffi</span>::<span class="ident">gsl_root_fsolver_free</span>(<span class="self">self</span>.<span class="ident">s</span>);
            }
            <span class="self">self</span>.<span class="ident">s</span> <span class="op">=</span> ::<span class="ident">std</span>::<span class="ident">ptr</span>::<span class="ident">null_mut</span>();
        }
    }
}

<span class="doccomment">/// The root polishing algorithms described in this section require an initial guess for the</span>
<span class="doccomment">/// location of the root. There is no absolute guarantee of convergence—the function must be</span>
<span class="doccomment">/// suitable for this technique and the initial guess must be sufficiently close to the root</span>
<span class="doccomment">/// for it to work. When these conditions are satisfied then convergence is quadratic.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// These algorithms make use of both the function and its derivative.</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RootFdfSolverType</span> {
    <span class="ident">s</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_type</span>,
}

<span class="kw">impl</span> <span class="ident">ffi</span>::<span class="ident">FFI</span><span class="op">&lt;</span><span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_type</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">RootFdfSolverType</span> {
    <span class="kw">fn</span> <span class="ident">wrap</span>(<span class="ident">r</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_type</span>) <span class="op">-&gt;</span> <span class="ident">RootFdfSolverType</span> {
        <span class="ident">RootFdfSolverType</span> { <span class="ident">s</span>: <span class="ident">r</span> }
    }

    <span class="kw">fn</span> <span class="ident">soft_wrap</span>(<span class="ident">r</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_type</span>) <span class="op">-&gt;</span> <span class="ident">RootFdfSolverType</span> {
        <span class="self">Self</span>::<span class="ident">wrap</span>(<span class="ident">r</span>)
    }

    <span class="kw">fn</span> <span class="ident">unwrap_shared</span>(<span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">RootFdfSolverType</span>) <span class="op">-&gt;</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_type</span> {
        <span class="ident">s</span>.<span class="ident">s</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="kw">_</span>
    }

    <span class="kw">fn</span> <span class="ident">unwrap_unique</span>(<span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">RootFdfSolverType</span>) <span class="op">-&gt;</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_type</span> {
        <span class="ident">s</span>.<span class="ident">s</span>
    }
}

<span class="kw">impl</span> <span class="ident">RootFdfSolverType</span> {
    <span class="doccomment">/// Newton’s Method is the standard root-polishing algorithm. The algorithm begins</span>
    <span class="doccomment">/// with an initial guess for the location of the root. On each iteration, a line tangent to</span>
    <span class="doccomment">/// the function f is drawn at that position. The point where this line crosses the x-axis</span>
    <span class="doccomment">/// becomes the new guess.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">newton</span>() <span class="op">-&gt;</span> <span class="ident">RootFdfSolverType</span> {
        <span class="ident">RootFdfSolverType</span> { <span class="ident">s</span>: <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_newton</span> } }
    }

    <span class="doccomment">/// The secant method is a simplified version of Newton’s method which does not require</span>
    <span class="doccomment">/// the computation of the derivative on every step.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">secant</span>() <span class="op">-&gt;</span> <span class="ident">RootFdfSolverType</span> {
        <span class="ident">RootFdfSolverType</span> { <span class="ident">s</span>: <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_secant</span> } }
    }

    <span class="doccomment">/// The Steffenson Method 1 provides the fastest convergence of all the routines. It com-</span>
    <span class="doccomment">/// bines the basic Newton algorithm with an Aitken “delta-squared” acceleration.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">steffenson</span>() <span class="op">-&gt;</span> <span class="ident">RootFdfSolverType</span> {
        <span class="ident">RootFdfSolverType</span> { <span class="ident">s</span>: <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_steffenson</span> } }
    }
}

<span class="kw">pub</span> <span class="kw">use</span> <span class="ident">ffi</span>::<span class="ident">gsl_function_fdf</span> <span class="kw">as</span> <span class="ident">RootFunctionFdf</span>;

<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RootFdfSolver</span> {
    <span class="ident">s</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver</span>,
}

<span class="kw">impl</span> <span class="ident">RootFdfSolver</span> {
    <span class="doccomment">/// This function returns a pointer to a newly allocated instance of a derivative-based</span>
    <span class="doccomment">/// solver of type T.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If there is insufficient memory to create the solver then the function returns a null</span>
    <span class="doccomment">/// pointer and the error handler is invoked with an error code of `Value::NoMemory`.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">t</span>: <span class="kw-2">&amp;</span><span class="ident">RootFdfSolverType</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">RootFdfSolver</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_alloc</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">t</span>)) };

        <span class="kw">if</span> <span class="ident">tmp</span>.<span class="ident">is_null</span>() {
            <span class="prelude-val">None</span>
        } <span class="kw">else</span> {
            <span class="prelude-val">Some</span>(<span class="ident">RootFdfSolver</span> { <span class="ident">s</span>: <span class="ident">tmp</span> })
        }
    }

    <span class="doccomment">/// This function initializes, or reinitializes, an existing solver s to use the function and</span>
    <span class="doccomment">/// derivative fdf and the initial guess root.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">RootFunctionFdf</span>, <span class="ident">root</span>: <span class="ident">f64</span>) <span class="op">-&gt;</span> ::<span class="ident">Value</span> {
        ::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
            <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_set</span>(<span class="self">self</span>.<span class="ident">s</span>, <span class="ident">f</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">RootFunctionFdf</span>, <span class="ident">root</span>)
        })
    }

    <span class="doccomment">/// The following function drives the iteration of each algorithm. Each function performs one</span>
    <span class="doccomment">/// iteration to update the state of any solver of the corresponding type. The same func-</span>
    <span class="doccomment">/// tion works for all solvers so that different methods can be substituted at runtime without</span>
    <span class="doccomment">/// modifications to the code.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This function performs a single iteration of the solver s. If the iteration encounters</span>
    <span class="doccomment">/// an unexpected problem then an error code will be returned.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The solver maintains a current best estimate of the root at all times. The bracketing</span>
    <span class="doccomment">/// solvers also keep track of the current best interval bounding the root.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">iterate</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) <span class="op">-&gt;</span> ::<span class="ident">Value</span> {
        ::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_iterate</span>(<span class="self">self</span>.<span class="ident">s</span>) })
    }

    <span class="doccomment">/// Returns the solver type name.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">name</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">String</span> {
        <span class="kw">unsafe</span> {
            <span class="kw">let</span> <span class="ident">tmp</span> <span class="op">=</span> <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_name</span>(<span class="self">self</span>.<span class="ident">s</span>);

            <span class="ident">String</span>::<span class="ident">from_utf8_lossy</span>(::<span class="ident">std</span>::<span class="ident">ffi</span>::<span class="ident">CStr</span>::<span class="ident">from_ptr</span>(<span class="ident">tmp</span>).<span class="ident">to_bytes</span>()).<span class="ident">to_string</span>()
        }
    }

    <span class="doccomment">/// This function returns the current estimate of the root for the solver s.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">root</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
        <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_root</span>(<span class="self">self</span>.<span class="ident">s</span>) }
    }
}

<span class="kw">impl</span> <span class="ident">Drop</span> <span class="kw">for</span> <span class="ident">RootFdfSolver</span> {
    <span class="kw">fn</span> <span class="ident">drop</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) {
        <span class="kw">if</span> <span class="op">!</span><span class="self">self</span>.<span class="ident">s</span>.<span class="ident">is_null</span>() {
            <span class="kw">unsafe</span> {
                <span class="ident">ffi</span>::<span class="ident">gsl_root_fdfsolver_free</span>(<span class="self">self</span>.<span class="ident">s</span>);
            }
            <span class="self">self</span>.<span class="ident">s</span> <span class="op">=</span> ::<span class="ident">std</span>::<span class="ident">ptr</span>::<span class="ident">null_mut</span>();
        }
    }
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../../";window.currentCrate = "rgsl";</script><script src="../../../aliases.js"></script><script src="../../../main.js"></script><script src="../../../source-script.js"></script><script src="../../../source-files.js"></script><script defer src="../../../search-index.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>MathJax.Hub.Config({TeX: {Macros: {dd: "{\\mathop{}\\!\\mathrm{d}}", textsc: ["\\mathrm{\\scriptsize #1}", 1], vt: ["\\boldsymbol{#1}", 1], pfrac: ["\\frac{\\partial #1}{\\partial #2}", 2], ddfrac: ["\\frac{\\dd #1}{\\dd #2}", 2], defeq: "\\mathrel{\\vcenter:}=", abs: ["\\lvert #1 \\rvert", 1], angles: ["\\langle #1 \\rangle", 1]}}});</script></body></html>