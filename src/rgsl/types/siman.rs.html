<!DOCTYPE html><html lang="en"><head><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'<head>l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N9HX7G4');</script><!-- End Google Tag Manager --><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `/home/travis/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>siman.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css"><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script src="../../../storage.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="shortcut icon" href="../../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../../rgsl/index.html'><div class='logo-container'><img src='../../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../../settings.html"><img src="../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">/*!
# 25 Simulated Annealing

Stochastic search techniques are used when the structure of a space is not well understood or
is not smooth, so that techniques like Newton’s method (which requires calculating Jacobian
derivative matrices) cannot be used. In particular, these techniques are frequently used to
solve combinatorial optimization problems, such as the traveling salesman problem.

The goal is to find a point in the space at which a real valued energy function (or cost
function) is minimized. Simulated annealing is a minimization technique which has given
good results in avoiding local minima; it is based on the idea of taking a random walk
through the space at successively lower temperatures, where the probability of taking a
step is given by a Boltzmann distribution.

The functions described in this chapter are declared in the header file gsl_siman.h.

## Simulated Annealing algorithm

The simulated annealing algorithm takes random walks through the problem space, looking
for points with low energies; in these random walks, the probability of taking a step is
determined by the Boltzmann distribution,

&gt; p = e −(E i+1 −E i )/(kT )
&gt; if E i+1 &gt; E i , and p = 1 when E i+1 ≤ E i

In other words, a step will occur if the new energy is lower. If the new energy is higher,
the transition can still occur, and its likelihood is proportional to the temperature T and
inversely proportional to the energy difference E i+1 − E i .

The temperature T is initially set to a high value, and a random walk is carried out
at that temperature. Then the temperature is lowered very slightly according to a cooling
schedule, for example: T → T /μ T where μ T is slightly greater than 1.

The slight probability of taking a step that gives higher energy is what allows simulated
annealing to frequently get out of local minima.
!*/</span>

<span class="kw">const</span> <span class="ident">GSL_LOG_DBL_MIN</span>: <span class="ident">f64</span> <span class="op">=</span> <span class="op">-</span><span class="number">7.0839641853226408e+02</span>;

<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SimAnnealing</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Clone</span><span class="op">&gt;</span> {
    <span class="ident">x0_p</span>: <span class="ident">T</span>,
    <span class="ident">params</span>: <span class="ident">SimAnnealingParams</span>,
    <span class="ident">Efunc_t</span>: <span class="ident">gsl_siman_Efunc_t</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">step_t</span>: <span class="ident">gsl_siman_step_t</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">metric_t</span>: <span class="ident">gsl_siman_metric_t</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    <span class="ident">print_t</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">gsl_siman_print_t</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;&gt;</span>,
}

<span class="kw">type</span> <span class="ident">gsl_siman_Efunc_t</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw">fn</span>(<span class="kw-2">&amp;</span><span class="ident">T</span>) <span class="op">-&gt;</span> <span class="ident">f64</span>;
<span class="kw">type</span> <span class="ident">gsl_siman_step_t</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw">fn</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">Rng</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">T</span>, <span class="ident">f64</span>);
<span class="kw">type</span> <span class="ident">gsl_siman_metric_t</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw">fn</span>(<span class="kw-2">&amp;</span><span class="ident">T</span>, <span class="kw-2">&amp;</span><span class="ident">T</span>) <span class="op">-&gt;</span> <span class="ident">f64</span>;
<span class="kw">type</span> <span class="ident">gsl_siman_print_t</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw">fn</span>(<span class="kw-2">&amp;</span><span class="ident">T</span>);

<span class="kw">fn</span> <span class="ident">boltzmann</span>(<span class="ident">E</span>: <span class="ident">f64</span>, <span class="ident">new_E</span>: <span class="ident">f64</span>, <span class="ident">T</span>: <span class="ident">f64</span>, <span class="ident">params</span>: <span class="kw-2">&amp;</span><span class="ident">SimAnnealingParams</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
    <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="op">-</span>(<span class="ident">new_E</span> <span class="op">-</span> <span class="ident">E</span>) <span class="op">/</span> (<span class="ident">params</span>.<span class="ident">k</span> <span class="op">*</span> <span class="ident">T</span>);
    <span class="comment">// avoid underflow errors for large uphill steps</span>
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="ident">GSL_LOG_DBL_MIN</span> { <span class="number">0.0</span> } <span class="kw">else</span> { <span class="ident">x</span>.<span class="ident">exp</span>() }
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">SimAnnealing</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
    <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">Clone</span>
{
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">x0_p</span>: <span class="ident">T</span>,
               <span class="ident">ef</span>: <span class="ident">gsl_siman_Efunc_t</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
               <span class="ident">take_step</span>: <span class="ident">gsl_siman_step_t</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
               <span class="ident">distance</span>: <span class="ident">gsl_siman_metric_t</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
               <span class="ident">print_pos</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">gsl_siman_print_t</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;&gt;</span>,
               <span class="ident">params</span>: <span class="ident">SimAnnealingParams</span>)
               <span class="op">-&gt;</span> <span class="ident">SimAnnealing</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
        <span class="ident">SimAnnealing</span> {
            <span class="ident">x0_p</span>: <span class="ident">x0_p</span>,
            <span class="ident">params</span>: <span class="ident">params</span>,
            <span class="ident">Efunc_t</span>: <span class="ident">ef</span>,
            <span class="ident">step_t</span>: <span class="ident">take_step</span>,
            <span class="ident">metric_t</span>: <span class="ident">distance</span>,
            <span class="ident">print_t</span>: <span class="ident">print_pos</span>,
        }
    }

    <span class="comment">/*
    /* implementation of a basic simulated annealing algorithm */

    void 
    gsl_siman_solve (const gsl_rng * r, void *x0_p, gsl_siman_Efunc_t Ef,
                    gsl_siman_step_t take_step,
                    gsl_siman_metric_t distance,
                    gsl_siman_print_t print_position,
                    gsl_siman_copy_t copyfunc,
                    gsl_siman_copy_construct_t copy_constructor,
                    gsl_siman_destroy_t destructor,
                    size_t element_size,
                    gsl_siman_params_t params)
    {
        void *x, *new_x, *best_x;
        double E, new_E, best_E;
        int i;
        double T, T_factor;
        int n_evals = 1, n_iter = 0, n_accepts, n_rejects, n_eless;

        /* this function requires that either the dynamic functions (copy,
            copy_constructor and destrcutor) are passed, or that an element
            size is given */
        assert((copyfunc != NULL &amp;&amp; copy_constructor != NULL &amp;&amp; destructor != NULL)
                || (element_size != 0));

        distance = 0 ; /* This parameter is not currently used */
        E = Ef(x0_p);

        if (copyfunc) {
            x = copy_constructor(x0_p);
            new_x = copy_constructor(x0_p);
            best_x = copy_constructor(x0_p);
        } else {
            x = (void *) malloc (element_size);
            memcpy (x, x0_p, element_size);
            new_x = (void *) malloc (element_size);
            best_x =  (void *) malloc (element_size);
            memcpy (best_x, x0_p, element_size);
        }

        best_E = E;

        T = params.t_initial;
        T_factor = 1.0 / params.mu_t;

        if (print_position) {
            printf (&quot;#-iter  #-evals   temperature     position   energy\n&quot;);
        }

        while (1) {

            n_accepts = 0;
            n_rejects = 0;
            n_eless = 0;

            for (i = 0; i &lt; params.iters_fixed_T; ++i) {

                copy_state(x, new_x, element_size, copyfunc);

                take_step (r, new_x, params.step_size);
                new_E = Ef (new_x);

                if(new_E &lt;= best_E){
                    if (copyfunc) {
                        copyfunc(new_x,best_x);
                    } else {
                        memcpy (best_x, new_x, element_size);
                    }
                    best_E=new_E;
                }

                ++n_evals;                /* keep track of Ef() evaluations */
                /* now take the crucial step: see if the new point is accepted
                    or not, as determined by the boltzmann probability */
                if (new_E &lt; E) {
                    if (new_E &lt; best_E) {
                        copy_state(new_x, best_x, element_size, copyfunc);
                        best_E = new_E;
                    }

                    /* yay! take a step */
                    copy_state(new_x, x, element_size, copyfunc);
                    E = new_E;
                    ++n_eless;

                } else if (gsl_rng_uniform(r) &lt; boltzmann(E, new_E, T, &amp;params)) {
                    /* yay! take a step */
                    copy_state(new_x, x, element_size, copyfunc);
                        E = new_E;
                        ++n_accepts;

                } else {
                    ++n_rejects;
                }
            }

            if (print_position) {
                /* see if we need to print stuff as we go */
                /*       printf(&quot;%5d %12g %5d %3d %3d %3d&quot;, n_iter, T, n_evals, */
                /*           100*n_eless/n_steps, 100*n_accepts/n_steps, */
                /*           100*n_rejects/n_steps); */
                printf (&quot;%5d   %7d  %12g&quot;, n_iter, n_evals, T);
                print_position (x);
                printf (&quot;  %12g  %12g\n&quot;, E, best_E);
            }

            /* apply the cooling schedule to the temperature */
            /* FIXME: I should also introduce a cooling schedule for the iters */
            T *= T_factor;
            ++n_iter;
            if (T &lt; params.t_min) {
                break;
            }
        }

        /* at the end, copy the result onto the initial point, so we pass it
            back to the caller */
        copy_state(best_x, x0_p, element_size, copyfunc);

        if (copyfunc) {
            destructor(x);
            destructor(new_x);
            destructor(best_x);
        } else {
            free (x);
            free (new_x);
            free (best_x);
        }
    }
    */</span>
    <span class="doccomment">/// This function performs a simulated annealing search through a given space. The space</span>
    <span class="doccomment">/// is specified by providing the functions Ef and distance. The simulated annealing steps</span>
    <span class="doccomment">/// are generated using the random number generator `rng` and the function `take_step`.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The starting configuration of the system should be given by x0\_p.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The params structure (described below) controls the run by providing the temperature</span>
    <span class="doccomment">/// schedule and other tunable parameters to the algorithm.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// On exit the best result achieved during the search is returned. If the annealing</span>
    <span class="doccomment">/// process has been successful this should be a good approximation to the optimal point</span>
    <span class="doccomment">/// in the space.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If the argument `print_pos` is not None, a debugging log will be printed to</span>
    <span class="doccomment">/// stdout with the following columns: ```#-iter #-evals temperature position energy best_energy```</span>
    <span class="doccomment">/// and the output of the function print position itself.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">solve</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">rng</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">Rng</span>) <span class="op">-&gt;</span> <span class="ident">T</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">x0_p</span>.<span class="ident">clone</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">new_x</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">x0_p</span>.<span class="ident">clone</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">best_x</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">x0_p</span>.<span class="ident">clone</span>();

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">n_evals</span> <span class="op">=</span> <span class="number">0_usize</span>;

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">E</span> <span class="op">=</span> (<span class="self">self</span>.<span class="ident">Efunc_t</span>)(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">x0_p</span>);
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">best_E</span> <span class="op">=</span> <span class="ident">E</span>;

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">Temp</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">params</span>.<span class="ident">t_initial</span>;
        <span class="kw">let</span> <span class="ident">Temp_factor</span> <span class="op">=</span> <span class="number">1.0</span> <span class="op">/</span> <span class="self">self</span>.<span class="ident">params</span>.<span class="ident">mu_t</span>;

        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">print_t</span>.<span class="ident">is_some</span>() {
            <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{i:^6} | {e:^7} | {t:^12} | {p:^15} | {E:^13}&quot;</span>,
                     <span class="ident">i</span> <span class="op">=</span> <span class="string">&quot;#-iter&quot;</span>,
                     <span class="ident">e</span> <span class="op">=</span> <span class="string">&quot;#-evals&quot;</span>,
                     <span class="ident">t</span> <span class="op">=</span> <span class="string">&quot;temperature&quot;</span>,
                     <span class="ident">p</span> <span class="op">=</span> <span class="string">&quot;position&quot;</span>,
                     <span class="ident">E</span> <span class="op">=</span> <span class="string">&quot;energy&quot;</span>);
        }

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="number">0</span>;
        <span class="kw">loop</span> {
            <span class="comment">//let mut n_accepts = 0;</span>
            <span class="comment">//let mut n_rejects = 0;</span>
            <span class="comment">//let mut n_eless = 0;</span>

            <span class="kw">for</span> <span class="kw">_</span> <span class="kw">in</span> <span class="number">0</span>..<span class="self">self</span>.<span class="ident">params</span>.<span class="ident">iters_fixed_T</span> {
                <span class="ident">x</span> <span class="op">=</span> <span class="ident">new_x</span>.<span class="ident">clone</span>();

                (<span class="self">self</span>.<span class="ident">step_t</span>)(<span class="ident">rng</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">new_x</span>, <span class="self">self</span>.<span class="ident">params</span>.<span class="ident">step_size</span>);
                <span class="kw">let</span> <span class="ident">new_E</span> <span class="op">=</span> (<span class="self">self</span>.<span class="ident">Efunc_t</span>)(<span class="kw-2">&amp;</span><span class="ident">new_x</span>);
                <span class="ident">n_evals</span> <span class="op">+=</span> <span class="number">1</span>; <span class="comment">// keep track of Ef() evaluations</span>

                <span class="kw">if</span> <span class="ident">new_E</span> <span class="op">&lt;=</span> <span class="ident">best_E</span> {
                    <span class="ident">best_x</span> <span class="op">=</span> <span class="ident">new_x</span>.<span class="ident">clone</span>();
                    <span class="ident">best_E</span> <span class="op">=</span> <span class="ident">new_E</span>;
                }

                <span class="comment">// now take the crucial step: see if the new point is accepted</span>
                <span class="comment">// or not, as determined by the boltzmann probability</span>
                <span class="kw">if</span> <span class="ident">new_E</span> <span class="op">&lt;</span> <span class="ident">E</span> {
                    <span class="kw">if</span> <span class="ident">new_E</span> <span class="op">&lt;</span> <span class="ident">best_E</span> {
                        <span class="ident">best_x</span> <span class="op">=</span> <span class="ident">new_x</span>.<span class="ident">clone</span>();
                        <span class="ident">best_E</span> <span class="op">=</span> <span class="ident">new_E</span>;
                    }
                    <span class="comment">// yay! take a step</span>
                    <span class="ident">x</span> <span class="op">=</span> <span class="ident">new_x</span>.<span class="ident">clone</span>();
                    <span class="ident">E</span> <span class="op">=</span> <span class="ident">new_E</span>;
                    <span class="comment">//n_eless += 1;</span>
                } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">rng</span>.<span class="ident">uniform</span>() <span class="op">&lt;</span> <span class="ident">boltzmann</span>(<span class="ident">E</span>, <span class="ident">new_E</span>, <span class="ident">Temp</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">params</span>) {
                    <span class="comment">// yay! take a step</span>
                    <span class="ident">x</span> <span class="op">=</span> <span class="ident">new_x</span>.<span class="ident">clone</span>();
                    <span class="ident">E</span> <span class="op">=</span> <span class="ident">new_E</span>;
                    <span class="comment">//n_accepts += 1;</span>
                }
            }

            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">ref</span> <span class="ident">printf</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">print_t</span> {
                <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;{:&gt;06} | {:&gt;07} | {:&gt;12.10} | &quot;</span>, <span class="ident">iter</span>, <span class="ident">n_evals</span>, <span class="ident">Temp</span>);
                <span class="ident">printf</span>(<span class="kw-2">&amp;</span><span class="ident">x</span>);
                <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot; | {:+&gt;13.12}&quot;</span>, <span class="ident">E</span>);
            }

            <span class="ident">Temp</span> <span class="op">*=</span> <span class="ident">Temp_factor</span>;
            <span class="ident">iter</span> <span class="op">+=</span> <span class="number">1</span>;
            <span class="kw">if</span> <span class="ident">Temp</span> <span class="op">&lt;</span> <span class="self">self</span>.<span class="ident">params</span>.<span class="ident">t_min</span> {
                <span class="kw">break</span>;
            }
        }

        <span class="ident">best_x</span>
    }


    <span class="comment">/*
    /* implementation of a simulated annealing algorithm with many tries */

    void 
    gsl_siman_solve_many (const gsl_rng * r, void *x0_p, gsl_siman_Efunc_t Ef,
                        gsl_siman_step_t take_step,
                        gsl_siman_metric_t distance,
                        gsl_siman_print_t print_position,
                        size_t element_size,
                        gsl_siman_params_t params)
    {
        /* the new set of trial points, and their energies and probabilities */
        void *x, *new_x;
        double *energies, *probs, *sum_probs;
        double Ex;                    /* energy of the chosen point */
        double T, T_factor;           /* the temperature and a step multiplier */
        int i;
        double u;                     /* throw the die to choose a new &quot;x&quot; */
        int n_iter;

        if (print_position) {
            printf (&quot;#-iter    temperature       position&quot;);
            printf (&quot;         delta_pos        energy\n&quot;);
        }

        x = (void *) malloc (params.n_tries * element_size);
        new_x = (void *) malloc (params.n_tries * element_size);
        energies = (double *) malloc (params.n_tries * sizeof (double));
        probs = (double *) malloc (params.n_tries * sizeof (double));
        sum_probs = (double *) malloc (params.n_tries * sizeof (double));

        T = params.t_initial;
        T_factor = 1.0 / params.mu_t;

        memcpy (x, x0_p, element_size);

        n_iter = 0;
        while (1)
            {
            Ex = Ef (x);
            for (i = 0; i &lt; params.n_tries - 1; ++i)
                {                       /* only go to N_TRIES-2 */
                /* center the new_x[] around x, then pass it to take_step() */
                sum_probs[i] = 0;
                memcpy ((char *)new_x + i * element_size, x, element_size);
                take_step (r, (char *)new_x + i * element_size, params.step_size);
                energies[i] = Ef ((char *)new_x + i * element_size);
                probs[i] = boltzmann(Ex, energies[i], T, &amp;params);
                }
            /* now add in the old value of &quot;x&quot;, so it is a contendor */
            memcpy ((char *)new_x + (params.n_tries - 1) * element_size, x, element_size);
            energies[params.n_tries - 1] = Ex;
            probs[params.n_tries - 1] = boltzmann(Ex, energies[i], T, &amp;params);

            /* now throw biased die to see which new_x[i] we choose */
            sum_probs[0] = probs[0];
            for (i = 1; i &lt; params.n_tries; ++i)
                {
                sum_probs[i] = sum_probs[i - 1] + probs[i];
                }
            u = gsl_rng_uniform (r) * sum_probs[params.n_tries - 1];
            for (i = 0; i &lt; params.n_tries; ++i)
                {
                if (u &lt; sum_probs[i])
                    {
                    memcpy (x, (char *) new_x + i * element_size, element_size);
                    break;
                    }
                }
            if (print_position)
                {
                printf (&quot;%5d\t%12g\t&quot;, n_iter, T);
                print_position (x);
                printf (&quot;\t%12g\t%12g\n&quot;, distance (x, x0_p), Ex);
                }
            T *= T_factor;
            ++n_iter;
            if (T &lt; params.t_min)
            {
            break;
                }
            }

        /* now return the value via x0_p */
        memcpy (x0_p, x, element_size);

        /*  printf(&quot;the result is: %g (E=%g)\n&quot;, x, Ex); */

        free (x);
        free (new_x);
        free (energies);
        free (probs);
        free (sum_probs);
    }
    */</span>
    <span class="doccomment">/// Like the function solve, but performs multiple runs and returns the best result.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">solve_many</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">rng</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">Rng</span>) <span class="op">-&gt;</span> <span class="ident">T</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">x0_p</span>.<span class="ident">clone</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">new_x</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="self">self</span>.<span class="ident">params</span>.<span class="ident">n_tries</span>);

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">energies</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="self">self</span>.<span class="ident">params</span>.<span class="ident">n_tries</span>);
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">probs</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="self">self</span>.<span class="ident">params</span>.<span class="ident">n_tries</span>);
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sum_probs</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="self">self</span>.<span class="ident">params</span>.<span class="ident">n_tries</span>);

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">Temp</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">params</span>.<span class="ident">t_initial</span>;
        <span class="kw">let</span> <span class="ident">Temp_factor</span> <span class="op">=</span> <span class="number">1.0</span> <span class="op">/</span> <span class="self">self</span>.<span class="ident">params</span>.<span class="ident">mu_t</span>;

        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">print_t</span>.<span class="ident">is_some</span>() {
            <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{i:^6} | {t:^12} | {p:^15} | {d:^15} | {E:^13}&quot;</span>,
                     <span class="ident">i</span> <span class="op">=</span> <span class="string">&quot;#-iter&quot;</span>,
                     <span class="ident">t</span> <span class="op">=</span> <span class="string">&quot;temperature&quot;</span>,
                     <span class="ident">p</span> <span class="op">=</span> <span class="string">&quot;position&quot;</span>,
                     <span class="ident">d</span> <span class="op">=</span> <span class="string">&quot;delta_pos&quot;</span>,
                     <span class="ident">E</span> <span class="op">=</span> <span class="string">&quot;energy&quot;</span>);
        }

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="number">0</span>;
        <span class="kw">loop</span> {
            <span class="kw">let</span> <span class="ident">Ex</span> <span class="op">=</span> (<span class="self">self</span>.<span class="ident">Efunc_t</span>)(<span class="kw-2">&amp;</span><span class="ident">x</span>);
            <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="self">self</span>.<span class="ident">params</span>.<span class="ident">n_tries</span> <span class="op">-</span> <span class="number">1</span> {
                <span class="comment">// only go to N_TRIES-2</span>
                <span class="ident">sum_probs</span>.<span class="ident">push</span>(<span class="number">0.0</span>);
                <span class="ident">new_x</span>.<span class="ident">push</span>(<span class="ident">x</span>.<span class="ident">clone</span>());

                (<span class="self">self</span>.<span class="ident">step_t</span>)(<span class="ident">rng</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">new_x</span>[<span class="ident">i</span>], <span class="self">self</span>.<span class="ident">params</span>.<span class="ident">step_size</span>);
                <span class="ident">energies</span>.<span class="ident">push</span>((<span class="self">self</span>.<span class="ident">Efunc_t</span>)(<span class="kw-2">&amp;</span><span class="ident">new_x</span>[<span class="ident">i</span>]));
                <span class="ident">probs</span>.<span class="ident">push</span>(<span class="ident">boltzmann</span>(<span class="ident">Ex</span>, <span class="ident">energies</span>[<span class="ident">i</span>], <span class="ident">Temp</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">params</span>));
            }

            <span class="comment">// now add in the old value of &quot;x&quot;, so it is a contendor</span>
            <span class="ident">new_x</span>.<span class="ident">push</span>(<span class="ident">x</span>.<span class="ident">clone</span>());
            <span class="ident">energies</span>.<span class="ident">push</span>(<span class="ident">Ex</span>);
            <span class="ident">probs</span>.<span class="ident">push</span>(<span class="ident">boltzmann</span>(<span class="ident">Ex</span>, <span class="ident">energies</span>[<span class="self">self</span>.<span class="ident">params</span>.<span class="ident">n_tries</span> <span class="op">-</span> <span class="number">2</span>], <span class="ident">Temp</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">params</span>));
            <span class="ident">sum_probs</span>.<span class="ident">push</span>(<span class="number">0.0</span>);

            <span class="comment">// now throw biased die to see which new_x[i] we choose</span>
            <span class="ident">sum_probs</span>[<span class="number">0</span>] <span class="op">=</span> <span class="ident">probs</span>[<span class="number">0</span>];
            <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">1</span>..<span class="self">self</span>.<span class="ident">params</span>.<span class="ident">n_tries</span> {
                <span class="ident">sum_probs</span>[<span class="ident">i</span>] <span class="op">=</span> <span class="ident">sum_probs</span>[<span class="ident">i</span> <span class="op">-</span> <span class="number">1</span>] <span class="op">+</span> <span class="ident">probs</span>[<span class="ident">i</span>];
            }
            <span class="kw">let</span> <span class="ident">u</span> <span class="op">=</span> <span class="ident">rng</span>.<span class="ident">uniform</span>() <span class="op">*</span> <span class="kw-2">*</span><span class="ident">sum_probs</span>.<span class="ident">last</span>().<span class="ident">unwrap</span>();
            <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="self">self</span>.<span class="ident">params</span>.<span class="ident">n_tries</span> {
                <span class="kw">if</span> <span class="kw-2">&amp;</span><span class="ident">u</span> <span class="op">&lt;</span> <span class="kw-2">&amp;</span><span class="ident">sum_probs</span>[<span class="ident">i</span>] {
                    <span class="ident">x</span> <span class="op">=</span> <span class="ident">new_x</span>[<span class="ident">i</span>].<span class="ident">clone</span>();
                    <span class="kw">break</span>;
                }
            }

            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">ref</span> <span class="ident">printf</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">print_t</span> {
                <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;{:&gt;06} | {:&gt;12.10} | &quot;</span>, <span class="ident">iter</span>, <span class="ident">Temp</span>);
                <span class="ident">printf</span>(<span class="kw-2">&amp;</span><span class="ident">x</span>);
                <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot; | {: &gt;15.12} | {: &gt;13.12}&quot;</span>,
                         (<span class="self">self</span>.<span class="ident">metric_t</span>)(<span class="kw-2">&amp;</span><span class="ident">x</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">x0_p</span>),
                         <span class="ident">Ex</span>);
            }

            <span class="ident">Temp</span> <span class="op">*=</span> <span class="ident">Temp_factor</span>;
            <span class="ident">iter</span> <span class="op">+=</span> <span class="number">1</span>;
            <span class="kw">if</span> <span class="ident">Temp</span> <span class="op">&lt;</span> <span class="self">self</span>.<span class="ident">params</span>.<span class="ident">t_min</span> {
                <span class="kw">break</span>;
            }
        }
        <span class="ident">x</span>
    }
}

<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SimAnnealingParams</span> {
    <span class="ident">n_tries</span>: <span class="ident">usize</span>,
    <span class="ident">iters_fixed_T</span>: <span class="ident">usize</span>,
    <span class="ident">step_size</span>: <span class="ident">f64</span>,
    <span class="ident">k</span>: <span class="ident">f64</span>,
    <span class="ident">t_initial</span>: <span class="ident">f64</span>,
    <span class="ident">mu_t</span>: <span class="ident">f64</span>,
    <span class="ident">t_min</span>: <span class="ident">f64</span>,
}

<span class="kw">impl</span> <span class="ident">SimAnnealingParams</span> {
    <span class="doccomment">/// These are the parameters that control a run of the simulated annealing algorithm.</span>
    <span class="doccomment">/// This structure contains all the information needed to control the search,</span>
    <span class="doccomment">/// beyond the energy function, the step function and the initial guess.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// - n_tries: The number of points to try for each step.</span>
    <span class="doccomment">/// - iters: The number of iterations at each temperature.</span>
    <span class="doccomment">/// - step_size: The maximum step size in the random walk.</span>
    <span class="doccomment">/// - k, t_initial, mu_t, t_min: The parameters of the Boltzmann distribution and</span>
    <span class="doccomment">///   cooling schedule.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">n_tries</span>: <span class="ident">usize</span>,
               <span class="ident">iters</span>: <span class="ident">usize</span>,
               <span class="ident">step_size</span>: <span class="ident">f64</span>,
               <span class="ident">k</span>: <span class="ident">f64</span>,
               <span class="ident">t_initial</span>: <span class="ident">f64</span>,
               <span class="ident">mut_t</span>: <span class="ident">f64</span>,
               <span class="ident">t_min</span>: <span class="ident">f64</span>)
               <span class="op">-&gt;</span> <span class="ident">SimAnnealingParams</span> {
        <span class="ident">SimAnnealingParams</span> {
            <span class="ident">n_tries</span>: <span class="ident">n_tries</span>,
            <span class="ident">iters_fixed_T</span>: <span class="ident">iters</span>,
            <span class="ident">step_size</span>: <span class="ident">step_size</span>,
            <span class="ident">k</span>: <span class="ident">k</span>,
            <span class="ident">t_initial</span>: <span class="ident">t_initial</span>,
            <span class="ident">mu_t</span>: <span class="ident">mut_t</span>,
            <span class="ident">t_min</span>: <span class="ident">t_min</span>,
        }
    }
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../../";window.currentCrate = "rgsl";</script><script src="../../../aliases.js"></script><script src="../../../main.js"></script><script src="../../../source-script.js"></script><script src="../../../source-files.js"></script><script defer src="../../../search-index.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>MathJax.Hub.Config({TeX: {Macros: {dd: "{\\mathop{}\\!\\mathrm{d}}", textsc: ["\\mathrm{\\scriptsize #1}", 1], vt: ["\\boldsymbol{#1}", 1], pfrac: ["\\frac{\\partial #1}{\\partial #2}", 2], ddfrac: ["\\frac{\\dd #1}{\\dd #2}", 2], defeq: "\\mathrel{\\vcenter:}=", abs: ["\\lvert #1 \\rvert", 1], angles: ["\\langle #1 \\rangle", 1]}}});</script></body></html>