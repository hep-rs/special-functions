<!DOCTYPE html><html lang="en"><head><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'<head>l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N9HX7G4');</script><!-- End Google Tag Manager --><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `/home/travis/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>fft.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../rgsl/index.html'><img src='../../rust-logo.png' alt='logo' width='100'></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="comment">//</span>
<span class="comment">// A rust binding for the GSL library by Guillaume Gomez (guillaume1.gomez@gmail.com)</span>
<span class="comment">//</span>

<span class="doccomment">/*!
#Fast Fourier Transforms (FFTs)

This chapter describes functions for performing Fast Fourier Transforms (FFTs). The library includes radix-2 routines (for lengths which are
a power of two) and mixed-radix routines (which work for any length). For efficiency there are separate versions of the routines for real data
and for complex data. The mixed-radix routines are a reimplementation of the FFTPACK library of Paul Swarztrauber. Fortran code for FFTPACK
is available on Netlib (FFTPACK also includes some routines for sine and cosine transforms but these are currently not available in GSL). For
details and derivations of the underlying algorithms consult the document GSL FFT Algorithms (see FFT References and Further Reading)

##Mathematical Definitions

Fast Fourier Transforms are efficient algorithms for calculating the discrete Fourier transform (DFT),

x_j = \sum_{k=0}^{n-1} z_k \exp(-2\pi i j k / n)

The DFT usually arises as an approximation to the continuous Fourier transform when functions are sampled at discrete intervals in space or time.
The naive evaluation of the discrete Fourier transform is a matrix-vector multiplication W\vec{z}. A general matrix-vector multiplication takes
O(n^2) operations for n data-points. Fast Fourier transform algorithms use a divide-and-conquer strategy to factorize the matrix W into smaller
sub-matrices, corresponding to the integer factors of the length n. If n can be factorized into a product of integers f_1 f_2 ... f_m then the
DFT can be computed in O(n \sum f_i) operations. For a radix-2 FFT this gives an operation count of O(n \log_2 n).

All the FFT functions offer three types of transform: forwards, inverse and backwards, based on the same mathematical definitions. The definition
of the forward Fourier transform, x = FFT(z), is,

x_j = \sum_{k=0}^{n-1} z_k \exp(-2\pi i j k / n)

and the definition of the inverse Fourier transform, x = IFFT(z), is,

z_j = {1 \over n} \sum_{k=0}^{n-1} x_k \exp(2\pi i j k / n).
The factor of 1/n makes this a true inverse. For example, a call to gsl_fft_complex_forward followed by a call to gsl_fft_complex_inverse should
return the original data (within numerical errors).

In general there are two possible choices for the sign of the exponential in the transform/ inverse-transform pair. GSL follows the same convention
as FFTPACK, using a negative exponential for the forward transform. The advantage of this convention is that the inverse transform recreates the
original function with simple Fourier synthesis. Numerical Recipes uses the opposite convention, a positive exponential in the forward transform.

The backwards FFT is simply our terminology for an unscaled version of the inverse FFT,

z^{backwards}_j = \sum_{k=0}^{n-1} x_k \exp(2\pi i j k / n).

When the overall scale of the result is unimportant it is often convenient to use the backwards FFT instead of the inverse to save unnecessary
divisions.

##Overview of complex data FFTs

The inputs and outputs for the complex FFT routines are packed arrays of floating point numbers. In a packed array the real and imaginary parts
of each complex number are placed in alternate neighboring elements. For example, the following definition of a packed array of length 6,

```C
double x[3*2];
gsl_complex_packed_array data = x;
// can be used to hold an array of three complex numbers, z[3], in the following way,

data[0] = Re(z[0])
data[1] = Im(z[0])
data[2] = Re(z[1])
data[3] = Im(z[1])
data[4] = Re(z[2])
data[5] = Im(z[2])
```

The array indices for the data have the same ordering as those in the definition of the DFT—i.e. there are no index transformations or
permutations of the data.

A stride parameter allows the user to perform transforms on the elements z[stride*i] instead of z[i]. A stride greater than 1 can be used
to take an in-place FFT of the column of a matrix. A stride of 1 accesses the array without any additional spacing between elements.

To perform an FFT on a vector argument, such as gsl_vector_complex * v, use the following definitions (or their equivalents) when calling
the functions described in this chapter:

gsl_complex_packed_array data = v-&gt;data;
size_t stride = v-&gt;stride;
size_t n = v-&gt;size;
For physical applications it is important to remember that the index appearing in the DFT does not correspond directly to a physical frequency.
If the time-step of the DFT is \Delta then the frequency-domain includes both positive and negative frequencies, ranging from -1/(2\Delta)
through 0 to +1/(2\Delta). The positive frequencies are stored from the beginning of the array up to the middle, and the negative frequencies
are stored backwards from the end of the array.

Here is a table which shows the layout of the array data, and the correspondence between the time-domain data z, and the frequency-domain
data x.

index    z               x = FFT(z)

0        z(t = 0)        x(f = 0)
1        z(t = 1)        x(f = 1/(n Delta))
2        z(t = 2)        x(f = 2/(n Delta))
.        ........        ..................
n/2      z(t = n/2)      x(f = +1/(2 Delta),
                               -1/(2 Delta))
.        ........        ..................
n-3      z(t = n-3)      x(f = -3/(n Delta))
n-2      z(t = n-2)      x(f = -2/(n Delta))
n-1      z(t = n-1)      x(f = -1/(n Delta))

When n is even the location n/2 contains the most positive and negative frequencies (+1/(2 \Delta), -1/(2 \Delta)) which are equivalent. If
n is odd then general structure of the table above still applies, but n/2 does not appear.

#Radix-2 FFT routines for complex data

The radix-2 algorithms described in this section are simple and compact, although not necessarily the most efficient. They use the Cooley-Tukey
algorithm to compute in-place complex FFTs for lengths which are a power of 2—no additional storage is required. The corresponding self-sorting
mixed-radix routines offer better performance at the expense of requiring additional working space.

##Mixed-radix FFT routines for complex data

This section describes mixed-radix FFT algorithms for complex data. The mixed-radix functions work for FFTs of any length. They are a
reimplementation of Paul Swarztrauber’s Fortran FFTPACK library. The theory is explained in the review article Self-sorting Mixed-radix FFTs
by Clive Temperton. The routines here use the same indexing scheme and basic algorithms as FFTPACK.

The mixed-radix algorithm is based on sub-transform modules—highly optimized small length FFTs which are combined to create larger FFTs. There
are efficient modules for factors of 2, 3, 4, 5, 6 and 7. The modules for the composite factors of 4 and 6 are faster than combining the modules
for 2*2 and 2*3.

For factors which are not implemented as modules there is a fall-back to a general length-n module which uses Singleton’s method for efficiently
computing a DFT. This module is O(n^2), and slower than a dedicated module would be but works for any length n. Of course, lengths which use the
general length-n module will still be factorized as much as possible. For example, a length of 143 will be factorized into 11*13. Large prime
factors are the worst case scenario, e.g. as found in n=2*3*99991, and should be avoided because their O(n^2) scaling will dominate the run-time
(consult the document GSL FFT Algorithms included in the GSL distribution if you encounter this problem).

The mixed-radix initialization function gsl_fft_complex_wavetable_alloc returns the list of factors chosen by the library for a given length n.
It can be used to check how well the length has been factorized, and estimate the run-time. To a first approximation the run-time scales as
n \sum f_i, where the f_i are the factors of n. For programs under user control you may wish to issue a warning that the transform will be slow
when the length is poorly factorized. If you frequently encounter data lengths which cannot be factorized using the existing small-prime modules
consult GSL FFT Algorithms for details on adding support for other factors.

##Overview of real data FFTs

The functions for real data are similar to those for complex data. However, there is an important difference between forward and inverse transforms.
The Fourier transform of a real sequence is not real. It is a complex sequence with a special symmetry:

z_k = z_{n-k}^*

A sequence with this symmetry is called conjugate-complex or half-complex. This different structure requires different storage layouts for the
forward transform (from real to half-complex) and inverse transform (from half-complex back to real). As a consequence the routines are divided
into two sets: functions in gsl_fft_real which operate on real sequences and functions in gsl_fft_halfcomplex which operate on half-complex sequences.

Functions in gsl_fft_real compute the frequency coefficients of a real sequence. The half-complex coefficients c of a real sequence x are given
by Fourier analysis,

c_k = \sum_{j=0}^{n-1} x_j \exp(-2 \pi i j k /n)

Functions in gsl_fft_halfcomplex compute inverse or backwards transforms. They reconstruct real sequences by Fourier synthesis from their half-complex
frequency coefficients, c,

x_j = {1 \over n} \sum_{k=0}^{n-1} c_k \exp(2 \pi i j k /n)

The symmetry of the half-complex sequence implies that only half of the complex numbers in the output need to be stored. The remaining half can be
reconstructed using the half-complex symmetry condition. This works for all lengths, even and odd—when the length is even the middle value where k=n/2
is also real. Thus only n real numbers are required to store the half-complex sequence, and the transform of a real sequence can be stored in the
same size array as the original data.

The precise storage arrangements depend on the algorithm, and are different for radix-2 and mixed-radix routines. The radix-2 function operates
in-place, which constrains the locations where each element can be stored. The restriction forces real and imaginary parts to be stored far apart.
The mixed-radix algorithm does not have this restriction, and it stores the real and imaginary parts of a given term in neighboring locations (which
is desirable for better locality of memory accesses).
!*/</span>

<span class="doccomment">/// These functions compute forward, backward and inverse FFTs of length n with stride stride, on the packed complex array data using an in-place radix-2</span>
<span class="doccomment">/// decimation-in-time algorithm. The length of the transform is restricted to powers of two. For the transform version of the function</span>
<span class="doccomment">/// the sign argument can be either forward (-1) or backward (+1).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The functions return a value of ::Value::Success if no errors were detected, or Value::Dom if the length n is not a power of two.</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">radix2</span> {
    <span class="kw">use</span> <span class="ident">enums</span>;
    <span class="kw">use</span> <span class="ident">ffi</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">forward</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_complex_radix2_forward</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) })
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">transform</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">sign</span>: ::<span class="ident">FftDirection</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_complex_radix2_transform</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">sign</span>.<span class="ident">into</span>()) })
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">backward</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_complex_radix2_backward</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) })
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">inverse</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_complex_radix2_inverse</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) })
    }

    <span class="doccomment">/// This is decimation-in-frequency version of the radix-2 FFT function.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">dif_forward</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_complex_radix2_dif_forward</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) })
    }

    <span class="doccomment">/// This is decimation-in-frequency version of the radix-2 FFT function.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">dif_transform</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">sign</span>: ::<span class="ident">FftDirection</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_complex_radix2_dif_transform</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">sign</span>.<span class="ident">into</span>()) })
    }

    <span class="doccomment">/// This is decimation-in-frequency version of the radix-2 FFT function.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">dif_backward</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_complex_radix2_dif_backward</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) })
    }

    <span class="doccomment">/// This is decimation-in-frequency version of the radix-2 FFT function.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">dif_inverse</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span>[<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_complex_radix2_dif_inverse</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) })
    }
}

<span class="doccomment">/// These functions compute forward, backward and inverse FFTs of length n with stride stride, on the packed complex array data, using a</span>
<span class="doccomment">/// mixed radix decimation-in-frequency algorithm. There is no restriction on the length n. Efficient modules are provided for subtransforms</span>
<span class="doccomment">/// of length 2, 3, 4, 5, 6 and 7. Any remaining factors are computed with a slow, O(n^2), general-n module. The caller must supply a</span>
<span class="doccomment">/// wavetable containing the trigonometric lookup tables and a workspace work. For the transform version of the function the sign argument</span>
<span class="doccomment">/// can be either forward (-1) or backward (+1).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The functions return a value of 0 if no errors were detected. The following gsl_errno conditions are defined for these functions:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Value::Dom</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The length of the data n is not a positive integer (i.e. n is zero).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Value::Invalid</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The length of the data n and the length used to compute the given wavetable do not match.</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">mixed_radix</span> {
    <span class="kw">use</span> <span class="ident">enums</span>;
    <span class="kw">use</span> <span class="ident">ffi</span>;
    <span class="kw">use</span> <span class="ident">types</span>::{<span class="ident">FftComplexWaveTable</span>, <span class="ident">FftComplexWorkspace</span>};

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">forward</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">wavetable</span>: <span class="kw-2">&amp;</span><span class="ident">FftComplexWaveTable</span>, <span class="ident">work</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">FftComplexWorkspace</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_complex_forward</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">wavetable</span>),
            <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">work</span>)) })
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">transform</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">wavetable</span>: <span class="kw-2">&amp;</span><span class="ident">FftComplexWaveTable</span>, <span class="ident">work</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">FftComplexWorkspace</span>, <span class="ident">sign</span>: ::<span class="ident">FftDirection</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_complex_transform</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">wavetable</span>),
            <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">work</span>), <span class="ident">sign</span>.<span class="ident">into</span>()) })
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">backward</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">wavetable</span>: <span class="kw-2">&amp;</span><span class="ident">FftComplexWaveTable</span>, <span class="ident">work</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">FftComplexWorkspace</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_complex_backward</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">wavetable</span>),
            <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">work</span>)) })
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">inverse</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>, <span class="ident">wavetable</span>: <span class="kw-2">&amp;</span><span class="ident">FftComplexWaveTable</span>, <span class="ident">work</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">FftComplexWorkspace</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_complex_inverse</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>, <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">wavetable</span>),
            <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">work</span>)) })
    }
}

<span class="doccomment">/// This section describes radix-2 FFT algorithms for real data. They use the Cooley-Tukey algorithm to compute in-place FFTs for lengths which</span>
<span class="doccomment">/// are a power of 2.</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">real_radix2</span> {
    <span class="kw">use</span> <span class="ident">ffi</span>;
    <span class="kw">use</span> <span class="ident">enums</span>;

    <span class="doccomment">/// This function computes an in-place radix-2 FFT of length n and stride stride on the real array data. The output is a half-complex sequence,</span>
    <span class="doccomment">/// which is stored in-place. The arrangement of the half-complex terms uses the following scheme: for k &lt; n/2 the real part of the k-th term</span>
    <span class="doccomment">/// is stored in location k, and the corresponding imaginary part is stored in location n-k. Terms with k &gt; n/2 can be reconstructed using the</span>
    <span class="doccomment">/// symmetry z_k = z^*_{n-k}. The terms for k=0 and k=n/2 are both purely real, and count as a special case. Their real parts are stored in</span>
    <span class="doccomment">/// locations 0 and n/2 respectively, while their imaginary parts which are zero are not stored.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The following table shows the correspondence between the output data and the equivalent results obtained by considering the input data as</span>
    <span class="doccomment">/// a complex sequence with zero imaginary part (assuming stride=1),</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// complex[0].real    =    data[0]</span>
    <span class="doccomment">/// complex[0].imag    =    0</span>
    <span class="doccomment">/// complex[1].real    =    data[1]</span>
    <span class="doccomment">/// complex[1].imag    =    data[n-1]</span>
    <span class="doccomment">/// ...............         ................</span>
    <span class="doccomment">/// complex[k].real    =    data[k]</span>
    <span class="doccomment">/// complex[k].imag    =    data[n-k]</span>
    <span class="doccomment">/// ...............         ................</span>
    <span class="doccomment">/// complex[n/2].real  =    data[n/2]</span>
    <span class="doccomment">/// complex[n/2].imag  =    0</span>
    <span class="doccomment">/// ...............         ................</span>
    <span class="doccomment">/// complex[k&#39;].real   =    data[k]        k&#39; = n - k</span>
    <span class="doccomment">/// complex[k&#39;].imag   =   -data[n-k]</span>
    <span class="doccomment">/// ...............         ................</span>
    <span class="doccomment">/// complex[n-1].real  =    data[1]</span>
    <span class="doccomment">/// complex[n-1].imag  =   -data[n-1]</span>
    <span class="doccomment">/// Note that the output data can be converted into the full complex sequence using the function gsl_fft_halfcomplex_radix2_unpack described</span>
    <span class="doccomment">/// below.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">transform</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_real_radix2_transform</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) })
    }

    <span class="doccomment">/// This function computes the inverse or backwards in-place radix-2 FFT of length n and stride stride on the half-complex sequence data</span>
    <span class="doccomment">/// stored according the output scheme used by gsl_fft_real_radix2. The result is a real array stored in natural order.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">inverse</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_halfcomplex_radix2_inverse</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) })
    }

    <span class="doccomment">/// This function computes the inverse or backwards in-place radix-2 FFT of length n and stride stride on the half-complex sequence data</span>
    <span class="doccomment">/// stored according the output scheme used by gsl_fft_real_radix2. The result is a real array stored in natural order.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">backward</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_halfcomplex_radix2_backward</span>(<span class="ident">data</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">stride</span>, <span class="ident">n</span>) })
    }

    <span class="doccomment">/// This function converts halfcomplex_coefficient, an array of half-complex coefficients as returned by gsl_fft_real_radix2_transform,</span>
    <span class="doccomment">/// into an ordinary complex array, complex_coefficient. It fills in the complex array using the symmetry z_k = z_{n-k}^* to reconstruct</span>
    <span class="doccomment">/// the redundant elements. The algorithm for the conversion is,</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// ```C</span>
    <span class="doccomment">/// complex_coefficient[0].real</span>
    <span class="doccomment">///   = halfcomplex_coefficient[0];</span>
    <span class="doccomment">/// complex_coefficient[0].imag</span>
    <span class="doccomment">///   = 0.0;</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// for (i = 1; i &lt; n - i; i++)</span>
    <span class="doccomment">///   {</span>
    <span class="doccomment">///     double hc_real</span>
    <span class="doccomment">///       = halfcomplex_coefficient[i*stride];</span>
    <span class="doccomment">///     double hc_imag</span>
    <span class="doccomment">///       = halfcomplex_coefficient[(n-i)*stride];</span>
    <span class="doccomment">///     complex_coefficient[i*stride].real = hc_real;</span>
    <span class="doccomment">///     complex_coefficient[i*stride].imag = hc_imag;</span>
    <span class="doccomment">///     complex_coefficient[(n - i)*stride].real = hc_real;</span>
    <span class="doccomment">///     complex_coefficient[(n - i)*stride].imag = -hc_imag;</span>
    <span class="doccomment">///   }</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// if (i == n - i)</span>
    <span class="doccomment">///   {</span>
    <span class="doccomment">///     complex_coefficient[i*stride].real</span>
    <span class="doccomment">///       = halfcomplex_coefficient[(n - 1)*stride];</span>
    <span class="doccomment">///     complex_coefficient[i*stride].imag</span>
    <span class="doccomment">///       = 0.0;</span>
    <span class="doccomment">///   }</span>
    <span class="doccomment">/// ```</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">unpack</span>(<span class="ident">halfcomplex_coefficient</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">f64</span>], <span class="ident">complex_coefficient</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">f64</span>], <span class="ident">stride</span>: <span class="ident">usize</span>, <span class="ident">n</span>: <span class="ident">usize</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
        <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_fft_halfcomplex_radix2_unpack</span>(<span class="ident">halfcomplex_coefficient</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">complex_coefficient</span>.<span class="ident">as_mut_ptr</span>(),
            <span class="ident">stride</span>, <span class="ident">n</span>) })
    }
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "rgsl";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>MathJax.Hub.Config({TeX: {Macros: {dd: "{\\mathop{}\\!\\mathrm{d}}", textsc: ["\\mathrm{\\scriptsize #1}", 1], vt: ["\\boldsymbol{#1}", 1], pfrac: ["\\frac{\\partial #1}{\\partial #2}", 2], ddfrac: ["\\frac{\\dd #1}{\\dd #2}", 2], defeq: "\\mathrel{\\vcenter:}=", abs: ["\\lvert #1 \\rvert", 1], angles: ["\\langle #1 \\rangle", 1]}}});</script></body></html>