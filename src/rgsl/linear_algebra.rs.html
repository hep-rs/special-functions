<!DOCTYPE html><html lang="en"><head><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'<head>l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N9HX7G4');</script><!-- End Google Tag Manager --><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `/home/travis/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>linear_algebra.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../rgsl/index.html'><img src='../../rust-logo.png' alt='logo' width='100'></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">   1</span>
<span id="2">   2</span>
<span id="3">   3</span>
<span id="4">   4</span>
<span id="5">   5</span>
<span id="6">   6</span>
<span id="7">   7</span>
<span id="8">   8</span>
<span id="9">   9</span>
<span id="10">  10</span>
<span id="11">  11</span>
<span id="12">  12</span>
<span id="13">  13</span>
<span id="14">  14</span>
<span id="15">  15</span>
<span id="16">  16</span>
<span id="17">  17</span>
<span id="18">  18</span>
<span id="19">  19</span>
<span id="20">  20</span>
<span id="21">  21</span>
<span id="22">  22</span>
<span id="23">  23</span>
<span id="24">  24</span>
<span id="25">  25</span>
<span id="26">  26</span>
<span id="27">  27</span>
<span id="28">  28</span>
<span id="29">  29</span>
<span id="30">  30</span>
<span id="31">  31</span>
<span id="32">  32</span>
<span id="33">  33</span>
<span id="34">  34</span>
<span id="35">  35</span>
<span id="36">  36</span>
<span id="37">  37</span>
<span id="38">  38</span>
<span id="39">  39</span>
<span id="40">  40</span>
<span id="41">  41</span>
<span id="42">  42</span>
<span id="43">  43</span>
<span id="44">  44</span>
<span id="45">  45</span>
<span id="46">  46</span>
<span id="47">  47</span>
<span id="48">  48</span>
<span id="49">  49</span>
<span id="50">  50</span>
<span id="51">  51</span>
<span id="52">  52</span>
<span id="53">  53</span>
<span id="54">  54</span>
<span id="55">  55</span>
<span id="56">  56</span>
<span id="57">  57</span>
<span id="58">  58</span>
<span id="59">  59</span>
<span id="60">  60</span>
<span id="61">  61</span>
<span id="62">  62</span>
<span id="63">  63</span>
<span id="64">  64</span>
<span id="65">  65</span>
<span id="66">  66</span>
<span id="67">  67</span>
<span id="68">  68</span>
<span id="69">  69</span>
<span id="70">  70</span>
<span id="71">  71</span>
<span id="72">  72</span>
<span id="73">  73</span>
<span id="74">  74</span>
<span id="75">  75</span>
<span id="76">  76</span>
<span id="77">  77</span>
<span id="78">  78</span>
<span id="79">  79</span>
<span id="80">  80</span>
<span id="81">  81</span>
<span id="82">  82</span>
<span id="83">  83</span>
<span id="84">  84</span>
<span id="85">  85</span>
<span id="86">  86</span>
<span id="87">  87</span>
<span id="88">  88</span>
<span id="89">  89</span>
<span id="90">  90</span>
<span id="91">  91</span>
<span id="92">  92</span>
<span id="93">  93</span>
<span id="94">  94</span>
<span id="95">  95</span>
<span id="96">  96</span>
<span id="97">  97</span>
<span id="98">  98</span>
<span id="99">  99</span>
<span id="100"> 100</span>
<span id="101"> 101</span>
<span id="102"> 102</span>
<span id="103"> 103</span>
<span id="104"> 104</span>
<span id="105"> 105</span>
<span id="106"> 106</span>
<span id="107"> 107</span>
<span id="108"> 108</span>
<span id="109"> 109</span>
<span id="110"> 110</span>
<span id="111"> 111</span>
<span id="112"> 112</span>
<span id="113"> 113</span>
<span id="114"> 114</span>
<span id="115"> 115</span>
<span id="116"> 116</span>
<span id="117"> 117</span>
<span id="118"> 118</span>
<span id="119"> 119</span>
<span id="120"> 120</span>
<span id="121"> 121</span>
<span id="122"> 122</span>
<span id="123"> 123</span>
<span id="124"> 124</span>
<span id="125"> 125</span>
<span id="126"> 126</span>
<span id="127"> 127</span>
<span id="128"> 128</span>
<span id="129"> 129</span>
<span id="130"> 130</span>
<span id="131"> 131</span>
<span id="132"> 132</span>
<span id="133"> 133</span>
<span id="134"> 134</span>
<span id="135"> 135</span>
<span id="136"> 136</span>
<span id="137"> 137</span>
<span id="138"> 138</span>
<span id="139"> 139</span>
<span id="140"> 140</span>
<span id="141"> 141</span>
<span id="142"> 142</span>
<span id="143"> 143</span>
<span id="144"> 144</span>
<span id="145"> 145</span>
<span id="146"> 146</span>
<span id="147"> 147</span>
<span id="148"> 148</span>
<span id="149"> 149</span>
<span id="150"> 150</span>
<span id="151"> 151</span>
<span id="152"> 152</span>
<span id="153"> 153</span>
<span id="154"> 154</span>
<span id="155"> 155</span>
<span id="156"> 156</span>
<span id="157"> 157</span>
<span id="158"> 158</span>
<span id="159"> 159</span>
<span id="160"> 160</span>
<span id="161"> 161</span>
<span id="162"> 162</span>
<span id="163"> 163</span>
<span id="164"> 164</span>
<span id="165"> 165</span>
<span id="166"> 166</span>
<span id="167"> 167</span>
<span id="168"> 168</span>
<span id="169"> 169</span>
<span id="170"> 170</span>
<span id="171"> 171</span>
<span id="172"> 172</span>
<span id="173"> 173</span>
<span id="174"> 174</span>
<span id="175"> 175</span>
<span id="176"> 176</span>
<span id="177"> 177</span>
<span id="178"> 178</span>
<span id="179"> 179</span>
<span id="180"> 180</span>
<span id="181"> 181</span>
<span id="182"> 182</span>
<span id="183"> 183</span>
<span id="184"> 184</span>
<span id="185"> 185</span>
<span id="186"> 186</span>
<span id="187"> 187</span>
<span id="188"> 188</span>
<span id="189"> 189</span>
<span id="190"> 190</span>
<span id="191"> 191</span>
<span id="192"> 192</span>
<span id="193"> 193</span>
<span id="194"> 194</span>
<span id="195"> 195</span>
<span id="196"> 196</span>
<span id="197"> 197</span>
<span id="198"> 198</span>
<span id="199"> 199</span>
<span id="200"> 200</span>
<span id="201"> 201</span>
<span id="202"> 202</span>
<span id="203"> 203</span>
<span id="204"> 204</span>
<span id="205"> 205</span>
<span id="206"> 206</span>
<span id="207"> 207</span>
<span id="208"> 208</span>
<span id="209"> 209</span>
<span id="210"> 210</span>
<span id="211"> 211</span>
<span id="212"> 212</span>
<span id="213"> 213</span>
<span id="214"> 214</span>
<span id="215"> 215</span>
<span id="216"> 216</span>
<span id="217"> 217</span>
<span id="218"> 218</span>
<span id="219"> 219</span>
<span id="220"> 220</span>
<span id="221"> 221</span>
<span id="222"> 222</span>
<span id="223"> 223</span>
<span id="224"> 224</span>
<span id="225"> 225</span>
<span id="226"> 226</span>
<span id="227"> 227</span>
<span id="228"> 228</span>
<span id="229"> 229</span>
<span id="230"> 230</span>
<span id="231"> 231</span>
<span id="232"> 232</span>
<span id="233"> 233</span>
<span id="234"> 234</span>
<span id="235"> 235</span>
<span id="236"> 236</span>
<span id="237"> 237</span>
<span id="238"> 238</span>
<span id="239"> 239</span>
<span id="240"> 240</span>
<span id="241"> 241</span>
<span id="242"> 242</span>
<span id="243"> 243</span>
<span id="244"> 244</span>
<span id="245"> 245</span>
<span id="246"> 246</span>
<span id="247"> 247</span>
<span id="248"> 248</span>
<span id="249"> 249</span>
<span id="250"> 250</span>
<span id="251"> 251</span>
<span id="252"> 252</span>
<span id="253"> 253</span>
<span id="254"> 254</span>
<span id="255"> 255</span>
<span id="256"> 256</span>
<span id="257"> 257</span>
<span id="258"> 258</span>
<span id="259"> 259</span>
<span id="260"> 260</span>
<span id="261"> 261</span>
<span id="262"> 262</span>
<span id="263"> 263</span>
<span id="264"> 264</span>
<span id="265"> 265</span>
<span id="266"> 266</span>
<span id="267"> 267</span>
<span id="268"> 268</span>
<span id="269"> 269</span>
<span id="270"> 270</span>
<span id="271"> 271</span>
<span id="272"> 272</span>
<span id="273"> 273</span>
<span id="274"> 274</span>
<span id="275"> 275</span>
<span id="276"> 276</span>
<span id="277"> 277</span>
<span id="278"> 278</span>
<span id="279"> 279</span>
<span id="280"> 280</span>
<span id="281"> 281</span>
<span id="282"> 282</span>
<span id="283"> 283</span>
<span id="284"> 284</span>
<span id="285"> 285</span>
<span id="286"> 286</span>
<span id="287"> 287</span>
<span id="288"> 288</span>
<span id="289"> 289</span>
<span id="290"> 290</span>
<span id="291"> 291</span>
<span id="292"> 292</span>
<span id="293"> 293</span>
<span id="294"> 294</span>
<span id="295"> 295</span>
<span id="296"> 296</span>
<span id="297"> 297</span>
<span id="298"> 298</span>
<span id="299"> 299</span>
<span id="300"> 300</span>
<span id="301"> 301</span>
<span id="302"> 302</span>
<span id="303"> 303</span>
<span id="304"> 304</span>
<span id="305"> 305</span>
<span id="306"> 306</span>
<span id="307"> 307</span>
<span id="308"> 308</span>
<span id="309"> 309</span>
<span id="310"> 310</span>
<span id="311"> 311</span>
<span id="312"> 312</span>
<span id="313"> 313</span>
<span id="314"> 314</span>
<span id="315"> 315</span>
<span id="316"> 316</span>
<span id="317"> 317</span>
<span id="318"> 318</span>
<span id="319"> 319</span>
<span id="320"> 320</span>
<span id="321"> 321</span>
<span id="322"> 322</span>
<span id="323"> 323</span>
<span id="324"> 324</span>
<span id="325"> 325</span>
<span id="326"> 326</span>
<span id="327"> 327</span>
<span id="328"> 328</span>
<span id="329"> 329</span>
<span id="330"> 330</span>
<span id="331"> 331</span>
<span id="332"> 332</span>
<span id="333"> 333</span>
<span id="334"> 334</span>
<span id="335"> 335</span>
<span id="336"> 336</span>
<span id="337"> 337</span>
<span id="338"> 338</span>
<span id="339"> 339</span>
<span id="340"> 340</span>
<span id="341"> 341</span>
<span id="342"> 342</span>
<span id="343"> 343</span>
<span id="344"> 344</span>
<span id="345"> 345</span>
<span id="346"> 346</span>
<span id="347"> 347</span>
<span id="348"> 348</span>
<span id="349"> 349</span>
<span id="350"> 350</span>
<span id="351"> 351</span>
<span id="352"> 352</span>
<span id="353"> 353</span>
<span id="354"> 354</span>
<span id="355"> 355</span>
<span id="356"> 356</span>
<span id="357"> 357</span>
<span id="358"> 358</span>
<span id="359"> 359</span>
<span id="360"> 360</span>
<span id="361"> 361</span>
<span id="362"> 362</span>
<span id="363"> 363</span>
<span id="364"> 364</span>
<span id="365"> 365</span>
<span id="366"> 366</span>
<span id="367"> 367</span>
<span id="368"> 368</span>
<span id="369"> 369</span>
<span id="370"> 370</span>
<span id="371"> 371</span>
<span id="372"> 372</span>
<span id="373"> 373</span>
<span id="374"> 374</span>
<span id="375"> 375</span>
<span id="376"> 376</span>
<span id="377"> 377</span>
<span id="378"> 378</span>
<span id="379"> 379</span>
<span id="380"> 380</span>
<span id="381"> 381</span>
<span id="382"> 382</span>
<span id="383"> 383</span>
<span id="384"> 384</span>
<span id="385"> 385</span>
<span id="386"> 386</span>
<span id="387"> 387</span>
<span id="388"> 388</span>
<span id="389"> 389</span>
<span id="390"> 390</span>
<span id="391"> 391</span>
<span id="392"> 392</span>
<span id="393"> 393</span>
<span id="394"> 394</span>
<span id="395"> 395</span>
<span id="396"> 396</span>
<span id="397"> 397</span>
<span id="398"> 398</span>
<span id="399"> 399</span>
<span id="400"> 400</span>
<span id="401"> 401</span>
<span id="402"> 402</span>
<span id="403"> 403</span>
<span id="404"> 404</span>
<span id="405"> 405</span>
<span id="406"> 406</span>
<span id="407"> 407</span>
<span id="408"> 408</span>
<span id="409"> 409</span>
<span id="410"> 410</span>
<span id="411"> 411</span>
<span id="412"> 412</span>
<span id="413"> 413</span>
<span id="414"> 414</span>
<span id="415"> 415</span>
<span id="416"> 416</span>
<span id="417"> 417</span>
<span id="418"> 418</span>
<span id="419"> 419</span>
<span id="420"> 420</span>
<span id="421"> 421</span>
<span id="422"> 422</span>
<span id="423"> 423</span>
<span id="424"> 424</span>
<span id="425"> 425</span>
<span id="426"> 426</span>
<span id="427"> 427</span>
<span id="428"> 428</span>
<span id="429"> 429</span>
<span id="430"> 430</span>
<span id="431"> 431</span>
<span id="432"> 432</span>
<span id="433"> 433</span>
<span id="434"> 434</span>
<span id="435"> 435</span>
<span id="436"> 436</span>
<span id="437"> 437</span>
<span id="438"> 438</span>
<span id="439"> 439</span>
<span id="440"> 440</span>
<span id="441"> 441</span>
<span id="442"> 442</span>
<span id="443"> 443</span>
<span id="444"> 444</span>
<span id="445"> 445</span>
<span id="446"> 446</span>
<span id="447"> 447</span>
<span id="448"> 448</span>
<span id="449"> 449</span>
<span id="450"> 450</span>
<span id="451"> 451</span>
<span id="452"> 452</span>
<span id="453"> 453</span>
<span id="454"> 454</span>
<span id="455"> 455</span>
<span id="456"> 456</span>
<span id="457"> 457</span>
<span id="458"> 458</span>
<span id="459"> 459</span>
<span id="460"> 460</span>
<span id="461"> 461</span>
<span id="462"> 462</span>
<span id="463"> 463</span>
<span id="464"> 464</span>
<span id="465"> 465</span>
<span id="466"> 466</span>
<span id="467"> 467</span>
<span id="468"> 468</span>
<span id="469"> 469</span>
<span id="470"> 470</span>
<span id="471"> 471</span>
<span id="472"> 472</span>
<span id="473"> 473</span>
<span id="474"> 474</span>
<span id="475"> 475</span>
<span id="476"> 476</span>
<span id="477"> 477</span>
<span id="478"> 478</span>
<span id="479"> 479</span>
<span id="480"> 480</span>
<span id="481"> 481</span>
<span id="482"> 482</span>
<span id="483"> 483</span>
<span id="484"> 484</span>
<span id="485"> 485</span>
<span id="486"> 486</span>
<span id="487"> 487</span>
<span id="488"> 488</span>
<span id="489"> 489</span>
<span id="490"> 490</span>
<span id="491"> 491</span>
<span id="492"> 492</span>
<span id="493"> 493</span>
<span id="494"> 494</span>
<span id="495"> 495</span>
<span id="496"> 496</span>
<span id="497"> 497</span>
<span id="498"> 498</span>
<span id="499"> 499</span>
<span id="500"> 500</span>
<span id="501"> 501</span>
<span id="502"> 502</span>
<span id="503"> 503</span>
<span id="504"> 504</span>
<span id="505"> 505</span>
<span id="506"> 506</span>
<span id="507"> 507</span>
<span id="508"> 508</span>
<span id="509"> 509</span>
<span id="510"> 510</span>
<span id="511"> 511</span>
<span id="512"> 512</span>
<span id="513"> 513</span>
<span id="514"> 514</span>
<span id="515"> 515</span>
<span id="516"> 516</span>
<span id="517"> 517</span>
<span id="518"> 518</span>
<span id="519"> 519</span>
<span id="520"> 520</span>
<span id="521"> 521</span>
<span id="522"> 522</span>
<span id="523"> 523</span>
<span id="524"> 524</span>
<span id="525"> 525</span>
<span id="526"> 526</span>
<span id="527"> 527</span>
<span id="528"> 528</span>
<span id="529"> 529</span>
<span id="530"> 530</span>
<span id="531"> 531</span>
<span id="532"> 532</span>
<span id="533"> 533</span>
<span id="534"> 534</span>
<span id="535"> 535</span>
<span id="536"> 536</span>
<span id="537"> 537</span>
<span id="538"> 538</span>
<span id="539"> 539</span>
<span id="540"> 540</span>
<span id="541"> 541</span>
<span id="542"> 542</span>
<span id="543"> 543</span>
<span id="544"> 544</span>
<span id="545"> 545</span>
<span id="546"> 546</span>
<span id="547"> 547</span>
<span id="548"> 548</span>
<span id="549"> 549</span>
<span id="550"> 550</span>
<span id="551"> 551</span>
<span id="552"> 552</span>
<span id="553"> 553</span>
<span id="554"> 554</span>
<span id="555"> 555</span>
<span id="556"> 556</span>
<span id="557"> 557</span>
<span id="558"> 558</span>
<span id="559"> 559</span>
<span id="560"> 560</span>
<span id="561"> 561</span>
<span id="562"> 562</span>
<span id="563"> 563</span>
<span id="564"> 564</span>
<span id="565"> 565</span>
<span id="566"> 566</span>
<span id="567"> 567</span>
<span id="568"> 568</span>
<span id="569"> 569</span>
<span id="570"> 570</span>
<span id="571"> 571</span>
<span id="572"> 572</span>
<span id="573"> 573</span>
<span id="574"> 574</span>
<span id="575"> 575</span>
<span id="576"> 576</span>
<span id="577"> 577</span>
<span id="578"> 578</span>
<span id="579"> 579</span>
<span id="580"> 580</span>
<span id="581"> 581</span>
<span id="582"> 582</span>
<span id="583"> 583</span>
<span id="584"> 584</span>
<span id="585"> 585</span>
<span id="586"> 586</span>
<span id="587"> 587</span>
<span id="588"> 588</span>
<span id="589"> 589</span>
<span id="590"> 590</span>
<span id="591"> 591</span>
<span id="592"> 592</span>
<span id="593"> 593</span>
<span id="594"> 594</span>
<span id="595"> 595</span>
<span id="596"> 596</span>
<span id="597"> 597</span>
<span id="598"> 598</span>
<span id="599"> 599</span>
<span id="600"> 600</span>
<span id="601"> 601</span>
<span id="602"> 602</span>
<span id="603"> 603</span>
<span id="604"> 604</span>
<span id="605"> 605</span>
<span id="606"> 606</span>
<span id="607"> 607</span>
<span id="608"> 608</span>
<span id="609"> 609</span>
<span id="610"> 610</span>
<span id="611"> 611</span>
<span id="612"> 612</span>
<span id="613"> 613</span>
<span id="614"> 614</span>
<span id="615"> 615</span>
<span id="616"> 616</span>
<span id="617"> 617</span>
<span id="618"> 618</span>
<span id="619"> 619</span>
<span id="620"> 620</span>
<span id="621"> 621</span>
<span id="622"> 622</span>
<span id="623"> 623</span>
<span id="624"> 624</span>
<span id="625"> 625</span>
<span id="626"> 626</span>
<span id="627"> 627</span>
<span id="628"> 628</span>
<span id="629"> 629</span>
<span id="630"> 630</span>
<span id="631"> 631</span>
<span id="632"> 632</span>
<span id="633"> 633</span>
<span id="634"> 634</span>
<span id="635"> 635</span>
<span id="636"> 636</span>
<span id="637"> 637</span>
<span id="638"> 638</span>
<span id="639"> 639</span>
<span id="640"> 640</span>
<span id="641"> 641</span>
<span id="642"> 642</span>
<span id="643"> 643</span>
<span id="644"> 644</span>
<span id="645"> 645</span>
<span id="646"> 646</span>
<span id="647"> 647</span>
<span id="648"> 648</span>
<span id="649"> 649</span>
<span id="650"> 650</span>
<span id="651"> 651</span>
<span id="652"> 652</span>
<span id="653"> 653</span>
<span id="654"> 654</span>
<span id="655"> 655</span>
<span id="656"> 656</span>
<span id="657"> 657</span>
<span id="658"> 658</span>
<span id="659"> 659</span>
<span id="660"> 660</span>
<span id="661"> 661</span>
<span id="662"> 662</span>
<span id="663"> 663</span>
<span id="664"> 664</span>
<span id="665"> 665</span>
<span id="666"> 666</span>
<span id="667"> 667</span>
<span id="668"> 668</span>
<span id="669"> 669</span>
<span id="670"> 670</span>
<span id="671"> 671</span>
<span id="672"> 672</span>
<span id="673"> 673</span>
<span id="674"> 674</span>
<span id="675"> 675</span>
<span id="676"> 676</span>
<span id="677"> 677</span>
<span id="678"> 678</span>
<span id="679"> 679</span>
<span id="680"> 680</span>
<span id="681"> 681</span>
<span id="682"> 682</span>
<span id="683"> 683</span>
<span id="684"> 684</span>
<span id="685"> 685</span>
<span id="686"> 686</span>
<span id="687"> 687</span>
<span id="688"> 688</span>
<span id="689"> 689</span>
<span id="690"> 690</span>
<span id="691"> 691</span>
<span id="692"> 692</span>
<span id="693"> 693</span>
<span id="694"> 694</span>
<span id="695"> 695</span>
<span id="696"> 696</span>
<span id="697"> 697</span>
<span id="698"> 698</span>
<span id="699"> 699</span>
<span id="700"> 700</span>
<span id="701"> 701</span>
<span id="702"> 702</span>
<span id="703"> 703</span>
<span id="704"> 704</span>
<span id="705"> 705</span>
<span id="706"> 706</span>
<span id="707"> 707</span>
<span id="708"> 708</span>
<span id="709"> 709</span>
<span id="710"> 710</span>
<span id="711"> 711</span>
<span id="712"> 712</span>
<span id="713"> 713</span>
<span id="714"> 714</span>
<span id="715"> 715</span>
<span id="716"> 716</span>
<span id="717"> 717</span>
<span id="718"> 718</span>
<span id="719"> 719</span>
<span id="720"> 720</span>
<span id="721"> 721</span>
<span id="722"> 722</span>
<span id="723"> 723</span>
<span id="724"> 724</span>
<span id="725"> 725</span>
<span id="726"> 726</span>
<span id="727"> 727</span>
<span id="728"> 728</span>
<span id="729"> 729</span>
<span id="730"> 730</span>
<span id="731"> 731</span>
<span id="732"> 732</span>
<span id="733"> 733</span>
<span id="734"> 734</span>
<span id="735"> 735</span>
<span id="736"> 736</span>
<span id="737"> 737</span>
<span id="738"> 738</span>
<span id="739"> 739</span>
<span id="740"> 740</span>
<span id="741"> 741</span>
<span id="742"> 742</span>
<span id="743"> 743</span>
<span id="744"> 744</span>
<span id="745"> 745</span>
<span id="746"> 746</span>
<span id="747"> 747</span>
<span id="748"> 748</span>
<span id="749"> 749</span>
<span id="750"> 750</span>
<span id="751"> 751</span>
<span id="752"> 752</span>
<span id="753"> 753</span>
<span id="754"> 754</span>
<span id="755"> 755</span>
<span id="756"> 756</span>
<span id="757"> 757</span>
<span id="758"> 758</span>
<span id="759"> 759</span>
<span id="760"> 760</span>
<span id="761"> 761</span>
<span id="762"> 762</span>
<span id="763"> 763</span>
<span id="764"> 764</span>
<span id="765"> 765</span>
<span id="766"> 766</span>
<span id="767"> 767</span>
<span id="768"> 768</span>
<span id="769"> 769</span>
<span id="770"> 770</span>
<span id="771"> 771</span>
<span id="772"> 772</span>
<span id="773"> 773</span>
<span id="774"> 774</span>
<span id="775"> 775</span>
<span id="776"> 776</span>
<span id="777"> 777</span>
<span id="778"> 778</span>
<span id="779"> 779</span>
<span id="780"> 780</span>
<span id="781"> 781</span>
<span id="782"> 782</span>
<span id="783"> 783</span>
<span id="784"> 784</span>
<span id="785"> 785</span>
<span id="786"> 786</span>
<span id="787"> 787</span>
<span id="788"> 788</span>
<span id="789"> 789</span>
<span id="790"> 790</span>
<span id="791"> 791</span>
<span id="792"> 792</span>
<span id="793"> 793</span>
<span id="794"> 794</span>
<span id="795"> 795</span>
<span id="796"> 796</span>
<span id="797"> 797</span>
<span id="798"> 798</span>
<span id="799"> 799</span>
<span id="800"> 800</span>
<span id="801"> 801</span>
<span id="802"> 802</span>
<span id="803"> 803</span>
<span id="804"> 804</span>
<span id="805"> 805</span>
<span id="806"> 806</span>
<span id="807"> 807</span>
<span id="808"> 808</span>
<span id="809"> 809</span>
<span id="810"> 810</span>
<span id="811"> 811</span>
<span id="812"> 812</span>
<span id="813"> 813</span>
<span id="814"> 814</span>
<span id="815"> 815</span>
<span id="816"> 816</span>
<span id="817"> 817</span>
<span id="818"> 818</span>
<span id="819"> 819</span>
<span id="820"> 820</span>
<span id="821"> 821</span>
<span id="822"> 822</span>
<span id="823"> 823</span>
<span id="824"> 824</span>
<span id="825"> 825</span>
<span id="826"> 826</span>
<span id="827"> 827</span>
<span id="828"> 828</span>
<span id="829"> 829</span>
<span id="830"> 830</span>
<span id="831"> 831</span>
<span id="832"> 832</span>
<span id="833"> 833</span>
<span id="834"> 834</span>
<span id="835"> 835</span>
<span id="836"> 836</span>
<span id="837"> 837</span>
<span id="838"> 838</span>
<span id="839"> 839</span>
<span id="840"> 840</span>
<span id="841"> 841</span>
<span id="842"> 842</span>
<span id="843"> 843</span>
<span id="844"> 844</span>
<span id="845"> 845</span>
<span id="846"> 846</span>
<span id="847"> 847</span>
<span id="848"> 848</span>
<span id="849"> 849</span>
<span id="850"> 850</span>
<span id="851"> 851</span>
<span id="852"> 852</span>
<span id="853"> 853</span>
<span id="854"> 854</span>
<span id="855"> 855</span>
<span id="856"> 856</span>
<span id="857"> 857</span>
<span id="858"> 858</span>
<span id="859"> 859</span>
<span id="860"> 860</span>
<span id="861"> 861</span>
<span id="862"> 862</span>
<span id="863"> 863</span>
<span id="864"> 864</span>
<span id="865"> 865</span>
<span id="866"> 866</span>
<span id="867"> 867</span>
<span id="868"> 868</span>
<span id="869"> 869</span>
<span id="870"> 870</span>
<span id="871"> 871</span>
<span id="872"> 872</span>
<span id="873"> 873</span>
<span id="874"> 874</span>
<span id="875"> 875</span>
<span id="876"> 876</span>
<span id="877"> 877</span>
<span id="878"> 878</span>
<span id="879"> 879</span>
<span id="880"> 880</span>
<span id="881"> 881</span>
<span id="882"> 882</span>
<span id="883"> 883</span>
<span id="884"> 884</span>
<span id="885"> 885</span>
<span id="886"> 886</span>
<span id="887"> 887</span>
<span id="888"> 888</span>
<span id="889"> 889</span>
<span id="890"> 890</span>
<span id="891"> 891</span>
<span id="892"> 892</span>
<span id="893"> 893</span>
<span id="894"> 894</span>
<span id="895"> 895</span>
<span id="896"> 896</span>
<span id="897"> 897</span>
<span id="898"> 898</span>
<span id="899"> 899</span>
<span id="900"> 900</span>
<span id="901"> 901</span>
<span id="902"> 902</span>
<span id="903"> 903</span>
<span id="904"> 904</span>
<span id="905"> 905</span>
<span id="906"> 906</span>
<span id="907"> 907</span>
<span id="908"> 908</span>
<span id="909"> 909</span>
<span id="910"> 910</span>
<span id="911"> 911</span>
<span id="912"> 912</span>
<span id="913"> 913</span>
<span id="914"> 914</span>
<span id="915"> 915</span>
<span id="916"> 916</span>
<span id="917"> 917</span>
<span id="918"> 918</span>
<span id="919"> 919</span>
<span id="920"> 920</span>
<span id="921"> 921</span>
<span id="922"> 922</span>
<span id="923"> 923</span>
<span id="924"> 924</span>
<span id="925"> 925</span>
<span id="926"> 926</span>
<span id="927"> 927</span>
<span id="928"> 928</span>
<span id="929"> 929</span>
<span id="930"> 930</span>
<span id="931"> 931</span>
<span id="932"> 932</span>
<span id="933"> 933</span>
<span id="934"> 934</span>
<span id="935"> 935</span>
<span id="936"> 936</span>
<span id="937"> 937</span>
<span id="938"> 938</span>
<span id="939"> 939</span>
<span id="940"> 940</span>
<span id="941"> 941</span>
<span id="942"> 942</span>
<span id="943"> 943</span>
<span id="944"> 944</span>
<span id="945"> 945</span>
<span id="946"> 946</span>
<span id="947"> 947</span>
<span id="948"> 948</span>
<span id="949"> 949</span>
<span id="950"> 950</span>
<span id="951"> 951</span>
<span id="952"> 952</span>
<span id="953"> 953</span>
<span id="954"> 954</span>
<span id="955"> 955</span>
<span id="956"> 956</span>
<span id="957"> 957</span>
<span id="958"> 958</span>
<span id="959"> 959</span>
<span id="960"> 960</span>
<span id="961"> 961</span>
<span id="962"> 962</span>
<span id="963"> 963</span>
<span id="964"> 964</span>
<span id="965"> 965</span>
<span id="966"> 966</span>
<span id="967"> 967</span>
<span id="968"> 968</span>
<span id="969"> 969</span>
<span id="970"> 970</span>
<span id="971"> 971</span>
<span id="972"> 972</span>
<span id="973"> 973</span>
<span id="974"> 974</span>
<span id="975"> 975</span>
<span id="976"> 976</span>
<span id="977"> 977</span>
<span id="978"> 978</span>
<span id="979"> 979</span>
<span id="980"> 980</span>
<span id="981"> 981</span>
<span id="982"> 982</span>
<span id="983"> 983</span>
<span id="984"> 984</span>
<span id="985"> 985</span>
<span id="986"> 986</span>
<span id="987"> 987</span>
<span id="988"> 988</span>
<span id="989"> 989</span>
<span id="990"> 990</span>
<span id="991"> 991</span>
<span id="992"> 992</span>
<span id="993"> 993</span>
<span id="994"> 994</span>
<span id="995"> 995</span>
<span id="996"> 996</span>
<span id="997"> 997</span>
<span id="998"> 998</span>
<span id="999"> 999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
<span id="1059">1059</span>
<span id="1060">1060</span>
<span id="1061">1061</span>
<span id="1062">1062</span>
<span id="1063">1063</span>
<span id="1064">1064</span>
<span id="1065">1065</span>
<span id="1066">1066</span>
<span id="1067">1067</span>
<span id="1068">1068</span>
<span id="1069">1069</span>
<span id="1070">1070</span>
<span id="1071">1071</span>
<span id="1072">1072</span>
<span id="1073">1073</span>
<span id="1074">1074</span>
<span id="1075">1075</span>
<span id="1076">1076</span>
<span id="1077">1077</span>
<span id="1078">1078</span>
<span id="1079">1079</span>
<span id="1080">1080</span>
<span id="1081">1081</span>
<span id="1082">1082</span>
<span id="1083">1083</span>
<span id="1084">1084</span>
<span id="1085">1085</span>
<span id="1086">1086</span>
<span id="1087">1087</span>
<span id="1088">1088</span>
<span id="1089">1089</span>
<span id="1090">1090</span>
<span id="1091">1091</span>
<span id="1092">1092</span>
<span id="1093">1093</span>
<span id="1094">1094</span>
<span id="1095">1095</span>
<span id="1096">1096</span>
<span id="1097">1097</span>
<span id="1098">1098</span>
<span id="1099">1099</span>
<span id="1100">1100</span>
<span id="1101">1101</span>
<span id="1102">1102</span>
<span id="1103">1103</span>
<span id="1104">1104</span>
<span id="1105">1105</span>
<span id="1106">1106</span>
<span id="1107">1107</span>
<span id="1108">1108</span>
<span id="1109">1109</span>
<span id="1110">1110</span>
<span id="1111">1111</span>
<span id="1112">1112</span>
<span id="1113">1113</span>
<span id="1114">1114</span>
<span id="1115">1115</span>
<span id="1116">1116</span>
<span id="1117">1117</span>
<span id="1118">1118</span>
<span id="1119">1119</span>
<span id="1120">1120</span>
<span id="1121">1121</span>
<span id="1122">1122</span>
<span id="1123">1123</span>
<span id="1124">1124</span>
<span id="1125">1125</span>
<span id="1126">1126</span>
<span id="1127">1127</span>
<span id="1128">1128</span>
<span id="1129">1129</span>
<span id="1130">1130</span>
<span id="1131">1131</span>
<span id="1132">1132</span>
<span id="1133">1133</span>
<span id="1134">1134</span>
<span id="1135">1135</span>
<span id="1136">1136</span>
<span id="1137">1137</span>
<span id="1138">1138</span>
<span id="1139">1139</span>
<span id="1140">1140</span>
<span id="1141">1141</span>
<span id="1142">1142</span>
<span id="1143">1143</span>
<span id="1144">1144</span>
<span id="1145">1145</span>
<span id="1146">1146</span>
<span id="1147">1147</span>
<span id="1148">1148</span>
<span id="1149">1149</span>
<span id="1150">1150</span>
<span id="1151">1151</span>
<span id="1152">1152</span>
<span id="1153">1153</span>
<span id="1154">1154</span>
<span id="1155">1155</span>
<span id="1156">1156</span>
<span id="1157">1157</span>
<span id="1158">1158</span>
<span id="1159">1159</span>
<span id="1160">1160</span>
<span id="1161">1161</span>
<span id="1162">1162</span>
<span id="1163">1163</span>
<span id="1164">1164</span>
<span id="1165">1165</span>
<span id="1166">1166</span>
<span id="1167">1167</span>
<span id="1168">1168</span>
<span id="1169">1169</span>
<span id="1170">1170</span>
<span id="1171">1171</span>
<span id="1172">1172</span>
<span id="1173">1173</span>
<span id="1174">1174</span>
<span id="1175">1175</span>
<span id="1176">1176</span>
<span id="1177">1177</span>
<span id="1178">1178</span>
<span id="1179">1179</span>
<span id="1180">1180</span>
<span id="1181">1181</span>
<span id="1182">1182</span>
<span id="1183">1183</span>
<span id="1184">1184</span>
<span id="1185">1185</span>
<span id="1186">1186</span>
<span id="1187">1187</span>
<span id="1188">1188</span>
<span id="1189">1189</span>
<span id="1190">1190</span>
<span id="1191">1191</span>
<span id="1192">1192</span>
<span id="1193">1193</span>
<span id="1194">1194</span>
<span id="1195">1195</span>
<span id="1196">1196</span>
<span id="1197">1197</span>
<span id="1198">1198</span>
<span id="1199">1199</span>
<span id="1200">1200</span>
<span id="1201">1201</span>
<span id="1202">1202</span>
<span id="1203">1203</span>
<span id="1204">1204</span>
<span id="1205">1205</span>
<span id="1206">1206</span>
<span id="1207">1207</span>
<span id="1208">1208</span>
<span id="1209">1209</span>
<span id="1210">1210</span>
<span id="1211">1211</span>
<span id="1212">1212</span>
<span id="1213">1213</span>
<span id="1214">1214</span>
<span id="1215">1215</span>
<span id="1216">1216</span>
<span id="1217">1217</span>
<span id="1218">1218</span>
<span id="1219">1219</span>
<span id="1220">1220</span>
<span id="1221">1221</span>
<span id="1222">1222</span>
<span id="1223">1223</span>
<span id="1224">1224</span>
<span id="1225">1225</span>
<span id="1226">1226</span>
<span id="1227">1227</span>
<span id="1228">1228</span>
<span id="1229">1229</span>
<span id="1230">1230</span>
<span id="1231">1231</span>
<span id="1232">1232</span>
<span id="1233">1233</span>
<span id="1234">1234</span>
<span id="1235">1235</span>
<span id="1236">1236</span>
<span id="1237">1237</span>
<span id="1238">1238</span>
<span id="1239">1239</span>
<span id="1240">1240</span>
<span id="1241">1241</span>
<span id="1242">1242</span>
<span id="1243">1243</span>
<span id="1244">1244</span>
<span id="1245">1245</span>
<span id="1246">1246</span>
<span id="1247">1247</span>
<span id="1248">1248</span>
<span id="1249">1249</span>
<span id="1250">1250</span>
<span id="1251">1251</span>
<span id="1252">1252</span>
<span id="1253">1253</span>
<span id="1254">1254</span>
<span id="1255">1255</span>
<span id="1256">1256</span>
<span id="1257">1257</span>
<span id="1258">1258</span>
<span id="1259">1259</span>
<span id="1260">1260</span>
<span id="1261">1261</span>
<span id="1262">1262</span>
<span id="1263">1263</span>
<span id="1264">1264</span>
<span id="1265">1265</span>
<span id="1266">1266</span>
<span id="1267">1267</span>
<span id="1268">1268</span>
<span id="1269">1269</span>
<span id="1270">1270</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="comment">//</span>
<span class="comment">// A rust binding for the GSL library by Guillaume Gomez (guillaume1.gomez@gmail.com)</span>
<span class="comment">//</span>

<span class="doccomment">/*!
#Linear Algebra

This chapter describes functions for solving linear systems. The library provides linear algebra operations which operate directly on the 
gsl_vector and gsl_matrix objects. These routines use the standard algorithms from Golub &amp; Van Loan’s Matrix Computations with Level-1 and 
Level-2 BLAS calls for efficiency.

##LU Decomposition

A general square matrix A has an LU decomposition into upper and lower triangular matrices,

P A = L U
where P is a permutation matrix, L is unit lower triangular matrix and U is upper triangular matrix. For square matrices this decomposition 
can be used to convert the linear system A x = b into a pair of triangular systems (L y = P b, U x = y), which can be solved by forward and 
back-substitution. Note that the LU decomposition is valid for singular matrices.

##QR Decomposition

A general rectangular M-by-N matrix A has a QR decomposition into the product of an orthogonal M-by-M square matrix Q (where Q^T Q = I) and 
an M-by-N right-triangular matrix R,

A = Q R
This decomposition can be used to convert the linear system A x = b into the triangular system R x = Q^T b, which can be solved by back-substitution. 
Another use of the QR decomposition is to compute an orthonormal basis for a set of vectors. The first N columns of Q form an orthonormal 
basis for the range of A, ran(A), when A has full column rank.

##QR Decomposition with Column Pivoting

The QR decomposition can be extended to the rank deficient case by introducing a column permutation P,

A P = Q R
The first r columns of Q form an orthonormal basis for the range of A for a matrix with column rank r. This decomposition can also be used 
to convert the linear system A x = b into the triangular system R y = Q^T b, x = P y, which can be solved by back-substitution and permutation. 
We denote the QR decomposition with column pivoting by QRP^T since A = Q R P^T.

##Singular Value Decomposition

A general rectangular M-by-N matrix A has a singular value decomposition (SVD) into the product of an M-by-N orthogonal matrix U, an N-by-N 
diagonal matrix of singular values S and the transpose of an N-by-N orthogonal square matrix V,

A = U S V^T

The singular values \sigma_i = S_{ii} are all non-negative and are generally chosen to form a non-increasing sequence \sigma_1 &gt;= \sigma_2 &gt;= 
... &gt;= \sigma_N &gt;= 0.

The singular value decomposition of a matrix has many practical uses. The condition number of the matrix is given by the ratio of the largest 
singular value to the smallest singular value. The presence of a zero singular value indicates that the matrix is singular. The number of 
non-zero singular values indicates the rank of the matrix. In practice singular value decomposition of a rank-deficient matrix will not produce 
exact zeroes for singular values, due to finite numerical precision. Small singular values should be edited by choosing a suitable tolerance.

For a rank-deficient matrix, the null space of A is given by the columns of V corresponding to the zero singular values. Similarly, the range 
of A is given by columns of U corresponding to the non-zero singular values.

Note that the routines here compute the “thin” version of the SVD with U as M-by-N orthogonal matrix. This allows in-place computation and is 
the most commonly-used form in practice. Mathematically, the “full” SVD is defined with U as an M-by-M orthogonal matrix and S as an M-by-N 
diagonal matrix (with additional rows of zeros).

##Cholesky Decomposition

A symmetric, positive definite square matrix A has a Cholesky decomposition into a product of a lower triangular matrix L and its transpose L^T,

A = L L^T

This is sometimes referred to as taking the square-root of a matrix. The Cholesky decomposition can only be carried out when all the eigenvalues 
of the matrix are positive. This decomposition can be used to convert the linear system A x = b into a pair of triangular systems (L y = b, 
L^T x = y), which can be solved by forward and back-substitution.

##Tridiagonal Decomposition of Real Symmetric Matrices

A symmetric matrix A can be factorized by similarity transformations into the form,

A = Q T Q^T

where Q is an orthogonal matrix and T is a symmetric tridiagonal matrix.

##Tridiagonal Decomposition of Hermitian Matrices

A hermitian matrix A can be factorized by similarity transformations into the form,

A = U T U^T

where U is a unitary matrix and T is a real symmetric tridiagonal matrix.

##Hessenberg Decomposition of Real Matrices

A general real matrix A can be decomposed by orthogonal similarity transformations into the form

A = U H U^T

where U is orthogonal and H is an upper Hessenberg matrix, meaning that it has zeros below the first subdiagonal. The Hessenberg reduction 
is the first step in the Schur decomposition for the nonsymmetric eigenvalue problem, but has applications in other areas as well.

##Hessenberg-Triangular Decomposition of Real Matrices

A general real matrix pair (A, B) can be decomposed by orthogonal similarity transformations into the form

A = U H V^T
B = U R V^T

where U and V are orthogonal, H is an upper Hessenberg matrix, and R is upper triangular. The Hessenberg-Triangular reduction is the first 
step in the generalized Schur decomposition for the generalized eigenvalue problem.

##Bidiagonalization

A general matrix A can be factorized by similarity transformations into the form,

A = U B V^T
where U and V are orthogonal matrices and B is a N-by-N bidiagonal matrix with non-zero entries only on the diagonal and superdiagonal. The 
size of U is M-by-N and the size of V is N-by-N.

##Householder Transformations

A Householder transformation is a rank-1 modification of the identity matrix which can be used to zero out selected elements of a vector. 
A Householder matrix P takes the form,

P = I - \tau v v^T

where v is a vector (called the Householder vector) and \tau = 2/(v^T v). The functions described in this section use the rank-1 structure 
of the Householder matrix to create and apply Householder transformations efficiently.

##Tridiagonal Systems

The functions described in this section efficiently solve symmetric, non-symmetric and cyclic tridiagonal systems with minimal storage. Note 
that the current implementations of these functions use a variant of Cholesky decomposition, so the tridiagonal matrix must be positive definite. 
For non-positive definite matrices, the functions return the error code ::Sing.

##Balancing

The process of balancing a matrix applies similarity transformations to make the rows and columns have comparable norms. This is useful, for 
example, to reduce roundoff errors in the solution of eigenvalue problems. Balancing a matrix A consists of replacing A with a similar matrix

A&#39; = D^(-1) A D

where D is a diagonal matrix whose entries are powers of the floating point radix.

##14.16 References and Further Reading

Further information on the algorithms described in this section can be found in the following book,

G. H. Golub, C. F. Van Loan, Matrix Computations (3rd Ed, 1996), Johns Hopkins University Press, ISBN 0-8018-5414-8.
The LAPACK library is described in the following manual,

LAPACK Users’ Guide (Third Edition, 1999), Published by SIAM, ISBN 0-89871-447-8.
http://www.netlib.org/lapack

The LAPACK source code can be found at the website above, along with an online copy of the users guide.

The Modified Golub-Reinsch algorithm is described in the following paper,

T.F. Chan, “An Improved Algorithm for Computing the Singular Value Decomposition”, ACM Transactions on Mathematical Software, 8 (1982), pp 72–83.
The Jacobi algorithm for singular value decomposition is described in the following papers,

J.C. Nash, “A one-sided transformation method for the singular value decomposition and algebraic eigenproblem”, Computer Journal, Volume 18, Number 
1 (1975), p 74–76
J.C. Nash and S. Shlien “Simple algorithms for the partial singular value decomposition”, Computer Journal, Volume 30 (1987), p 268–275.
James Demmel, Krešimir Veselić, “Jacobi’s Method is more accurate than QR”, Lapack Working Note 15 (LAWN-15), October 1989. Available from netlib, 
http://www.netlib.org/lapack/ in the lawns or lawnspdf directories.
!*/</span>

<span class="kw">use</span> <span class="ident">ffi</span>;
<span class="kw">use</span> <span class="ident">enums</span>;

<span class="kw">use</span> <span class="ident">types</span>::<span class="ident">complex</span>::<span class="ident">FFFI</span>;

<span class="doccomment">/// Factorise a general N x N matrix A into,</span>
<span class="doccomment">///</span>
<span class="doccomment">///  P A = L U</span>
<span class="doccomment">///</span>
<span class="doccomment">/// where P is a permutation matrix, L is unit lower triangular and U is upper triangular.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// L is stored in the strict lower triangular part of the input matrix. The diagonal elements of L are unity and are not stored.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// U is stored in the diagonal and upper triangular part of the input matrix.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// P is stored in the permutation p. Column j of P is column k of the identity matrix, where k = permutation-&gt;data[j]</span>
<span class="doccomment">///</span>
<span class="doccomment">/// signum gives the sign of the permutation, (-1)^n, where n is the  number of interchanges in the permutation.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// See Golub &amp; Van Loan, Matrix Computations, Algorithm 3.4.1 (Gauss Elimination with Partial Pivoting).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">LU_decomp</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">Permutation</span>, <span class="ident">signum</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_LU_decomp</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">p</span>),
                                  <span class="ident">signum</span>)
    })
}

<span class="doccomment">/// Factorise a general N x N complex matrix A into,</span>
<span class="doccomment">///</span>
<span class="doccomment">///   P A = L U</span>
<span class="doccomment">///</span>
<span class="doccomment">/// where P is a permutation matrix, L is unit lower triangular and U is upper triangular.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// L is stored in the strict lower triangular part of the input matrix. The diagonal elements of L are unity and are not stored.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// U is stored in the diagonal and upper triangular part of the input matrix.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// P is stored in the permutation p. Column j of P is column k of the identity matrix, where k = permutation-&gt;data[j]</span>
<span class="doccomment">///</span>
<span class="doccomment">/// signum gives the sign of the permutation, (-1)^n, where n is the number of interchanges in the permutation.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// See Golub &amp; Van Loan, Matrix Computations, Algorithm 3.4.1 (Gauss Elimination with Partial Pivoting).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_LU_decomp</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>,
    <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">Permutation</span>,
    <span class="ident">signum</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">i32</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_LU_decomp</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">p</span>),
                                          <span class="ident">signum</span>)
    })
}

<span class="doccomment">/// This function solves the square system A x = b using the LU decomposition of A into (LU, p) given by LU_decomp or LU_decomp as input.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">LU_solve</span>(
    <span class="ident">lu</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_LU_solve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">lu</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the square system A x = b using the LU decomposition of A into (LU, p) given by LU_decomp or LU_decomp as input.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_LU_solve</span>(
    <span class="ident">lu</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixComplexF64</span>,
    <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorComplexF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorComplexF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_LU_solve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">lu</span>),
                                         <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                         <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                         <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the square system A x = b in-place using the precomputed LU decomposition of A into (LU,p). On input x should contain</span>
<span class="doccomment">/// the right-hand side b, which is replaced by the solution on output.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">LU_svx</span>(<span class="ident">lu</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_LU_svx</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">lu</span>),
                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the square system A x = b in-place using the precomputed LU decomposition of A into (LU,p). On input x should contain</span>
<span class="doccomment">/// the right-hand side b, which is replaced by the solution on output.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_LU_svx</span>(<span class="ident">lu</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixComplexF64</span>,
                      <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>,
                      <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorComplexF64</span>)
                      <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_LU_svx</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">lu</span>),
                                       <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                       <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function applies an iterative improvement to x, the solution of A x = b, from the precomputed LU decomposition of A into (LU,p). The</span>
<span class="doccomment">/// initial residual r = A x - b is also computed and stored in residual.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">LU_refine</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
                 <span class="ident">lu</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
                 <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>,
                 <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
                 <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
                 <span class="ident">residual</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>)
                 <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_LU_refine</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">a</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">lu</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">residual</span>))
    })
}

<span class="doccomment">/// This function applies an iterative improvement to x, the solution of A x = b, from the precomputed LU decomposition of A into (LU,p). The</span>
<span class="doccomment">/// initial residual r = A x - b is also computed and stored in residual.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_LU_refine</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>,
                         <span class="ident">lu</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixComplexF64</span>,
                         <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>,
                         <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorComplexF64</span>,
                         <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorComplexF64</span>,
                         <span class="ident">residual</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorComplexF64</span>)
                         <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_LU_refine</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">lu</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">residual</span>))
    })
}

<span class="doccomment">/// This function computes the inverse of a matrix A from its LU decomposition (LU,p), storing the result in the matrix inverse. The inverse</span>
<span class="doccomment">/// is computed by solving the system A x = b for each column of the identity matrix. It is preferable to avoid direct use of the inverse</span>
<span class="doccomment">/// whenever possible, as the linear solver functions can obtain the same result more efficiently and reliably (consult any introductory</span>
<span class="doccomment">/// textbook on numerical linear algebra for details).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">LU_invert</span>(<span class="ident">lu</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>, <span class="ident">inverse</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_LU_invert</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">lu</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">inverse</span>))
    })
}

<span class="doccomment">/// This function computes the inverse of a matrix A from its LU decomposition (LU,p), storing the result in the matrix inverse. The inverse</span>
<span class="doccomment">/// is computed by solving the system A x = b for each column of the identity matrix. It is preferable to avoid direct use of the inverse</span>
<span class="doccomment">/// whenever possible, as the linear solver functions can obtain the same result more efficiently and reliably (consult any introductory</span>
<span class="doccomment">/// textbook on numerical linear algebra for details).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_LU_invert</span>(
    <span class="ident">lu</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixComplexF64</span>,
    <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>,
    <span class="ident">inverse</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_LU_invert</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">lu</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">inverse</span>))
    })
}

<span class="doccomment">/// This function computes the determinant of a matrix A from its LU decomposition, LU. The determinant is computed as the product of the</span>
<span class="doccomment">/// diagonal elements of U and the sign of the row permutation signum.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">LU_det</span>(<span class="ident">lu</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>, <span class="ident">signum</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_linalg_LU_det</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">lu</span>), <span class="ident">signum</span>) }
}

<span class="doccomment">/// This function computes the determinant of a matrix A from its LU decomposition, LU. The determinant is computed as the product of the</span>
<span class="doccomment">/// diagonal elements of U and the sign of the row permutation signum.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_LU_det</span>(<span class="ident">lu</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>, <span class="ident">signum</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> ::<span class="ident">ComplexF64</span> {
    <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_LU_det</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">lu</span>), <span class="ident">signum</span>).<span class="ident">wrap</span>() }
}

<span class="doccomment">/// These functions compute the logarithm of the absolute value of the determinant of a matrix A, \ln|\det(A)|, from its LU decomposition,</span>
<span class="doccomment">/// LU. This function may be useful if the direct computation of the determinant would overflow or underflow.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">LU_lndet</span>(<span class="ident">lu</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_linalg_LU_lndet</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">lu</span>)) }
}

<span class="doccomment">/// These functions compute the logarithm of the absolute value of the determinant of a matrix A, \ln|\det(A)|, from its LU decomposition,</span>
<span class="doccomment">/// LU. This function may be useful if the direct computation of the determinant would overflow or underflow.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_LU_lndet</span>(<span class="ident">lu</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_LU_lndet</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">lu</span>)) }
}

<span class="doccomment">/// This function computes the sign or phase factor of the determinant of a matrix A, \det(A)/|\det(A)|, from its LU decomposition, LU.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">LU_sgndet</span>(<span class="ident">lu</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>, <span class="ident">signum</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_linalg_LU_sgndet</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">lu</span>), <span class="ident">signum</span>) }
}

<span class="doccomment">/// This function computes the sign or phase factor of the determinant of a matrix A, \det(A)/|\det(A)|, from its LU decomposition, LU.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_LU_sgndet</span>(<span class="ident">lu</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>, <span class="ident">signum</span>: <span class="ident">i32</span>) <span class="op">-&gt;</span> ::<span class="ident">ComplexF64</span> {
    <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_LU_sgndet</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">lu</span>), <span class="ident">signum</span>).<span class="ident">wrap</span>() }
}

<span class="doccomment">/// This function factorizes the M-by-N matrix A into the QR decomposition A = Q R. On output the diagonal and upper triangular part of the</span>
<span class="doccomment">/// input matrix contain the matrix R. The vector tau and the columns of the lower triangular part of the matrix A contain the Householder</span>
<span class="doccomment">/// coefficients and Householder vectors which encode the orthogonal matrix Q. The vector tau must be of length k=\min(M,N). The matrix Q</span>
<span class="doccomment">/// is related to these components by, Q = Q_k ... Q_2 Q_1 where Q_i = I - \tau_i v_i v_i^T and v_i is the Householder vector v_i =</span>
<span class="doccomment">/// (0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme as used by LAPACK.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The algorithm used to perform the decomposition is Householder QR (Golub &amp; Van Loan, Matrix Computations, Algorithm 5.2.1).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QR_decomp</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>, <span class="ident">tau</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QR_decomp</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>), <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">tau</span>))
    })
}

<span class="doccomment">/// This function solves the square system A x = b using the QR decomposition of A held in (QR, tau) which must have been computed previously</span>
<span class="doccomment">/// with gsl_linalg_QR_decomp. The least-squares solution for rectangular systems can be found using QR_lssolve.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QR_solve</span>(
    <span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QR_solve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the square system A x = b in-place using the QR decomposition of A held in (QR,tau) which must have been computed</span>
<span class="doccomment">/// previously by gsl_linalg_QR_decomp. On input x should contain the right-hand side b, which is replaced by the solution on output.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QR_svx</span>(<span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QR_svx</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>),
                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau</span>),
                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function finds the least squares solution to the overdetermined system A x = b where the matrix A has more rows than columns. The</span>
<span class="doccomment">/// least squares solution minimizes the Euclidean norm of the residual, ||Ax - b||.The routine requires as input the QR decomposition of</span>
<span class="doccomment">/// A into (QR, tau) given by gsl_linalg_QR_decomp. The solution is returned in x. The residual is computed as a by-product and stored in</span>
<span class="doccomment">/// residual.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QR_lssolve</span>(<span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
                  <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
                  <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
                  <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
                  <span class="ident">residual</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>)
                  <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QR_lssolve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>),
                                   <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau</span>),
                                   <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                   <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>),
                                   <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">residual</span>))
    })
}

<span class="doccomment">/// This function applies the matrix Q^T encoded in the decomposition (QR,tau) to the vector v, storing the result Q^T v in v. The matrix</span>
<span class="doccomment">/// multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QR_QTvec</span>(<span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>, <span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QR_QTvec</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">v</span>))
    })
}

<span class="doccomment">/// This function applies the matrix Q encoded in the decomposition (QR,tau) to the vector v, storing the result Q v in v. The matrix</span>
<span class="doccomment">/// multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QR_Qvec</span>(<span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>, <span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QR_Qvec</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>),
                                <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau</span>),
                                <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">v</span>))
    })
}

<span class="doccomment">/// This function applies the matrix Q^T encoded in the decomposition (QR,tau) to the matrix A, storing the result Q^T A in A. The matrix</span>
<span class="doccomment">/// multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QR_QTmat</span>(<span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>, <span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QR_QTmat</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">v</span>))
    })
}

<span class="doccomment">/// This function solves the triangular system R x = b for x. It may be useful if the product b&#39; = Q^T b has already been computed using</span>
<span class="doccomment">/// gsl_linalg_QR_QTvec.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QR_Rsolve</span>(<span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QR_Rsolve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the triangular system R x = b for x in-place. On input x should contain the right-hand side b and is replaced by</span>
<span class="doccomment">/// the solution on output. This function may be useful if the product b&#39; = Q^T b has already been computed using gsl_linalg_QR_QTvec.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QR_Rsvx</span>(<span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QR_Rsvx</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>), <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function unpacks the encoded QR decomposition (QR,tau) into the matrices Q and R, where Q is M-by-M and R is M-by-N.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QR_unpack</span>(
    <span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">q</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">r</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QR_unpack</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">q</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">r</span>))
    })
}

<span class="doccomment">/// This function solves the system R x = Q^T b for x. It can be used when the QR decomposition of a matrix is available in unpacked</span>
<span class="doccomment">/// form as (Q, R).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QR_QRsolve</span>(
    <span class="ident">q</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">r</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QR_QRsolve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">q</span>),
                                   <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">r</span>),
                                   <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                   <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function performs a rank-1 update w v^T of the QR decomposition (Q, R). The update is given by Q&#39;R&#39; = Q (R + w v^T) where the</span>
<span class="doccomment">/// output matrices Q&#39; and R&#39; are also orthogonal and right triangular. Note that w is destroyed by the update.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QR_update</span>(
    <span class="ident">q</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">r</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="kw-2">mut</span> <span class="ident">w</span>: ::<span class="ident">VectorF64</span>,
    <span class="ident">v</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QR_update</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">q</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">r</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">w</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">v</span>))
    })
}

<span class="doccomment">/// This function solves the triangular system R x = b for the N-by-N matrix R.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">R_solve</span>(<span class="ident">r</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_R_solve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">r</span>),
                                <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the triangular system R x = b in-place. On input x should contain the right-hand side b, which is replaced by</span>
<span class="doccomment">/// the solution on output.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">R_svx</span>(<span class="ident">r</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_R_svx</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">r</span>), <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function factorizes the M-by-N matrix A into the QRP^T decomposition A = Q R P^T. On output the diagonal and upper triangular part</span>
<span class="doccomment">/// of the input matrix contain the matrix R. The permutation matrix P is stored in the permutation p. The sign of the permutation is given</span>
<span class="doccomment">/// by signum. It has the value (-1)^n, where n is the number of interchanges in the permutation. The vector tau and the columns of the lower</span>
<span class="doccomment">/// triangular part of the matrix A contain the Householder coefficients and vectors which encode the orthogonal matrix Q. The vector tau must</span>
<span class="doccomment">/// be of length k=\min(M,N). The matrix Q is related to these components by, Q = Q_k ... Q_2 Q_1 where Q_i = I - \tau_i v_i v_i^T and v_i is</span>
<span class="doccomment">/// the Householder vector v_i = (0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme as used by LAPACK. The vector norm is</span>
<span class="doccomment">/// a workspace of length N used for column pivoting.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The algorithm used to perform the decomposition is Householder QR with column pivoting (Golub &amp; Van Loan, Matrix Computations, Algorithm 5.4.1).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QRPT_decomp</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">Permutation</span>,
    <span class="ident">signum</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">i32</span>,
    <span class="ident">norm</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QRPT_decomp</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>),
                                    <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">tau</span>),
                                    <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">p</span>),
                                    <span class="ident">signum</span>,
                                    <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">norm</span>))
    })
}

<span class="doccomment">/// This function factorizes the matrix A into the decomposition A = Q R P^T without modifying A itself and storing the output in the separate</span>
<span class="doccomment">/// matrices q and r.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QRPT_decomp2</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">q</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">r</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">Permutation</span>,
    <span class="ident">signum</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">i32</span>,
    <span class="ident">norm</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QRPT_decomp2</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">a</span>),
                                     <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">q</span>),
                                     <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">r</span>),
                                     <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">tau</span>),
                                     <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">p</span>),
                                     <span class="ident">signum</span>,
                                     <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">norm</span>))
    })
}

<span class="doccomment">/// This function solves the square system A x = b using the QRP^T decomposition of A held in (QR, tau, p) which must have been computed previously</span>
<span class="doccomment">/// by QRPT_decomp.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QRPT_solve</span>(
    <span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QRPT_solve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>),
                                   <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau</span>),
                                   <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                   <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                   <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the square system A x = b in-place using the QRP^T decomposition of A held in (QR,tau,p). On input x should contain the</span>
<span class="doccomment">/// right-hand side b, which is replaced by the solution on output.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QRPT_svx</span>(
    <span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QRPT_svx</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the square system R P^T x = Q^T b for x. It can be used when the QR decomposition of a matrix is available in unpacked</span>
<span class="doccomment">/// form as (Q, R).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QRPT_QRsolve</span>(
    <span class="ident">q</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">r</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QRPT_QRsolve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">q</span>),
                                     <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">r</span>),
                                     <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                     <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                     <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function performs a rank-1 update w v^T of the QRP^T decomposition (Q, R, p). The update is given by Q&#39;R&#39; = Q (R + w v^T P) where the</span>
<span class="doccomment">/// output matrices Q&#39; and R&#39; are also orthogonal and right triangular. Note that w is destroyed by the update. The permutation p is not changed.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QRPT_update</span>(
    <span class="ident">q</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">r</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>,
    <span class="ident">w</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">v</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QRPT_update</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">q</span>),
                                    <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">r</span>),
                                    <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                    <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">w</span>),
                                    <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">v</span>))
    })
}

<span class="doccomment">/// This function solves the triangular system R P^T x = b for the N-by-N matrix R contained in QR.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QRPT_Rsolve</span>(
    <span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QRPT_Rsolve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>),
                                    <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                    <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                    <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the triangular system R P^T x = b in-place for the N-by-N matrix R contained in QR. On input x should contain the</span>
<span class="doccomment">/// right-hand side b, which is replaced by the solution on output.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">QRPT_Rsvx</span>(<span class="ident">qr</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span>::<span class="ident">Permutation</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_QRPT_Rsvx</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">qr</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">p</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function factorizes the M-by-N matrix A into the singular value decomposition A = U S V^T for M &gt;= N. On output the matrix A is replaced</span>
<span class="doccomment">/// by U. The diagonal elements of the singular value matrix S are stored in the vector S. The singular values are non-negative and form a</span>
<span class="doccomment">/// non-increasing sequence from S_1 to S_N. The matrix V contains the elements of V in untransposed form. To form the product U S V^T it is</span>
<span class="doccomment">/// necessary to take the transpose of V. A workspace of length N is required in work.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This routine uses the Golub-Reinsch SVD algorithm.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">SV_decomp</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">work</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_SV_decomp</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">v</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">s</span>),
                                  <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">work</span>))
    })
}

<span class="doccomment">/// This function computes the SVD using the modified Golub-Reinsch algorithm, which is faster for M&gt;&gt;N. It requires the vector work of length</span>
<span class="doccomment">/// N and the N-by-N matrix X as additional working space.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">SV_decomp_mod</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">work</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_SV_decomp_mod</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">v</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">s</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">work</span>))
    })
}

<span class="doccomment">/// This function computes the SVD of the M-by-N matrix A using one-sided Jacobi orthogonalization for M &gt;= N. The Jacobi method can compute</span>
<span class="doccomment">/// singular values to higher relative accuracy than Golub-Reinsch algorithms (see references for details).</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">SV_decomp_jacobi</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>, <span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>, <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_SV_decomp_jacobi</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>),
                                         <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">v</span>),
                                         <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">s</span>))
    })
}

<span class="doccomment">/// This function solves the system A x = b using the singular value decomposition (U, S, V) of A which must have been computed previously</span>
<span class="doccomment">/// with gsl_linalg_SV_decomp.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Only non-zero singular values are used in computing the solution. The parts of the solution corresponding to singular values of zero are</span>
<span class="doccomment">/// ignored. Other singular values can be edited out by setting them to zero before calling this function.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// In the over-determined case where A has more rows than columns the system is solved in the least squares sense, returning the solution</span>
<span class="doccomment">/// x which minimizes ||A x - b||_2.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">SV_solve</span>(
    <span class="ident">u</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">v</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">s</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_SV_solve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">u</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">v</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">s</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function computes the statistical leverage values h_i of a matrix A using its singular value decomposition (U, S, V) previously computed</span>
<span class="doccomment">/// with gsl_linalg_SV_decomp. h_i are the diagonal values of the matrix A (A^T A)^{-1} A^T and depend only on the matrix U which is the input to</span>
<span class="doccomment">/// this function.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">SV_leverage</span>(<span class="ident">u</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">h</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_SV_leverage</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">u</span>), <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">h</span>))
    })
}

<span class="doccomment">/// This function factorizes the symmetric, positive-definite square matrix A into the Cholesky decomposition A = L L^T (or A = L L^H for</span>
<span class="doccomment">/// the complex case). On input, the values from the diagonal and lower-triangular part of the matrix A are used (the upper triangular part</span>
<span class="doccomment">/// is ignored). On output the diagonal and lower triangular part of the input matrix A contain the matrix L, while the upper triangular part</span>
<span class="doccomment">/// of the input matrix is overwritten with L^T (the diagonal terms being identical for both L and L^T). If the matrix is not positive-definite</span>
<span class="doccomment">/// then the decomposition will fail, returning the error code ::Dom.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// When testing whether a matrix is positive-definite, disable the error handler first to avoid triggering an error.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">cholesky_decomp</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_linalg_cholesky_decomp</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>)) })
}

<span class="doccomment">/// This function factorizes the symmetric, positive-definite square matrix A into the Cholesky decomposition A = L L^T (or A = L L^H for</span>
<span class="doccomment">/// the complex case). On input, the values from the diagonal and lower-triangular part of the matrix A are used (the upper triangular part</span>
<span class="doccomment">/// is ignored). On output the diagonal and lower triangular part of the input matrix A contain the matrix L, while the upper triangular part</span>
<span class="doccomment">/// of the input matrix is overwritten with L^T (the diagonal terms being identical for both L and L^T). If the matrix is not positive-definite</span>
<span class="doccomment">/// then the decomposition will fail, returning the error code ::Dom.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// When testing whether a matrix is positive-definite, disable the error handler first to avoid triggering an error.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_cholesky_decomp</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_cholesky_decomp</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>))
    })
}

<span class="doccomment">/// This function solves the system A x = b using the Cholesky decomposition of A held in the matrix cholesky which must have been previously</span>
<span class="doccomment">/// computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">cholesky_solve</span>(
    <span class="ident">cholesky</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_cholesky_solve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">cholesky</span>),
                                       <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                       <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the system A x = b using the Cholesky decomposition of A held in the matrix cholesky which must have been previously</span>
<span class="doccomment">/// computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_cholesky_solve</span>(
    <span class="ident">cholesky</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixComplexF64</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorComplexF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorComplexF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_cholesky_solve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">cholesky</span>),
                                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the system A x = b in-place using the Cholesky decomposition of A held in the matrix cholesky which must have been</span>
<span class="doccomment">/// previously computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On input x should contain the right-hand side</span>
<span class="doccomment">/// b, which is replaced by the solution on output.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">cholesky_svx</span>(<span class="ident">cholesky</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_cholesky_svx</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">cholesky</span>),
                                     <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the system A x = b in-place using the Cholesky decomposition of A held in the matrix cholesky which must have been</span>
<span class="doccomment">/// previously computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On input x should contain the right-hand side</span>
<span class="doccomment">/// b, which is replaced by the solution on output.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_cholesky_svx</span>(<span class="ident">cholesky</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixComplexF64</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorComplexF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_cholesky_svx</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">cholesky</span>),
                                             <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function computes the inverse of a matrix from its Cholesky decomposition cholesky, which must have been previously computed by</span>
<span class="doccomment">/// gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On output, the inverse is stored in-place in cholesky.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">cholesky_invert</span>(<span class="ident">cholesky</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_cholesky_invert</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">cholesky</span>))
    })
}

<span class="doccomment">/// This function computes the inverse of a matrix from its Cholesky decomposition cholesky, which must have been previously computed by</span>
<span class="doccomment">/// gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On output, the inverse is stored in-place in cholesky.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_cholesky_invert</span>(<span class="ident">cholesky</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_cholesky_invert</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">cholesky</span>))
    })
}

<span class="doccomment">/// This function factorizes the symmetric square matrix A into the symmetric tridiagonal decomposition Q T Q^T. On output the diagonal and</span>
<span class="doccomment">/// subdiagonal part of the input matrix A contain the tridiagonal matrix T. The remaining lower triangular part of the input matrix contains</span>
<span class="doccomment">/// the Householder vectors which, together with the Householder coefficients tau, encode the orthogonal matrix Q. This storage scheme is</span>
<span class="doccomment">/// the same as used by LAPACK. The upper triangular part of A is not referenced.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">symmtd_decomp</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>, <span class="ident">tau</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_symmtd_decomp</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>), <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">tau</span>))
    })
}

<span class="doccomment">/// This function unpacks the encoded symmetric tridiagonal decomposition (A, tau) obtained from gsl_linalg_symmtd_decomp into the orthogonal</span>
<span class="doccomment">/// matrix Q, the vector of diagonal elements diag and the vector of subdiagonal elements subdiag.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">symmtd_unpack</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">q</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">diag</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">subdiag</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_symmtd_unpack</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">a</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">q</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">diag</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">subdiag</span>))
    })
}

<span class="doccomment">/// This function unpacks the diagonal and subdiagonal of the encoded symmetric tridiagonal decomposition (A, tau) obtained from</span>
<span class="doccomment">/// gsl_linalg_symmtd_decomp into the vectors diag and subdiag.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">symmtd_unpack_T</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">diag</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">subdiag</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_symmtd_unpack_T</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">a</span>),
                                        <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">diag</span>),
                                        <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">subdiag</span>))
    })
}

<span class="doccomment">/// This function factorizes the hermitian matrix A into the symmetric tridiagonal decomposition U T U^T. On output the real parts of the</span>
<span class="doccomment">/// diagonal and subdiagonal part of the input matrix A contain the tridiagonal matrix T. The remaining lower triangular part of the input</span>
<span class="doccomment">/// matrix contains the Householder vectors which, together with the Householder coefficients tau, encode the unitary matrix U. This storage</span>
<span class="doccomment">/// scheme is the same as used by LAPACK. The upper triangular part of A and imaginary parts of the diagonal are not referenced.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hermtd_decomp</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>, <span class="ident">tau</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorComplexF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_hermtd_decomp</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>), <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">tau</span>))
    })
}

<span class="doccomment">/// This function unpacks the encoded tridiagonal decomposition (A, tau) obtained from gsl_linalg_hermtd_decomp into the unitary matrix U,</span>
<span class="doccomment">/// the real vector of diagonal elements diag and the real vector of subdiagonal elements subdiag.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hermtd_unpack</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixComplexF64</span>,
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorComplexF64</span>,
    <span class="ident">u</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>,
    <span class="ident">diag</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">subdiag</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_hermtd_unpack</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">a</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">u</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">diag</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">subdiag</span>))
    })
}

<span class="doccomment">/// This function unpacks the diagonal and subdiagonal of the encoded tridiagonal decomposition (A, tau) obtained from the</span>
<span class="doccomment">/// gsl_linalg_hermtd_decomp into the real vectors diag and subdiag.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hermtd_unpack_T</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixComplexF64</span>,
    <span class="ident">diag</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">subdiag</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_hermtd_unpack_T</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">a</span>),
                                        <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">diag</span>),
                                        <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">subdiag</span>))
    })
}

<span class="doccomment">/// This function computes the Hessenberg decomposition of the matrix A by applying the similarity transformation H = U^T A U. On output, H</span>
<span class="doccomment">/// is stored in the upper portion of A. The information required to construct the matrix U is stored in the lower triangular portion of A.</span>
<span class="doccomment">/// U is a product of N - 2 Householder matrices. The Householder vectors are stored in the lower portion of A (below the subdiagonal) and</span>
<span class="doccomment">/// the Householder coefficients are stored in the vector tau. tau must be of length N.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hessenberg_decomp</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>, <span class="ident">tau</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_hessenberg_decomp</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>), <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">tau</span>))
    })
}

<span class="doccomment">/// This function constructs the orthogonal matrix U from the information stored in the Hessenberg matrix H along with the vector tau. H and</span>
<span class="doccomment">/// tau are outputs from gsl_linalg_hessenberg_decomp.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hessenberg_unpack</span>(
    <span class="ident">h</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">u</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_hessenberg_unpack</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">h</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">tau</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">u</span>))
    })
}

<span class="doccomment">/// This function is similar to gsl_linalg_hessenberg_unpack, except it accumulates the matrix U into V, so that V&#39; = VU. The matrix V must</span>
<span class="doccomment">/// be initialized prior to calling this function. Setting V to the identity matrix provides the same result as gsl_linalg_hessenberg_unpack.</span>
<span class="doccomment">/// If H is order N, then V must have N columns but may have any number of rows.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hessenberg_unpack_accum</span>(
    <span class="ident">h</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_hessenberg_unpack_accum</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">h</span>),
                                                <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">tau</span>),
                                                <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">v</span>))
    })
}

<span class="doccomment">/// This function sets the lower triangular portion of H, below the subdiagonal, to zero. It is useful for clearing out the Householder</span>
<span class="doccomment">/// vectors after calling gsl_linalg_hessenberg_decomp.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hessenberg_set_zero</span>(<span class="ident">h</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_linalg_hessenberg_set_zero</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">h</span>)) })
}

<span class="doccomment">/// This function computes the Hessenberg-Triangular decomposition of the matrix pair (A, B). On output, H is stored in A, and R is stored</span>
<span class="doccomment">/// in B. If U and V are provided (they may be null), the similarity transformations are stored in them. Additional workspace of length N</span>
<span class="doccomment">/// is needed in work.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hesstri_decomp</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">u</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">work</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_hesstri_decomp</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>),
                                       <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">b</span>),
                                       <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">u</span>),
                                       <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">v</span>),
                                       <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">work</span>))
    })
}

<span class="doccomment">/// This function factorizes the M-by-N matrix A into bidiagonal form U B V^T. The diagonal and superdiagonal of the matrix B are stored in</span>
<span class="doccomment">/// the diagonal and superdiagonal of A. The orthogonal matrices U and V are stored as compressed Householder vectors in the remaining elements</span>
<span class="doccomment">/// of A. The Householder coefficients are stored in the vectors tau_U and tau_V. The length of tau_U must equal the number of elements in</span>
<span class="doccomment">/// the diagonal of A and the length of tau_V should be one element shorter.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bidiag_decomp</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">tau_u</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">tau_v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_bidiag_decomp</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">tau_u</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">tau_v</span>))
    })
}

<span class="doccomment">/// This function unpacks the bidiagonal decomposition of A produced by gsl_linalg_bidiag_decomp, (A, tau_U, tau_V) into the separate orthogonal</span>
<span class="doccomment">/// matrices U, V and the diagonal vector diag and superdiagonal superdiag. Note that U is stored as a compact M-by-N orthogonal matrix satisfying</span>
<span class="doccomment">/// U^T U = I for efficiency.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bidiag_unpack</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">tau_u</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">u</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">tau_v</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">diag</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">superdiag</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_bidiag_unpack</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau_u</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">u</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">tau_v</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">v</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">diag</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">superdiag</span>))
    })
}

<span class="doccomment">/// This function unpacks the bidiagonal decomposition of A produced by gsl_linalg_bidiag_decomp, (A, tau_U, tau_V) into the separate orthogonal</span>
<span class="doccomment">/// matrices U, V and the diagonal vector diag and superdiagonal superdiag. The matrix U is stored in-place in A.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bidiag_unpack2</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
    <span class="ident">tau_u</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">tau_v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_bidiag_unpack2</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>),
                                       <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">tau_u</span>),
                                       <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">tau_v</span>),
                                       <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">v</span>))
    })
}

<span class="doccomment">/// This function unpacks the diagonal and superdiagonal of the bidiagonal decomposition of A from gsl_linalg_bidiag_decomp, into the diagonal</span>
<span class="doccomment">/// vector diag and superdiagonal vector superdiag.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bidiag_unpack_B</span>(
    <span class="ident">a</span>: <span class="kw-2">&amp;</span>::<span class="ident">MatrixF64</span>,
    <span class="ident">diag</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
    <span class="ident">superdiag</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_bidiag_unpack_B</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">a</span>),
                                        <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">diag</span>),
                                        <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">superdiag</span>))
    })
}

<span class="doccomment">/// This function prepares a Householder transformation P = I - \tau v v^T which can be used to zero all the elements of the input vector except</span>
<span class="doccomment">/// the first. On output the transformation is stored in the vector v and the scalar \tau is returned.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">householder_transform</span>(<span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">f64</span> {
    <span class="kw">unsafe</span> { <span class="ident">ffi</span>::<span class="ident">gsl_linalg_householder_transform</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">v</span>)) }
}

<span class="doccomment">/// This function prepares a Householder transformation P = I - \tau v v^T which can be used to zero all the elements of the input vector except</span>
<span class="doccomment">/// the first. On output the transformation is stored in the vector v and the scalar \tau is returned.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_householder_transform</span>(<span class="ident">v</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorComplexF64</span>) <span class="op">-&gt;</span> ::<span class="ident">ComplexF64</span> {
    <span class="kw">unsafe</span> {
        ::<span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">transmute</span>(<span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_householder_transform</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">v</span>)))
    }
}

<span class="doccomment">/// This function applies the Householder matrix P defined by the scalar tau and the vector v to the left-hand side of the matrix A. On output</span>
<span class="doccomment">/// the result P A is stored in A.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">householder_hm</span>(<span class="ident">tau</span>: <span class="ident">f64</span>, <span class="ident">v</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>, <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_householder_hm</span>(<span class="ident">tau</span>, <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">v</span>), <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>))
    })
}

<span class="doccomment">/// This function applies the Householder matrix P defined by the scalar tau and the vector v to the left-hand side of the matrix A. On output</span>
<span class="doccomment">/// the result P A is stored in A.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_householder_hm</span>(
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">ComplexF64</span>,
    <span class="ident">v</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorComplexF64</span>,
    <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_householder_hm</span>(::<span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">transmute</span>(<span class="kw-2">*</span><span class="ident">tau</span>),
                                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">v</span>),
                                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>))
    })
}

<span class="doccomment">/// This function applies the Householder matrix P defined by the scalar tau and the vector v to the right-hand side of the matrix A. On output</span>
<span class="doccomment">/// the result A P is stored in A.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">householder_mh</span>(<span class="ident">tau</span>: <span class="ident">f64</span>, <span class="ident">v</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>, <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_householder_mh</span>(<span class="ident">tau</span>, <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">v</span>), <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>))
    })
}

<span class="doccomment">/// This function applies the Householder matrix P defined by the scalar tau and the vector v to the right-hand side of the matrix A. On output</span>
<span class="doccomment">/// the result A P is stored in A.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_householder_mh</span>(
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">ComplexF64</span>,
    <span class="ident">v</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorComplexF64</span>,
    <span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_householder_mh</span>(::<span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">transmute</span>(<span class="kw-2">*</span><span class="ident">tau</span>),
                                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">v</span>),
                                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>))
    })
}

<span class="doccomment">/// This function applies the Householder transformation P defined by the scalar tau and the vector v to the vector w. On output the result P</span>
<span class="doccomment">/// w is stored in w.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">householder_hv</span>(<span class="ident">tau</span>: <span class="ident">f64</span>, <span class="ident">v</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>, <span class="ident">w</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_householder_hv</span>(<span class="ident">tau</span>, <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">v</span>), <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">w</span>))
    })
}

<span class="doccomment">/// This function applies the Householder transformation P defined by the scalar tau and the vector v to the vector w. On output the result P</span>
<span class="doccomment">/// w is stored in w.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">complex_householder_hv</span>(
    <span class="ident">tau</span>: <span class="kw-2">&amp;</span>::<span class="ident">ComplexF64</span>,
    <span class="ident">v</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorComplexF64</span>,
    <span class="ident">w</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixComplexF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_complex_householder_hv</span>(::<span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">transmute</span>(<span class="kw-2">*</span><span class="ident">tau</span>),
                                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">v</span>),
                                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">w</span>))
    })
}

<span class="doccomment">/// This function solves the system A x = b directly using Householder transformations. On output the solution is stored in x and b is not</span>
<span class="doccomment">/// modified. The matrix A is destroyed by the Householder transformations.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">HH_solve</span>(<span class="kw-2">mut</span> <span class="ident">a</span>: ::<span class="ident">MatrixF64</span>, <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_HH_solve</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">a</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                 <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the system A x = b in-place using Householder transformations. On input x should contain the right-hand side b,</span>
<span class="doccomment">/// which is replaced by the solution on output. The matrix A is destroyed by the Householder transformations.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">HH_svx</span>(<span class="kw-2">mut</span> <span class="ident">a</span>: ::<span class="ident">MatrixF64</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_HH_svx</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">a</span>), <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the general N-by-N system A x = b where A is tridiagonal (N &gt;= 2). The super-diagonal and sub-diagonal vectors</span>
<span class="doccomment">/// e and f must be one element shorter than the diagonal vector diag. The form of A for the 4-by-4 case is shown below,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```text</span>
<span class="doccomment">/// A = ( d_0 e_0  0   0  )</span>
<span class="doccomment">///     ( f_0 d_1 e_1  0  )</span>
<span class="doccomment">///     (  0  f_1 d_2 e_2 )</span>
<span class="doccomment">///     (  0   0  f_2 d_3 )</span>
<span class="doccomment">/// ```</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">solve_tridiag</span>(
    <span class="ident">diag</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">e</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">f</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_solve_tridiag</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">diag</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">e</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">f</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                      <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the general N-by-N system A x = b where A is symmetric tridiagonal (N &gt;= 2). The off-diagonal vector e must be one</span>
<span class="doccomment">/// element shorter than the diagonal vector diag. The form of A for the 4-by-4 case is shown below,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```text</span>
<span class="doccomment">/// A = ( d_0 e_0  0   0  )</span>
<span class="doccomment">///     ( e_0 d_1 e_1  0  )</span>
<span class="doccomment">///     (  0  e_1 d_2 e_2 )</span>
<span class="doccomment">///     (  0   0  e_2 d_3 )</span>
<span class="doccomment">/// ```</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">solve_symm_tridiag</span>(
    <span class="ident">diag</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">e</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_solve_symm_tridiag</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">diag</span>),
                                           <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">e</span>),
                                           <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                           <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the general N-by-N system A x = b where A is cyclic tridiagonal (N &gt;= 3). The cyclic super-diagonal and sub-diagonal</span>
<span class="doccomment">/// vectors e and f must have the same number of elements as the diagonal vector diag. The form of A for the 4-by-4 case is shown below,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```text</span>
<span class="doccomment">/// A = ( d_0 e_0  0  f_3 )</span>
<span class="doccomment">///     ( f_0 d_1 e_1  0  )</span>
<span class="doccomment">///     (  0  f_1 d_2 e_2 )</span>
<span class="doccomment">///     ( e_3  0  f_2 d_3 )</span>
<span class="doccomment">/// ```</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">solve_cyc_tridiag</span>(
    <span class="ident">diag</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">e</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">f</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_solve_cyc_tridiag</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">diag</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">e</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">f</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                          <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function solves the general N-by-N system A x = b where A is symmetric cyclic tridiagonal (N &gt;= 3). The cyclic off-diagonal vector</span>
<span class="doccomment">/// e must have the same number of elements as the diagonal vector diag. The form of A for the 4-by-4 case is shown below,</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```text</span>
<span class="doccomment">/// A = ( d_0 e_0  0  e_3 )</span>
<span class="doccomment">///     ( e_0 d_1 e_1  0  )</span>
<span class="doccomment">///     (  0  e_1 d_2 e_2 )</span>
<span class="doccomment">///     ( e_3  0  e_2 d_3 )</span>
<span class="doccomment">/// ```</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">solve_symm_cyc_tridiag</span>(
    <span class="ident">diag</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">e</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">b</span>: <span class="kw-2">&amp;</span>::<span class="ident">VectorF64</span>,
    <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>,
) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_solve_symm_cyc_tridiag</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">diag</span>),
                                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">e</span>),
                                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_shared</span>(<span class="ident">b</span>),
                                               <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">x</span>))
    })
}

<span class="doccomment">/// This function replaces the matrix A with its balanced counterpart and stores the diagonal elements of the similarity transformation into</span>
<span class="doccomment">/// the vector D.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">balance_matrix</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">MatrixF64</span>, <span class="ident">d</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> ::<span class="ident">VectorF64</span>) <span class="op">-&gt;</span> <span class="ident">enums</span>::<span class="ident">Value</span> {
    <span class="ident">enums</span>::<span class="ident">Value</span>::<span class="ident">from</span>(<span class="kw">unsafe</span> {
        <span class="ident">ffi</span>::<span class="ident">gsl_linalg_balance_matrix</span>(<span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">a</span>), <span class="ident">ffi</span>::<span class="ident">FFI</span>::<span class="ident">unwrap_unique</span>(<span class="ident">d</span>))
    })
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "rgsl";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>MathJax.Hub.Config({TeX: {Macros: {dd: "{\\mathop{}\\!\\mathrm{d}}", textsc: ["\\mathrm{\\scriptsize #1}", 1], vt: ["\\boldsymbol{#1}", 1], pfrac: ["\\frac{\\partial #1}{\\partial #2}", 2], ddfrac: ["\\frac{\\dd #1}{\\dd #2}", 2], defeq: "\\mathrel{\\vcenter:}=", abs: ["\\lvert #1 \\rvert", 1], angles: ["\\langle #1 \\rangle", 1]}}});</script></body></html>